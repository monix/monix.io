<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  
  <title>Task &mdash; Monix</title>

  <link rel="canonical" href="https://monix.io/docs/current/eval/task.html" />

  <!-- Twitter Cards -->
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:image:src" content="https://monix.io/public/images/monix-logo-rect.png">
  <meta name="twitter:site" content="@monix" />  
  <meta name="twitter:creator" content="@monix" />  
  <meta name="twitter:title" content="Task &amp;mdash; Monix" />
  <meta name="twitter:description" content="A data type for controlling possibly lazy &amp;amp; asynchronous computations, useful for controlling side-effects, avoiding nondeterminism and callback-hell." />
  <meta name="twitter:url" content="https://monix.io/docs/2x/eval/task.html">
  <!-- Facebook Open-Graph -->
  <meta property="fb:app_id" content="2160100887367418" />

  <meta content="Monix" property="og:site_name">
  <meta content="Task &amp;mdash; Monix" property="og:title">
  <meta content="A data type for controlling possibly lazy &amp;amp; asynchronous computations, useful for controlling side-effects, avoiding nondeterminism and callback-hell." property="og:description">
  <meta content="https://monix.io/docs/2x/eval/task.html" property="og:url">
  <meta content="2016-10-10T15:02:35+00:00" property="article:modified_time">
    
  <meta content="article" property="og:type">
  <meta property="og:image" content="https://monix.io/public/images/monix-logo.png" />
  <meta property="og:image:secure_url" content="https://monix.io/public/images/monix-logo.png" />
  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/all.css?1648574008277833500">
  <!--[if lt IE 9]>
  <link rel="stylesheet" href="/public/css/forkme.ie.css?1648574008277833500">
  <![endif]-->

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Web App Manifest, see: http://manifest.sysapps.org/ -->
  <link rel="manifest" href="/manifest.json">
  <!-- Icons -->
  <link rel="icon" sizes="48x48" href="/public/icons/icon-48x48.png">
  <link rel="icon" sizes="72x72" href="/public/icons/icon-72x72.png">
  <link rel="icon" sizes="96x96" href="/public/icons/icon-96x96.png">
  <link rel="icon" sizes="144x144" href="/public/icons/icon-144x144.png">
  <link rel="icon" sizes="192x192" href="/public/icons/icon-192x192.png">
  <link rel="icon" sizes="240x240" href="/public/icons/icon-240x240.png">
  <link rel="icon" sizes="384x384" href="/public/icons/icon-384x384.png">
  <!-- Mobile Safari / iOS Icons -->
  <link rel="apple-touch-icon" sizes="48x48" href="/public/icons/icon-48x48.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/public/icons/icon-72x72.png">
  <link rel="apple-touch-icon" sizes="96x96" href="/public/icons/icon-96x96.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/public/icons/icon-144x144.png">
  <link rel="apple-touch-icon" sizes="192x192" href="/public/icons/icon-192x192.png">
  <link rel="apple-touch-icon" sizes="240x240" href="/public/icons/icon-240x240.png">
  <link rel="apple-touch-icon" sizes="384x384" href="/public/icons/icon-384x384.png">
  <!-- Standard Favicon -->
  <link rel="shortcut icon" href="/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="Feed" href="/blog/atom.xml">
</head>


  <body class="monix layout">
    <div class="wrapper">
      <aside class="sidebar plus">
  <div class="container">
    <div class="sidebar-about">
      <a class="github-fork-ribbon left-top" href="https://github.com/monix/monix"
        title="Fork me on GitHub">Fork me on GitHub</a>

      <h1>
        <a href="/">
          <img src="/public/images/monix-logo.png"
            alt="Monix Logo" title="Monix" class="logo" />
        </a>
      </h1>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">About</a>
      <a class="sidebar-nav-item" href="/blog/">Blog</a>
      <a class="sidebar-nav-item active" href="/docs/current/">Documentation</a>
      <a class="sidebar-nav-item" href="/presentations/">Presentations</a>
      <a class="sidebar-nav-item" href="/social.html">Follow @Monix</a>
      <a class="sidebar-nav-item" href="/privacy.html">Privacy Policy</a>
    </nav>
  </div>
</aside>


      <article class="content container">
        <div class="page">
      <h1 class="page-title">
        
        
          Task
        
        
      </h1>

  
  <time class="post-date" itemprop="dateModified"
    datetime="2016-10-10">
    <b>Page updated at:</b> 10 Oct 2016
  </time>
  <nav role="navigation" id="type-info">
    <a href="/api/2.3/monix/eval/Task.html">API Documentation</a>
    <a href="https://github.com/monix/monix/blob/v2.3.3/monix-eval/shared/src/main/scala/monix/eval/Task.scala">Source Code</a>
    
    <a href="https://github.com/monix/monix.io/blob/main/_docs/2x/eval/task.md">Edit Page</a>
  </nav>
  
  <div id="version2x">
    You are viewing the documentation for the <em>older</em> Monix 2.x series.<br />
    For the latest version:
    <a href="/docs/current/eval/task.html">see here</a>!
  </div>

  <nav role="navigation" id="toc">
    <ul>
  <li><a href="#introduction">Introduction</a>
    <ul>
      <li><a href="#design-summary">Design Summary</a></li>
      <li><a href="#comparison-with-scalas-future">Comparison with Scala’s Future</a></li>
      <li><a href="#comparison-with-the-scalaz-task">Comparison with the Scalaz Task</a></li>
    </ul>
  </li>
  <li><a href="#execution-runasync--foreach">Execution (runAsync &amp; foreach)</a>
    <ul>
      <li><a href="#blocking-for-a-result">Blocking for a Result</a></li>
      <li><a href="#try-immediate-execution-coeval">Try Immediate Execution (Coeval)</a></li>
    </ul>
  </li>
  <li><a href="#simple-builders">Simple Builders</a>
    <ul>
      <li><a href="#tasknow">Task.now</a></li>
      <li><a href="#taskeval-delay">Task.eval (delay)</a></li>
      <li><a href="#taskevalonce">Task.evalOnce</a></li>
      <li><a href="#taskdefer-suspend">Task.defer (suspend)</a></li>
      <li><a href="#taskfromfuture">Task.fromFuture</a></li>
      <li><a href="#taskdeferfuture">Task.deferFuture</a></li>
      <li><a href="#taskdeferfutureaction">Task.deferFutureAction</a></li>
      <li><a href="#taskfork--taskasyncboundary">Task.fork &amp;&amp; Task.asyncBoundary</a></li>
      <li><a href="#taskraiseerror">Task.raiseError</a></li>
      <li><a href="#tasknever">Task.never</a></li>
      <li><a href="#taskunit">Task.unit</a></li>
    </ul>
  </li>
  <li><a href="#asynchronous-builders">Asynchronous Builders</a>
    <ul>
      <li><a href="#taskcreate">Task.create</a></li>
      <li><a href="#taskunsafecreate">Task.unsafeCreate</a></li>
    </ul>
  </li>
  <li><a href="#memoization">Memoization</a>
    <ul>
      <li><a href="#memoize-only-on-success">Memoize Only on Success</a></li>
      <li><a href="#memoize-versus-runasync">Memoize versus runAsync</a></li>
    </ul>
  </li>
  <li><a href="#operations">Operations</a>
    <ul>
      <li><a href="#flatmap-and-tail-recursive-loops">FlatMap and Tail-Recursive Loops</a></li>
      <li><a href="#the-applicative-zip2-zip3--zip6">The Applicative: zip2, zip3, … zip6</a></li>
      <li><a href="#gather-results-from-a-seq-of-tasks">Gather results from a Seq of Tasks</a></li>
      <li><a href="#choose-first-of-two-tasks">Choose First Of Two Tasks</a></li>
      <li><a href="#choose-first-of-list">Choose First Of List</a></li>
      <li><a href="#delay-execution">Delay Execution</a></li>
      <li><a href="#delay-signaling-of-the-result">Delay Signaling of the Result</a></li>
      <li><a href="#restart-until-predicate-is-true">Restart Until Predicate is True</a></li>
      <li><a href="#clean-up-resources-on-finish">Clean-up Resources on Finish</a></li>
      <li><a href="#convert-to-reactive-publisher">Convert to Reactive Publisher</a></li>
    </ul>
  </li>
  <li><a href="#error-handling">Error Handling</a>
    <ul>
      <li><a href="#overriding-the-error-logging">Overriding the Error Logging</a></li>
      <li><a href="#trigger-a-timeout">Trigger a Timeout</a></li>
      <li><a href="#recovering-from-error">Recovering from Error</a></li>
      <li><a href="#restart-on-error">Restart On Error</a></li>
      <li><a href="#expose-errors">Expose Errors</a></li>
    </ul>
  </li>
</ul>

  </nav>
    
      <h2 id="introduction">
        
        
          Introduction <a href="#introduction" class="anchor">#</a>
        
        
      </h2>

<p>Task is a data type for controlling possibly lazy &amp; asynchronous
computations, useful for controlling side-effects, avoiding
nondeterminism and callback-hell.</p>

<p>To get the imports out of the way:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In order to evaluate tasks, we'll need a Scheduler</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>

<span class="c1">// A Future type that is also Cancelable</span>
<span class="k">import</span> <span class="nn">monix.execution.CancelableFuture</span>

<span class="c1">// Task is in monix.eval</span>
<span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Executing a sum, which (due to the semantics of apply)</span>
<span class="c1">// will happen on another thread. Nothing happens on building</span>
<span class="c1">// this instance though, this expression is pure, being</span>
<span class="c1">// just a spec! Task by default has lazy behavior ;-)</span>
<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">}</span>

<span class="c1">// Tasks get evaluated only on runAsync!</span>
<span class="c1">// Callback style:</span>
<span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">runOnComplete</span> <span class="o">{</span> <span class="n">result</span> <span class="k">=&gt;</span>
  <span class="n">result</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nf">println</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nv">System</span><span class="o">.</span><span class="py">out</span><span class="o">.</span><span class="py">println</span><span class="o">(</span><span class="n">s</span><span class="s">"ERROR: ${ex.getMessage}"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">//=&gt; 2</span>

<span class="c1">// Or you can convert it into a Future</span>
<span class="k">val</span> <span class="nv">future</span><span class="k">:</span> <span class="kt">CancelableFuture</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span>

<span class="c1">// Printing the result asynchronously</span>
<span class="nv">future</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; 2</span>
</code></pre></div></div>
    
      <h3 id="design-summary">
        
        
          Design Summary <a href="#design-summary" class="anchor">#</a>
        
        
      </h3>

<p>In summary the Monix <code class="language-plaintext highlighter-rouge">Task</code>:</p>

<ul>
  <li>models lazy &amp; asynchronous evaluation</li>
  <li>models a producer pushing only one value to one or multiple consumers</li>
  <li>allows fine-grained control over the <a href="/docs/2x/execution/scheduler.html#execution-model">execution model</a></li>
  <li>doesn’t trigger the execution, or any effects until <code class="language-plaintext highlighter-rouge">runAsync</code></li>
  <li>doesn’t necessarily execute on another logical thread</li>
  <li>allows for cancelling of a running computation</li>
  <li>allows for controlling of side-effects, being just as
potent as Haskell’s I/O ;-)</li>
  <li>never blocks any threads in its implementation</li>
  <li>does not expose any API calls that can block threads</li>
</ul>

<p>A visual representation of where they sit in the design
space:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">Eager</th>
      <th style="text-align: center">Lazy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>Synchronous</strong></td>
      <td style="text-align: center">A</td>
      <td style="text-align: center">() =&gt; A</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"><a href="/docs/2x/eval/coeval.html">Coeval[A]</a></td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>Asynchronous</strong></td>
      <td style="text-align: center">(A =&gt; Unit) =&gt; Unit</td>
      <td style="text-align: center">(A =&gt; Unit) =&gt; Unit</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">Future[A]</td>
      <td style="text-align: center">Task[A]</td>
    </tr>
  </tbody>
</table>
    
      <h3 id="comparison-with-scalas-future">
        
        
          Comparison with Scala’s Future <a href="#comparison-with-scalas-future" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task</code> sounds similar with Scala’s
<a href="http://docs.scala-lang.org/overviews/core/futures.html">Future</a>, but
has a different character and the two types as you’ll see are actually
complementary. A wise man once said:</p>

<blockquote>
  <p>“<em>A Future represents a value, detached from time</em>” — Viktor Klang</p>
</blockquote>

<p>That’s certainly a poetic notion, making one think about what values
are and how they incorporate time. But more importantly, while we
cannot say that a <code class="language-plaintext highlighter-rouge">Future</code> is a
<a href="https://en.wikipedia.org/wiki/Value_(computer_science)">value</a>,
we can certainly say that it’s a <em>value-wannabe</em>, meaning that when
users receive a <code class="language-plaintext highlighter-rouge">Future</code> reference, they know that whatever process
that’s going to evaluate it has probably already started and it might
have even finished already. This makes the behavior of Scala’s
<code class="language-plaintext highlighter-rouge">Future</code> to be about <em>eager evaluation</em> and certainly its design helps
with that, if you think about how it takes that implicit execution
context whenever you call its operators, like <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">flatMap</code>.</p>

<p>But <code class="language-plaintext highlighter-rouge">Task</code> is different. <code class="language-plaintext highlighter-rouge">Task</code> is about lazy evaluation. Well, not
always lazy, in fact <code class="language-plaintext highlighter-rouge">Task</code> allows for fine-tuning the execution
model, as you’ll see, but that’s the primary distinction between
them. If <code class="language-plaintext highlighter-rouge">Future</code> is like a value, then <code class="language-plaintext highlighter-rouge">Task</code> is like a function. And
in fact <code class="language-plaintext highlighter-rouge">Task</code> can function as a “factory” of <code class="language-plaintext highlighter-rouge">Future</code> instances.</p>

<p>Another distinction is that <code class="language-plaintext highlighter-rouge">Future</code> is “<em>memoized</em>” by default,
meaning that its result is going to be shared between multiple
consumers if needed. But the evaluation of a <code class="language-plaintext highlighter-rouge">Task</code> is not memoized by
default. No, you have to want memoization to happen, you have to
specify it explicitly, as you’ll see.</p>

<p>In terms of efficiency, <code class="language-plaintext highlighter-rouge">Future</code> having eager behavior, happens to be
less efficient because whatever operation you’re doing on it, the
implementation will end up sending <code class="language-plaintext highlighter-rouge">Runnable</code> instances in the
thread-pool and because the result is always memoized on each step,
invoking that machinery (e.g. going into compare-and-set loops)
whatever you’re doing. On the other hand <code class="language-plaintext highlighter-rouge">Task</code> can do execution in
synchronous batches.</p>
    
      <h3 id="comparison-with-the-scalaz-task">
        
        
          Comparison with the Scalaz Task <a href="#comparison-with-the-scalaz-task" class="anchor">#</a>
        
        
      </h3>

<p>It’s no secret that the Monix Task was inspired by the
<a href="https://github.com/scalaz/scalaz">Scalaz</a> Task, an otherwise solid
implementation. The whole Monix library stands on the shoulders of
giants. But where the Monix Task implementation disagrees:</p>

<ol>
  <li>The Scalaz Task is leaking implementation details. This is because
the Scalaz Task is first and foremost about <em>trampolined</em>
execution, but asynchronous execution is about jumping over
asynchronous and thus trampoline boundaries. So the API is limited
by what the trampoline can do and for example in order to not block
the current thread in a big loop, you have to <em>manually insert</em>
async boundaries yourself by means of <code class="language-plaintext highlighter-rouge">Task.fork</code>. The Monix Task
on the other hand manages to do that automatically by default,
which is very useful when running on top of
<a href="http://www.scala-js.org/">Javascript</a>, where
<a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">cooperative multitasking</a>
is not only nice to have, but required.</li>
  <li>The Scalaz Task has a dual synchronous / asynchronous
personality. That is fine for optimization purposes as far as the
producer is concerned (i.e. why fork a thread when you don’t have
to), but from the consumer’s point of view having a <code class="language-plaintext highlighter-rouge">def run: A</code>
means that the API cannot be fully supported on top of Javascript
and on top of the JVM it means that the <code class="language-plaintext highlighter-rouge">Task</code> ends up faking
synchronous evaluation and blocking threads. And
<a href="/docs/2x/best-practices/blocking.html">blocking threads is very unsafe</a>.</li>
  <li>The Scalaz Task cannot cancel running computations. This is
important for nondeterministic operations. For example when you
create a race condition with a <code class="language-plaintext highlighter-rouge">chooseFirstOf</code>, you may want to
cancel the slower task that didn’t finish in time, because
unfortunately, if we don’t release resources soon enough, we can
end up with serious leakage that can crash our process.</li>
  <li>The Scalaz Task piggybacks on top of Java’s standard library for
dealing with asynchronous execution. This is bad for portability
reasons, as this API is not supported on top of
<a href="http://www.scala-js.org/">Scala.js</a>.</li>
</ol>
    
      <h2 id="execution-runasync--foreach">
        
        
          Execution (runAsync &amp; foreach) <a href="#execution-runasync--foreach" class="anchor">#</a>
        
        
      </h2>

<p><code class="language-plaintext highlighter-rouge">Task</code> instances won’t do anything until they are executed by means
of <code class="language-plaintext highlighter-rouge">runAsync</code>. And there are multiple overloads of it.</p>

<p><code class="language-plaintext highlighter-rouge">Task.runAsync</code> also wants an implicit
<a href="/docs/2x/execution/scheduler.html">Scheduler</a> in scope, that can supplant
your <code class="language-plaintext highlighter-rouge">ExecutionContext</code> (since it inherits from it). But this is where
the design of <code class="language-plaintext highlighter-rouge">Task</code> diverges from Scala’s own <code class="language-plaintext highlighter-rouge">Future</code>. The <code class="language-plaintext highlighter-rouge">Task</code>
being lazy, it only wants this <code class="language-plaintext highlighter-rouge">Scheduler</code> on execution with
<code class="language-plaintext highlighter-rouge">runAsync</code>, instead of wanting it on every operation (like <code class="language-plaintext highlighter-rouge">map</code> or
<code class="language-plaintext highlighter-rouge">flatMap</code>), the way that Scala’s <code class="language-plaintext highlighter-rouge">Future</code> does.</p>

<p>So first things first, we need a <code class="language-plaintext highlighter-rouge">Scheduler</code> in scope. The <code class="language-plaintext highlighter-rouge">global</code> is
piggybacking on Scala’s own <code class="language-plaintext highlighter-rouge">global</code>, so now you can do this:</p>

<p><strong>NOTE:</strong> The <a href="/docs/2x/execution/scheduler.html">Scheduler</a> can inject a
configurable
<a href="/docs/2x/execution/scheduler.html#execution-model">execution model</a> which
determines how asynchronous boundaries get forced (or not). Read up on
it.</p>

<p>The most straightforward and idiomatic way would be to execute
tasks and get a
<a href="/api/2.3/monix/execution/CancelableFuture.html">CancelableFuture</a>
in return, which is a standard <code class="language-plaintext highlighter-rouge">Future</code> paired with a
<a href="/docs/2x/execution/cancelable.html">Cancelable</a>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.CancelableFuture</span>
<span class="k">import</span> <span class="nn">concurrent.duration._</span>

<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">result</span><span class="k">:</span> <span class="kt">CancelableFuture</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span>

<span class="c1">// If we change our mind</span>
<span class="nv">result</span><span class="o">.</span><span class="py">cancel</span><span class="o">()</span>
</code></pre></div></div>

<p>Returning a <code class="language-plaintext highlighter-rouge">Future</code> might be too heavy for your needs, you might want
to provide a simple callback. We can also <code class="language-plaintext highlighter-rouge">runAsync</code> with a <code class="language-plaintext highlighter-rouge">Try[T] =&gt;
Unit</code> callback, just like the standard <code class="language-plaintext highlighter-rouge">Future.onComplete</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>

<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">runOnComplete</span> <span class="o">{</span> <span class="n">result</span> <span class="k">=&gt;</span>
  <span class="n">result</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nf">println</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nv">System</span><span class="o">.</span><span class="py">err</span><span class="o">.</span><span class="py">println</span><span class="o">(</span><span class="n">s</span><span class="s">"ERROR: ${ex.getMessage}"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// If we change our mind...</span>
<span class="nv">cancelable</span><span class="o">.</span><span class="py">cancel</span><span class="o">()</span>
</code></pre></div></div>

<p>We can also <code class="language-plaintext highlighter-rouge">runOnComplete</code> with a <a href="/docs/2x/eval/callback.html">Callback</a> instance.
This is like a Java-ish API, useful in case, for any reason whatsoever,
you want to keep state. <code class="language-plaintext highlighter-rouge">Callback</code> is also used internally, because it
allows us to guard against contract violations and to avoid the boxing
specific to <code class="language-plaintext highlighter-rouge">Try[T]</code>. Sample:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Callback</span>

<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">runOnComplete</span><span class="o">(</span>
  <span class="k">new</span> <span class="nc">Callback</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
      <span class="nf">println</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
    <span class="k">def</span> <span class="nf">onError</span><span class="o">(</span><span class="n">ex</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
      <span class="nv">System</span><span class="o">.</span><span class="py">err</span><span class="o">.</span><span class="py">println</span><span class="o">(</span><span class="n">s</span><span class="s">"ERROR: ${ex.getMessage}"</span><span class="o">)</span>
  <span class="o">})</span>

<span class="c1">// If we change our mind...</span>
<span class="nv">cancelable</span><span class="o">.</span><span class="py">cancel</span><span class="o">()</span>
</code></pre></div></div>

<p>But if you just want to trigger some side-effects quickly, you can
just use <code class="language-plaintext highlighter-rouge">foreach</code> directly:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect!"</span><span class="o">);</span> <span class="s">"Result"</span> <span class="o">}</span>

<span class="nv">task</span><span class="o">.</span><span class="py">foreach</span> <span class="o">{</span> <span class="n">result</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="o">}</span>
<span class="c1">//=&gt; Effect!</span>
<span class="c1">//=&gt; Result</span>

<span class="c1">// Or we can use for-comprehensions</span>
<span class="nf">for</span> <span class="o">(</span><span class="n">result</span> <span class="k">&lt;-</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>NOTE: <code class="language-plaintext highlighter-rouge">foreach</code> on <code class="language-plaintext highlighter-rouge">Task</code> does not block, but returns a
<code class="language-plaintext highlighter-rouge">CancelableFuture[Unit]</code> that can be used to block on the execution,
or for cancellation.</p>
    
      <h3 id="blocking-for-a-result">
        
        
          Blocking for a Result <a href="#blocking-for-a-result" class="anchor">#</a>
        
        
      </h3>

<p>Monix is <a href="/docs/2x/best-practices/blocking.html">against blocking</a> as a
matter of philosophy, therefore <code class="language-plaintext highlighter-rouge">Task</code> doesn’t have any API calls that
blocks threads, none!</p>

<p>However, on top of the JVM sometimes we have to block. And if we have
to block, Monix doesn’t try to outsmart Scala’s standard library,
because the standard <code class="language-plaintext highlighter-rouge">Await.result</code> and <code class="language-plaintext highlighter-rouge">Await.ready</code> have two healthy
design choices:</p>

<ol>
  <li>These calls use Scala’s <code class="language-plaintext highlighter-rouge">BlockContext</code> in their implementation,
signaling to the underlying thread-pool that a blocking operation
is being executed, allowing the thread-pool to act on it. For
example it might decide to add more threads in the pool, like
Scala’s <code class="language-plaintext highlighter-rouge">ForkJoinPool</code> is doing.</li>
  <li>These calls require a very explicit timeout parameter, specified as
a <code class="language-plaintext highlighter-rouge">FiniteDuration</code>, triggering a <code class="language-plaintext highlighter-rouge">TimeoutException</code> in case that
specified timespan is exceeded without the source being ready.</li>
</ol>

<p>Therefore in order to block on a result, you have to first convert it
into a <code class="language-plaintext highlighter-rouge">Future</code> by means of <code class="language-plaintext highlighter-rouge">runAsync</code> and then you can block on it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.Await</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">fork</span><span class="o">(</span><span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">future</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span>

<span class="nv">Await</span><span class="o">.</span><span class="py">result</span><span class="o">(</span><span class="n">future</span><span class="o">,</span> <span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!</span>

<span class="c1">// Or by using foreach</span>
<span class="k">val</span> <span class="nv">completed</span> <span class="k">=</span> <span class="nf">for</span> <span class="o">(</span><span class="n">r</span> <span class="k">&lt;-</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Completed!"</span><span class="o">)</span> <span class="o">}</span>

<span class="nv">Await</span><span class="o">.</span><span class="py">result</span><span class="o">(</span><span class="n">completed</span><span class="o">,</span> <span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!</span>
<span class="c1">//=&gt; Completed!</span>
</code></pre></div></div>

<p><strong>NOTE:</strong> There is <a href="https://github.com/scala-js/scala-js/issues/186">no blocking</a>
on Scala.js by design.</p>
    
      <h3 id="try-immediate-execution-coeval">
        
        
          Try Immediate Execution (Coeval) <a href="#try-immediate-execution-coeval" class="anchor">#</a>
        
        
      </h3>

<p>Monix is against blocking, we’ve established that. But clearly some
<code class="language-plaintext highlighter-rouge">Task</code> instances can be evaluated immediately on the current logical
thread, if allowed by the execution model. And for <em>optimization
purposes</em>, we might want to act immediately on their results, avoiding
dealing with callbacks.</p>

<p>To do that, we can convert a <code class="language-plaintext highlighter-rouge">Task</code> into a <code class="language-plaintext highlighter-rouge">Coeval</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">tryingNow</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">coeval</span>
<span class="c1">// tryingNow: Coeval[Either[CancelableFuture[String],String]] = ???</span>

<span class="nv">tryingNow</span><span class="o">.</span><span class="py">value</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">future</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="c1">// No luck, this Task really wants async execution</span>
    <span class="nv">future</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Async: $r"</span><span class="o">))</span>
  <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Got lucky: $result"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>NOTE:</strong> as it happens, by default the <code class="language-plaintext highlighter-rouge">eval</code> builder is
executing things on the current thread, unless an async boundary is
forced by the underlying loop. So this code will always print “<em>Got
Lucky</em>” ;-)</p>
    
      <h2 id="simple-builders">
        
        
          Simple Builders <a href="#simple-builders" class="anchor">#</a>
        
        
      </h2>

<p>If you can accept its possibly asynchronous nature, <code class="language-plaintext highlighter-rouge">Task</code> can replace
functions accepting zero arguments, Scala by-name params and <code class="language-plaintext highlighter-rouge">lazy
val</code>. And any Scala <code class="language-plaintext highlighter-rouge">Future</code> is convertible to <code class="language-plaintext highlighter-rouge">Task</code>.</p>
    
      <h3 id="tasknow">
        
        
          Task.now <a href="#tasknow" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.now</code>
lifts an already known value in the <code class="language-plaintext highlighter-rouge">Task</code> context,
the equivalent of <code class="language-plaintext highlighter-rouge">Future.successful</code> or of <code class="language-plaintext highlighter-rouge">Applicative.pure</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">now</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">// task: monix.eval.Task[String] = Delay(Now(Hello!))</span>
</code></pre></div></div>
    
      <h3 id="taskeval-delay">
        
        
          Task.eval (delay) <a href="#taskeval-delay" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.eval</code>
is the equivalent of <code class="language-plaintext highlighter-rouge">Function0</code>, taking a function
that will always be evaluated on <code class="language-plaintext highlighter-rouge">runAsync</code>, possibly on the same
thread (depending on the chosen
<a href="/docs/2x/execution/scheduler.html#execution-model">execution model</a>):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="c1">// task: monix.eval.Task[String] = Delay(Always(&lt;function0&gt;))</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>

<span class="c1">// The evaluation (and thus all contained side effects)</span>
<span class="c1">// gets triggered on each runAsync:</span>
<span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>

<p>NOTE: for Scalaz converts, this function is also aliased as <code class="language-plaintext highlighter-rouge">Task.delay</code>.</p>
    
      <h3 id="taskevalonce">
        
        
          Task.evalOnce <a href="#taskevalonce" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.evalOnce</code>
is the equivalent of a <code class="language-plaintext highlighter-rouge">lazy val</code>, a type that cannot
be precisely expressed in Scala. The <code class="language-plaintext highlighter-rouge">evalOnce</code> builder does
memoization on the first run, such that the result of the evaluation
will be available for subsequent runs. It also has guaranteed
idempotency and thread-safety:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">evalOnce</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="c1">// task: monix.eval.Task[String] = EvalOnce(&lt;function0&gt;)</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>

<span class="c1">// Result was memoized on the first run!</span>
<span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>

<p>NOTE: this operation is effectively <code class="language-plaintext highlighter-rouge">Task.eval(f).memoize</code>.</p>
    
      <h3 id="taskdefer-suspend">
        
        
          Task.defer (suspend) <a href="#taskdefer-suspend" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.defer</code>
is about building a factory of tasks. For example this
will behave approximately like <code class="language-plaintext highlighter-rouge">Task.eval</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">defer</span> <span class="o">{</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">now</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// task: monix.eval.Task[String] = Suspend(&lt;function0&gt;)</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>

<p>NOTE: for Scalaz converts, this function is also aliased as <code class="language-plaintext highlighter-rouge">Task.suspend</code>.</p>
    
      <h3 id="taskfromfuture">
        
        
          Task.fromFuture <a href="#taskfromfuture" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.fromFuture</code> can convert any Scala <code class="language-plaintext highlighter-rouge">Future</code> instance into a <code class="language-plaintext highlighter-rouge">Task</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.Future</span>

<span class="k">val</span> <span class="nv">future</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">fromFuture</span><span class="o">(</span><span class="n">future</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!</span>
<span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>

<p>Note that <code class="language-plaintext highlighter-rouge">fromFuture</code> takes a strict argument and that may not be
what you want. You might want a factory of <code class="language-plaintext highlighter-rouge">Future</code>. The design of
<code class="language-plaintext highlighter-rouge">Task</code> however is to have fine-grained control over the evaluation
model, so in case you want a factory, you need to combine it with
<code class="language-plaintext highlighter-rouge">Task.defer</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">defer</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">future</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">fromFuture</span><span class="o">(</span><span class="n">future</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">//=&gt; task: monix.eval.Task[Int] = Suspend(&lt;function0&gt;)</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>
<span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>
    
      <h3 id="taskdeferfuture">
        
        
          Task.deferFuture <a href="#taskdeferfuture" class="anchor">#</a>
        
        
      </h3>

<p>A <code class="language-plaintext highlighter-rouge">Future</code> reference is like a strict value, meaning that when you receive one,
whatever process that’s supposed to complete it has probably started already.</p>

<p>Therefore it makes sense to defer the evaluation of futures when building tasks:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">defer</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">future</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">fromFuture</span><span class="o">(</span><span class="n">future</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>As a shortcut, you can also use the <code class="language-plaintext highlighter-rouge">deferFuture</code> builder, which is equivalent
with the above:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">deferFuture</span> <span class="o">{</span>
  <span class="nc">Future</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
    
      <h3 id="taskdeferfutureaction">
        
        
          Task.deferFutureAction <a href="#taskdeferfutureaction" class="anchor">#</a>
        
        
      </h3>

<p>Wraps calls that generate <code class="language-plaintext highlighter-rouge">Future</code> results into <code class="language-plaintext highlighter-rouge">Task</code>, provided a
callback with an injected <code class="language-plaintext highlighter-rouge">Scheduler</code> to act as the necessary
<code class="language-plaintext highlighter-rouge">ExecutionContext</code>.</p>

<p>This builder helps with wrapping <code class="language-plaintext highlighter-rouge">Future</code>-enabled APIs that need an
implicit <code class="language-plaintext highlighter-rouge">ExecutionContext</code> to work. Consider this example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.</span><span class="o">{</span><span class="nc">ExecutionContext</span><span class="o">,</span> <span class="nc">Future</span><span class="o">}</span>

<span class="k">def</span> <span class="nf">sumFuture</span><span class="o">(</span><span class="n">list</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Future</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">sum</span><span class="o">)</span>
</code></pre></div></div>

<p>We’d like to wrap this function into one that returns a lazy <code class="language-plaintext highlighter-rouge">Task</code>
that evaluates this sum every time it is called, because that’s how
tasks work best. However in order to invoke this function an
<code class="language-plaintext highlighter-rouge">ExecutionContext</code> is needed:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sumTask</span><span class="o">(</span><span class="n">list</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">deferFuture</span><span class="o">(</span><span class="nf">sumFuture</span><span class="o">(</span><span class="n">list</span><span class="o">))</span>
</code></pre></div></div>

<p>But this is not only superfluous, but against the best practices of
using <code class="language-plaintext highlighter-rouge">Task</code>. The difference is that <code class="language-plaintext highlighter-rouge">Task</code> takes a <code class="language-plaintext highlighter-rouge">Scheduler</code>
(inheriting from <code class="language-plaintext highlighter-rouge">ExecutionContext</code>) only when <code class="language-plaintext highlighter-rouge">runAsync</code> gets called,
but we don’t need it just for building a <code class="language-plaintext highlighter-rouge">Task</code> reference.  With
<code class="language-plaintext highlighter-rouge">deferFutureAction</code> we get to have an injected <code class="language-plaintext highlighter-rouge">Scheduler</code> in the
passed callback:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sumTask</span><span class="o">(</span><span class="n">list</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">deferFutureAction</span> <span class="o">{</span> <span class="k">implicit</span> <span class="n">scheduler</span> <span class="k">=&gt;</span>
    <span class="nf">sumFuture</span><span class="o">(</span><span class="n">list</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Voilà! No more implicit <code class="language-plaintext highlighter-rouge">ExecutionContext</code> passed around.</p>
    
      <h3 id="taskfork--taskasyncboundary">
        
        
          Task.fork &amp;&amp; Task.asyncBoundary <a href="#taskfork--taskasyncboundary" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.fork</code> ensures an asynchronous boundary, forcing the fork of a
(logical) thread on execution. Sometimes we are doing something really
wasteful and we want to guarantee that an asynchronous boundary
happens, given that by default
the <a href="/docs/2x/execution/scheduler.html#execution-model">execution model</a>
prefers to execute things on the current thread, at first.</p>

<p>So this guarantees that our task will get executed asynchronously:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">fork</span><span class="o">(</span><span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">))</span>
</code></pre></div></div>

<p>In fact that’s how <code class="language-plaintext highlighter-rouge">apply</code> is defined:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Task</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="nf">fork</span><span class="o">(</span><span class="nf">eval</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
  <span class="c1">//...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Fork also allows us to specify an alternative <code class="language-plaintext highlighter-rouge">Scheduler</code> to use.
You see, the run-loop of <code class="language-plaintext highlighter-rouge">Task</code> always has a <code class="language-plaintext highlighter-rouge">Scheduler</code> available, but
for certain operations you might want to divert the processing to an alternative
scheduler. For example you might want to execute blocking I/O operations
on an alternative thread-pool.</p>

<p>Lets assume we have 2 thread-pools:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The default scheduler</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>

<span class="c1">// Creating a special scheduler meant for I/O</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler</span>
<span class="k">lazy</span> <span class="k">val</span> <span class="nv">io</span> <span class="k">=</span> <span class="nv">Scheduler</span><span class="o">.</span><span class="py">io</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"my-io"</span><span class="o">)</span>
</code></pre></div></div>

<p>Then we can manage what executes on which:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Override the default Scheduler by fork:</span>
<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Running on thread: ${Thread.currentThread.getName}"</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">forked</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">fork</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">io</span><span class="o">)</span>

<span class="nv">source</span><span class="o">.</span><span class="py">runAsync</span>
<span class="c1">//=&gt; Running on thread: ForkJoinPool-1-worker-1</span>
<span class="nv">forked</span><span class="o">.</span><span class="py">runAsync</span>
<span class="c1">//=&gt; Running on thread: my-io-4</span>
</code></pre></div></div>

<p>Note that, unless another asynchronous boundary is scheduled on the
default <code class="language-plaintext highlighter-rouge">Scheduler</code>, execution remains on the last scheduler (thread-pool)
used. Notice what happens in this combination:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">onFinish</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span>
  <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Ends on thread: ${Thread.currentThread.getName}"</span><span class="o">)</span>
<span class="o">)</span>

<span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">source</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">forked</span><span class="o">)</span>
    <span class="o">.</span><span class="py">doOnFinish</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">onFinish</span><span class="o">)</span>
    <span class="o">.</span><span class="py">runAsync</span>
<span class="o">}</span>

<span class="c1">//=&gt; Running on thread: ForkJoinPool-1-worker-7</span>
<span class="c1">//=&gt; Running on thread: my-io-1</span>
<span class="c1">//=&gt; Ends on thread: my-io-1</span>
</code></pre></div></div>

<p>But if we insert another async boundary, then it switches back
to the default:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">asyncBoundary</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">fork</span><span class="o">(</span><span class="nv">Task</span><span class="o">.</span><span class="py">unit</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">onFinish</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span>
  <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Ends on thread: ${Thread.currentThread.getName}"</span><span class="o">))</span>

<span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">source</span> <span class="c1">// executes on global</span>
    <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">forked</span><span class="o">)</span> <span class="c1">// executes on io</span>
    <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">asyncBoundary</span><span class="o">)</span> <span class="c1">// switch back to global</span>
    <span class="o">.</span><span class="py">doOnFinish</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">onFinish</span><span class="o">)</span> <span class="c1">// executes on global</span>
    <span class="o">.</span><span class="py">runAsync</span>
<span class="o">}</span>

<span class="c1">//=&gt; Running on thread: ForkJoinPool-1-worker-5</span>
<span class="c1">//=&gt; Running on thread: my-io-2</span>
<span class="c1">//=&gt; Ends on thread: ForkJoinPool-1-worker-5</span>
</code></pre></div></div>

<p>But <code class="language-plaintext highlighter-rouge">Task</code> also provides a convenient operator for introducing an
asynchronous boundary without having to manually do this trick, called
<code class="language-plaintext highlighter-rouge">Task.asyncBoundary</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">source</span> <span class="c1">// executes on global</span>
    <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">forked</span><span class="o">)</span> <span class="c1">// executes on io</span>
    <span class="o">.</span><span class="py">asyncBoundary</span> <span class="c1">// switch back to global</span>
    <span class="o">.</span><span class="py">doOnFinish</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">onFinish</span><span class="o">)</span> <span class="c1">// executes on global</span>
    <span class="o">.</span><span class="py">runAsync</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that overriding of the scheduler can only happen once, as
<code class="language-plaintext highlighter-rouge">Task</code> instances are immutable, so the following does not work,
because for the <code class="language-plaintext highlighter-rouge">forked</code> instance the <code class="language-plaintext highlighter-rouge">Scheduler</code> was already
set in stone and we only have flexibility to override the
default if it hasn’t been overridden already:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Trying to execute on global</span>
<span class="nv">Task</span><span class="o">.</span><span class="py">fork</span><span class="o">(</span><span class="n">forked</span><span class="o">,</span> <span class="n">global</span><span class="o">).</span><span class="py">runAsync</span>
<span class="c1">//=&gt; Running on thread: my-io-4</span>
</code></pre></div></div>

<p>There are also two <code class="language-plaintext highlighter-rouge">Task</code> methods specified as aliases for <code class="language-plaintext highlighter-rouge">Task.fork</code>,
called <code class="language-plaintext highlighter-rouge">executeOn</code> and <code class="language-plaintext highlighter-rouge">executeWithFork</code> respectively. So you can do:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">source</span><span class="o">.</span><span class="py">executeOn</span><span class="o">(</span><span class="n">io</span><span class="o">)</span>
    <span class="o">.</span><span class="py">asyncBoundary</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>General advice:</strong> unless you’re doing blocking I/O, keep using
the default thread-pool, with <code class="language-plaintext highlighter-rouge">global</code> being a good default.
For blocking I/O it is OK to have a second thread-pool,
but isolate those I/O operations and only override the scheduler
for actual I/O operations.</p>
    
      <h3 id="taskraiseerror">
        
        
          Task.raiseError <a href="#taskraiseerror" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.raiseError</code> can lift errors in the monadic context of <code class="language-plaintext highlighter-rouge">Task</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="k">val</span> <span class="nv">error</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">new</span> <span class="nc">TimeoutException</span><span class="o">)</span>
<span class="c1">// error: monix.eval.Task[Int] =</span>
<span class="c1">//   Delay(Error(java.util.concurrent.TimeoutException))</span>

<span class="nv">error</span><span class="o">.</span><span class="py">runOnComplete</span><span class="o">(</span><span class="n">result</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">result</span><span class="o">))</span>
<span class="c1">//=&gt; Failure(java.util.concurrent.TimeoutException)</span>
</code></pre></div></div>
    
      <h3 id="tasknever">
        
        
          Task.never <a href="#tasknever" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.never</code> returns a <code class="language-plaintext highlighter-rouge">Task</code> instance that never completes:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="c1">// A Task instance that never completes</span>
<span class="k">val</span> <span class="nv">never</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">never</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="k">val</span> <span class="nv">timedOut</span> <span class="k">=</span> <span class="nv">never</span><span class="o">.</span><span class="py">timeoutTo</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">,</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">TimeoutException</span><span class="o">))</span>

<span class="nv">timedOut</span><span class="o">.</span><span class="py">runOnComplete</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">// After 3 seconds:</span>
<span class="c1">// =&gt; Failure(java.util.concurrent.TimeoutException)</span>
</code></pre></div></div>

<p>This instance is shared, so that can relieve some stress from the
garbage collector.</p>
    
      <h3 id="taskunit">
        
        
          Task.unit <a href="#taskunit" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.unit</code> is returning an already completed <code class="language-plaintext highlighter-rouge">Task[Unit]</code> instance,
provided as a utility, to spare you creating new instances with
<code class="language-plaintext highlighter-rouge">Task.now(())</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">unit</span>
<span class="c1">// task: monix.eval.Task[Unit] = Delay(Now(()))</span>
</code></pre></div></div>

<p>This instance is shared, so that can relieve some stress from the
garbage collector.</p>
    
      <h2 id="asynchronous-builders">
        
        
          Asynchronous Builders <a href="#asynchronous-builders" class="anchor">#</a>
        
        
      </h2>

<p>You can use any async API to build a <code class="language-plaintext highlighter-rouge">Task</code>. There’s an unsafe
version, for people knowing what they are doing and a safe version, that
handles some of the nitty-gritty automatically.</p>
    
      <h3 id="taskcreate">
        
        
          Task.create <a href="#taskcreate" class="anchor">#</a>
        
        
      </h3>

<p>Also known as <code class="language-plaintext highlighter-rouge">Task.async</code> (for Scalaz refugees), the <code class="language-plaintext highlighter-rouge">Task.create</code>
function allows for creating an asynchronous <code class="language-plaintext highlighter-rouge">Task</code> using a
callback-based API. For example, let’s create a utility that evaluates
expressions with a given delay:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Try</span>
<span class="k">import</span> <span class="nn">concurrent.duration._</span>

<span class="k">def</span> <span class="nf">evalDelayed</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">delay</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="c1">// On execution, we have the scheduler and</span>
  <span class="c1">// the callback injected ;-)</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">create</span> <span class="o">{</span> <span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">callback</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span>
      <span class="nv">scheduler</span><span class="o">.</span><span class="py">scheduleOnce</span><span class="o">(</span><span class="n">delay</span><span class="o">)</span> <span class="o">{</span>
        <span class="nf">callback</span><span class="o">(</span><span class="nc">Try</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
      <span class="o">}</span>

    <span class="c1">// We must return something that can</span>
    <span class="c1">// cancel the async computation</span>
    <span class="n">cancelable</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And here’s a possible implementation of
<a href="#taskfromfuture">Task.fromFuture</a>, in case you choose to implement it
yourself:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Cancelable</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Future</span>
<span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>

<span class="k">def</span> <span class="nf">fromFuture</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">create</span> <span class="o">{</span> <span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">callback</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nv">f</span><span class="o">.</span><span class="py">onComplete</span><span class="o">({</span>
      <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nv">callback</span><span class="o">.</span><span class="py">onSuccess</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
      <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nv">callback</span><span class="o">.</span><span class="py">onError</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>
    <span class="o">})(</span><span class="n">scheduler</span><span class="o">)</span>

    <span class="c1">// Scala Futures are not cancelable, so</span>
    <span class="c1">// we shouldn't pretend that they are!</span>
    <span class="nv">Cancelable</span><span class="o">.</span><span class="py">empty</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Some notes:</p>

<ul>
  <li>Tasks created with this builder are guaranteed to execute
asynchronously (on another logical thread)</li>
  <li>The <a href="/docs/2x/execution/scheduler.html">Scheduler</a> gets injected and with
it we can schedule things for async execution, we can delay,
etc…</li>
  <li>But as said, this callback will already execute asynchronously, so
you don’t need to explicitly schedule things to run on the provided
<code class="language-plaintext highlighter-rouge">Scheduler</code>, unless you really need to do it.</li>
  <li><a href="/docs/2x/eval/callback.html">The Callback</a> gets injected on execution and that
callback has a contract. In particular you need to execute
<code class="language-plaintext highlighter-rouge">onSuccess</code> or <code class="language-plaintext highlighter-rouge">onError</code> or <code class="language-plaintext highlighter-rouge">apply</code> only once. The implementation
does a reasonably good job to protect against contract violations,
but if you do call it multiple times, then you’re doing it risking
undefined and nondeterministic behavior.</li>
  <li>It’s OK to return a <code class="language-plaintext highlighter-rouge">Cancelable.empty</code> in case the executed
process really can’t be canceled in time, but you should strive to
return a cancelable that does cancel your execution, if possible.</li>
</ul>
    
      <h3 id="taskunsafecreate">
        
        
          Task.unsafeCreate <a href="#taskunsafecreate" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.unsafeCreate</code> has the same purpose and function as
<a href="#taskcreate">Task.create</a>, only this is for people knowing what they
are doing, being the <em>unsafe version</em>. In the development of Monix
there were doubts whether this should be exposed or not. It gets
exposed because otherwise there’s no way to replace its functionality
for certain use-cases.</p>

<p><strong>WARNING:</strong> this isn’t for normal usage. Prefer <a href="#taskcreate">Task.create</a>.</p>

<p>The callback that needs to be passed to <code class="language-plaintext highlighter-rouge">unsafeCreate</code> this time has
this type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Task</span> <span class="o">{</span>
  <span class="c1">// ...</span>

  <span class="k">type</span> <span class="kt">OnFinish</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Context</span><span class="o">,</span> <span class="nc">Callback</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">Unit</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Context</span><span class="o">(</span>
    <span class="n">scheduler</span><span class="k">:</span> <span class="kt">Scheduler</span><span class="o">,</span>
    <span class="n">connection</span><span class="k">:</span> <span class="kt">StackedCancelable</span><span class="o">,</span>
    <span class="n">frameRef</span><span class="k">:</span> <span class="kt">ThreadLocal</span><span class="o">[</span><span class="kt">FrameIndex</span><span class="o">],</span>
    <span class="n">options</span><span class="k">:</span> <span class="kt">Options</span>
  <span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>So instead of returning a
simple <a href="/docs/2x/execution/cancelable.html">Cancelable</a> we get to deal with
an injected
<a href="/api/2.3/ #monix.execution.cancelables.StackedCancelable">StackedCancelable</a>,
along with something called a <code class="language-plaintext highlighter-rouge">FrameIndex</code> that’s a <code class="language-plaintext highlighter-rouge">ThreadLocal</code> and
some special <code class="language-plaintext highlighter-rouge">Options</code> instead.</p>

<p>This is because you</p>

<p>Let implement our own version of the <code class="language-plaintext highlighter-rouge">delayExecution</code> operator, just
for the kicks:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval._</span>
<span class="k">import</span> <span class="nn">monix.execution.cancelables._</span>

<span class="k">def</span> <span class="nf">delayExecution</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span>
  <span class="n">source</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">timespan</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="nv">Task</span><span class="o">.</span><span class="py">unsafeCreate</span> <span class="o">{</span> <span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">cb</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nv">context</span><span class="o">.</span><span class="py">scheduler</span>
    <span class="c1">// A stack that keeps track of what we need to cancel</span>
    <span class="k">val</span> <span class="nv">conn</span> <span class="k">=</span> <span class="nv">context</span><span class="o">.</span><span class="py">connection</span>
    <span class="c1">// We need the forward reference, because otherwise `conn.pop`</span>
    <span class="c1">// below can happen before pushing that reference in `conn`</span>
    <span class="k">val</span> <span class="nv">c</span> <span class="k">=</span> <span class="nc">SingleAssignmentCancelable</span><span class="o">()</span>
    <span class="n">conn</span> <span class="n">push</span> <span class="n">c</span>

    <span class="n">c</span> <span class="o">:=</span> <span class="nv">s</span><span class="o">.</span><span class="py">scheduleOnce</span><span class="o">(</span><span class="nv">timespan</span><span class="o">.</span><span class="py">length</span><span class="o">,</span> <span class="nv">timespan</span><span class="o">.</span><span class="py">unit</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Runnable</span> <span class="o">{</span>
      <span class="k">def</span> <span class="nf">run</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
        <span class="c1">// Releasing our cancelable because our scheduled</span>
        <span class="c1">// task is done and we need to let the GC collect it</span>
        <span class="nv">conn</span><span class="o">.</span><span class="py">pop</span><span class="o">()</span>

        <span class="c1">// We had an async boundary, so we must reset the frame</span>
        <span class="c1">// index in order to let Monix know we've had a real</span>
        <span class="c1">// async boundary - on the JVM this is not needed, since</span>
        <span class="c1">// this is a thread-local, but on JS we don't have threads</span>
        <span class="nv">context</span><span class="o">.</span><span class="py">frameRef</span><span class="o">.</span><span class="py">reset</span><span class="o">()</span>

        <span class="c1">// We can now resume execution, by finally starting</span>
        <span class="c1">// our source. As you can see, we just inject our</span>
        <span class="c1">// StackedCancelable, there's no need to create another</span>
        <span class="c1">// Cancelable reference, so at this point it's as if</span>
        <span class="c1">// the source is being executed without any overhead!</span>
        <span class="nv">Task</span><span class="o">.</span><span class="py">unsafeStartNow</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">context</span><span class="o">,</span> <span class="nv">Callback</span><span class="o">.</span><span class="py">async</span><span class="o">(</span><span class="n">cb</span><span class="o">))</span>
      <span class="o">}</span>
    <span class="o">})</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>As you can see, this really is unsafe and actually unneeded in most
cases. So don’t use it, or if you think you need it, maybe ask for
help.</p>

<p>¯＼(º_o)/¯</p>
    
      <h2 id="memoization">
        
        
          Memoization <a href="#memoization" class="anchor">#</a>
        
        
      </h2>

<p>The
<a href="/api/2.3/monix/eval/Task.html#memoize:monix.eval.Task[A]">Task#memoize</a>
operator can take any <code class="language-plaintext highlighter-rouge">Task</code> and apply memoization on the first <code class="language-plaintext highlighter-rouge">runAsync</code>,
such that:</p>

<ol>
  <li>you have guaranteed idempotency, calling <code class="language-plaintext highlighter-rouge">runAsync</code> multiple times
will have the same effect as calling it once</li>
  <li>subsequent <code class="language-plaintext highlighter-rouge">runAsync</code> calls will reuse the result computed by the
first <code class="language-plaintext highlighter-rouge">runAsync</code></li>
</ol>

<p>So <code class="language-plaintext highlighter-rouge">memoize</code> effectively caches the result of the first <code class="language-plaintext highlighter-rouge">runAsync</code>.
In fact we can say that:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Task</span><span class="o">.</span><span class="py">evalOnce</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">&lt;-&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="py">memoize</span>
</code></pre></div></div>

<p>They are effectively the same.  And <code class="language-plaintext highlighter-rouge">memoize</code> works
with any task reference:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Has async execution, to do the .apply semantics</span>
<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>

<span class="k">val</span> <span class="nv">memoized</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">memoize</span>

<span class="nv">memoized</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>

<span class="nv">memoized</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>
    
      <h3 id="memoize-only-on-success">
        
        
          Memoize Only on Success <a href="#memoize-only-on-success" class="anchor">#</a>
        
        
      </h3>

<p>Sometimes you just want memoization, along with idempotency
guarantees, only for successful values. For failures you might want to
keep retrying until a successful value is available.</p>

<p>This is where the <code class="language-plaintext highlighter-rouge">memoizeOnSuccess</code> operator comes in handy:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">effect</span> <span class="k">=</span> <span class="mi">0</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span> <span class="o">{</span>
  <span class="n">effect</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">effect</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="s">"dummy"</span><span class="o">)</span> <span class="k">else</span> <span class="n">effect</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">cached</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">memoizeOnSuccess</span>

<span class="k">val</span> <span class="nv">f1</span> <span class="k">=</span> <span class="nv">cached</span><span class="o">.</span><span class="py">runAsync</span> <span class="c1">// yields RuntimeException</span>
<span class="k">val</span> <span class="nv">f2</span> <span class="k">=</span> <span class="nv">cached</span><span class="o">.</span><span class="py">runAsync</span> <span class="c1">// yields RuntimeException</span>
<span class="k">val</span> <span class="nv">f3</span> <span class="k">=</span> <span class="nv">cached</span><span class="o">.</span><span class="py">runAsync</span> <span class="c1">// yields 3</span>
<span class="k">val</span> <span class="nv">f4</span> <span class="k">=</span> <span class="nv">cached</span><span class="o">.</span><span class="py">runAsync</span> <span class="c1">// yields 3</span>
</code></pre></div></div>
    
      <h3 id="memoize-versus-runasync">
        
        
          Memoize versus runAsync <a href="#memoize-versus-runasync" class="anchor">#</a>
        
        
      </h3>

<p>You can say that when we do this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="k">val</span> <span class="nv">future</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span>
</code></pre></div></div>

<p>That <code class="language-plaintext highlighter-rouge">future</code> instance is also going to be a memoized value of the
first <code class="language-plaintext highlighter-rouge">runAsync</code> execution, which can be reused for other <code class="language-plaintext highlighter-rouge">onComplete</code>
subscribers.</p>

<p>The difference is the same as the difference between <code class="language-plaintext highlighter-rouge">Task</code> and
<code class="language-plaintext highlighter-rouge">Future</code>. The <code class="language-plaintext highlighter-rouge">memoize</code> operation is lazy, evaluation only being
triggered on the first <code class="language-plaintext highlighter-rouge">runAsync</code>, whereas the result of <code class="language-plaintext highlighter-rouge">runAsync</code> is
eager.</p>
    
      <h2 id="operations">
        
        
          Operations <a href="#operations" class="anchor">#</a>
        
        
      </h2>
    
      <h3 id="flatmap-and-tail-recursive-loops">
        
        
          FlatMap and Tail-Recursive Loops <a href="#flatmap-and-tail-recursive-loops" class="anchor">#</a>
        
        
      </h3>

<p>So let’s start with a stupid example that calculates the N-th number in
the Fibonacci sequence:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.annotation.tailrec</span>

<span class="nd">@tailrec</span>
<span class="k">def</span> <span class="nf">fib</span><span class="o">(</span><span class="n">cycles</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="o">{</span>
 <span class="nf">if</span> <span class="o">(</span><span class="n">cycles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
   <span class="nf">fib</span><span class="o">(</span><span class="n">cycles</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>
 <span class="k">else</span>
   <span class="n">b</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We need this to be tail-recursive, hence the use of the
<a href="http://www.scala-lang.org/api/current/index.html#scala.annotation.tailrec">@tailrec</a>
annotation from Scala’s standard library. And if we’d describe it with
<code class="language-plaintext highlighter-rouge">Task</code>, one possible implementation would be:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fib</span><span class="o">(</span><span class="n">cycles</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">BigInt</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
 <span class="nf">if</span> <span class="o">(</span><span class="n">cycles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
   <span class="nv">Task</span><span class="o">.</span><span class="py">defer</span><span class="o">(</span><span class="nf">fib</span><span class="o">(</span><span class="n">cycles</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">))</span>
 <span class="k">else</span>
   <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And now there are already differences. This is lazy, as the N-th
Fibonacci number won’t get calculated until we <code class="language-plaintext highlighter-rouge">runAsync</code>. The
<code class="language-plaintext highlighter-rouge">@tailrec</code> annotation is also not needed, as this is stack (and heap)
safe.</p>

<p><code class="language-plaintext highlighter-rouge">Task</code> has <code class="language-plaintext highlighter-rouge">flatMap</code>, which is the monadic <code class="language-plaintext highlighter-rouge">bind</code> operation, that for
things like <code class="language-plaintext highlighter-rouge">Task</code> and <code class="language-plaintext highlighter-rouge">Future</code> is the operation that describes
recursivity or that forces ordering (e.g. execute this, then that,
then that). And we can use it to describe recursive calls:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fib</span><span class="o">(</span><span class="n">cycles</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">BigInt</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="n">cycles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span>
      <span class="nf">fib</span><span class="o">(</span><span class="n">cycles</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">)</span>
    <span class="k">case</span> <span class="kc">false</span> <span class="k">=&gt;</span>
      <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Again, this is stack safe and uses a constant amount of memory, so no
<code class="language-plaintext highlighter-rouge">@tailrec</code> annotation is needed or wanted. And it has lazy behavior,
as nothing will get triggered until <code class="language-plaintext highlighter-rouge">runAsync</code> happens.</p>

<p>But we can also have <strong>mutually tail-recursive calls</strong>, w00t!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Mutual Tail Recursion, ftw!!!</span>
<span class="o">{</span>
  <span class="k">def</span> <span class="nf">odd</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
      <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>
      <span class="k">case</span> <span class="kc">false</span> <span class="k">=&gt;</span> <span class="nf">even</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="k">def</span> <span class="nf">even</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
      <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
      <span class="k">case</span> <span class="kc">false</span> <span class="k">=&gt;</span> <span class="nf">odd</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="nf">even</span><span class="o">(</span><span class="mi">1000000</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Again, this is stack safe and uses a constant amount of memory.  And
best of all, because of the
<a href="/docs/2x/execution/scheduler.html#execution-model">execution model</a>, by
default these loops won’t block the current thread forever, preferring to
execute things in batches.</p>
    
      <h3 id="the-applicative-zip2-zip3--zip6">
        
        
          The Applicative: zip2, zip3, … zip6 <a href="#the-applicative-zip2-zip3--zip6" class="anchor">#</a>
        
        
      </h3>

<p>When using <code class="language-plaintext highlighter-rouge">flatMap</code>, we often end up with this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">locationTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(???)</span>
<span class="k">val</span> <span class="nv">phoneTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(???)</span>
<span class="k">val</span> <span class="nv">addressTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(???)</span>

<span class="c1">// Ordered operations based on flatMap ...</span>
<span class="k">val</span> <span class="nv">aggregate</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">location</span> <span class="k">&lt;-</span> <span class="n">locationTask</span>
  <span class="n">phone</span> <span class="k">&lt;-</span> <span class="n">phoneTask</span>
  <span class="n">address</span> <span class="k">&lt;-</span> <span class="n">addressTask</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">{</span>
  <span class="s">"Gotcha!"</span>
<span class="o">}</span>
</code></pre></div></div>

<p>For one the problem here is that these operations are executed in
order. This also happens with Scala’s standard <code class="language-plaintext highlighter-rouge">Future</code>, being
sometimes an unwanted effect, but because <code class="language-plaintext highlighter-rouge">Task</code> is lazily evaluated,
this effect is even more pronounced with <code class="language-plaintext highlighter-rouge">Task</code>.</p>

<p>But <code class="language-plaintext highlighter-rouge">Task</code> is also an <code class="language-plaintext highlighter-rouge">Applicative</code> and hence it has utilities, such
as <code class="language-plaintext highlighter-rouge">zip2</code>, <code class="language-plaintext highlighter-rouge">zip3</code>, up until <code class="language-plaintext highlighter-rouge">zip6</code> (at the moment of writing) and also
<code class="language-plaintext highlighter-rouge">zipList</code>. The example above could be written as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">locationTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(???)</span>
<span class="k">val</span> <span class="nv">phoneTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(???)</span>
<span class="k">val</span> <span class="nv">addressTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(???)</span>

<span class="c1">// Potentially executed in parallel</span>
<span class="k">val</span> <span class="nv">aggregate</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">zip3</span><span class="o">(</span><span class="n">locationTask</span><span class="o">,</span> <span class="n">phoneTask</span><span class="o">,</span> <span class="n">addressTask</span><span class="o">).</span><span class="py">map</span> <span class="o">{</span>
    <span class="nf">case</span> <span class="o">(</span><span class="n">location</span><span class="o">,</span> <span class="n">phone</span><span class="o">,</span> <span class="n">address</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"Gotcha!"</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>In order to avoid boxing into tuples, you can also use <code class="language-plaintext highlighter-rouge">zipMap2</code>,
<code class="language-plaintext highlighter-rouge">zipMap3</code> … <code class="language-plaintext highlighter-rouge">zipMap6</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Task</span><span class="o">.</span><span class="py">zipMap3</span><span class="o">(</span><span class="n">locationTask</span><span class="o">,</span> <span class="n">phoneTask</span><span class="o">,</span> <span class="n">addressTask</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">(</span><span class="n">location</span><span class="o">,</span> <span class="n">phone</span><span class="o">,</span> <span class="n">address</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"Gotcha!"</span>
<span class="o">}</span>
</code></pre></div></div>
    
      <h3 id="gather-results-from-a-seq-of-tasks">
        
        
          Gather results from a Seq of Tasks <a href="#gather-results-from-a-seq-of-tasks" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.sequence</code>, takes a <code class="language-plaintext highlighter-rouge">Seq[Task[A]]</code> and returns a <code class="language-plaintext highlighter-rouge">Task[Seq[A]]</code>,
thus transforming any sequence of tasks into a task with a sequence of
results and with ordered effects and results. This means that the
tasks WILL NOT execute in parallel.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">ta</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect1"</span><span class="o">);</span> <span class="mi">1</span> <span class="o">}</span>
<span class="k">val</span> <span class="nv">tb</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect2"</span><span class="o">);</span> <span class="mi">2</span> <span class="o">}</span>

<span class="k">val</span> <span class="nv">list</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">sequence</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">))</span>

<span class="c1">// We always get this ordering:</span>
<span class="nv">list</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; List(1, 2)</span>
</code></pre></div></div>

<p>The results are ordered in the order of the initial sequence, so that
means in the example above we are guaranteed in the result to first
get the result of <code class="language-plaintext highlighter-rouge">ta</code> (the first task) and then the result of <code class="language-plaintext highlighter-rouge">tb</code>
(the second task). The execution itself is also ordered, so <code class="language-plaintext highlighter-rouge">ta</code>
executes and completes before <code class="language-plaintext highlighter-rouge">tb</code>.</p>

<p><code class="language-plaintext highlighter-rouge">Task.gather</code>, also known as <code class="language-plaintext highlighter-rouge">Task.zipList</code>, is the nondeterministic
version of <code class="language-plaintext highlighter-rouge">Task.sequence</code>.  It also takes a <code class="language-plaintext highlighter-rouge">Seq[Task[A]]</code> and
returns a <code class="language-plaintext highlighter-rouge">Task[Seq[A]]</code>, thus transforming any sequence of tasks into
a task with a sequence of ordered results. But the effects are not
ordered, meaning that there’s potential for parallel execution:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">ta</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect1"</span><span class="o">);</span> <span class="mi">1</span> <span class="o">}</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">tb</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect2"</span><span class="o">);</span> <span class="mi">2</span> <span class="o">}</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">list</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">gather</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">))</span>

<span class="nv">list</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; List(1, 2)</span>

<span class="nv">list</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; List(1, 2)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Task.gatherUnordered</code> is like <code class="language-plaintext highlighter-rouge">gather</code>, except that you don’t get
ordering for results or effects. The result is thus highly nondeterministic,
but yields better performance than <code class="language-plaintext highlighter-rouge">gather</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">ta</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect1"</span><span class="o">);</span> <span class="mi">1</span> <span class="o">}</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">tb</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect2"</span><span class="o">);</span> <span class="mi">2</span> <span class="o">}</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">list</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">gatherUnordered</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">))</span>

<span class="nv">list</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; Seq(2,1)</span>

<span class="nv">list</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; Seq(1,2)</span>
</code></pre></div></div>
    
      <h3 id="choose-first-of-two-tasks">
        
        
          Choose First Of Two Tasks <a href="#choose-first-of-two-tasks" class="anchor">#</a>
        
        
      </h3>

<p>The <code class="language-plaintext highlighter-rouge">chooseFirstOf</code> operation will choose the winner between two
<code class="language-plaintext highlighter-rouge">Task</code> that will potentially run in parallel:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">ta</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">tb</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">race</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">chooseFirstOf</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">).</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Left</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">futureB</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="nv">futureB</span><span class="o">.</span><span class="py">cancel</span><span class="o">()</span>
    <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"A succeeded: $a"</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Right</span><span class="o">((</span><span class="n">futureA</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="nv">futureA</span><span class="o">.</span><span class="py">cancel</span><span class="o">()</span>
    <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"B succeeded: $b"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The result generated will be an <code class="language-plaintext highlighter-rouge">Either</code> of tuples, giving you the
opportunity to do something with the other task that lost the race.
You can cancel it, or you can use its result somehow, or you can
simply ignore it, your choice depending on use-case.</p>
    
      <h3 id="choose-first-of-list">
        
        
          Choose First Of List <a href="#choose-first-of-list" class="anchor">#</a>
        
        
      </h3>

<p>The <code class="language-plaintext highlighter-rouge">chooseFirstOfList</code> operation takes as input a list of tasks,
and upon execution will generate the result of the first task
that completes and wins the race:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">ta</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">tb</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="o">{</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">chooseFirstOfList</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">))</span>
    <span class="o">.</span><span class="py">runAsync</span>
    <span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Winner: $r"</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It is similar to Scala’s
<a href="http://www.scala-lang.org/api/current/index.html#scala.concurrent.Future$@firstCompletedOf[T](futures:TraversableOnce[scala.concurrent.Future[T]])(implicitexecutor:scala.concurrent.ExecutionContext):scala.concurrent.Future[T]">Future.firstCompletedOf</a>
operation, except that it operates on <code class="language-plaintext highlighter-rouge">Task</code> and upon execution it has
a better model, as when a task wins the race the other tasks get
immediately canceled.</p>

<p>If you want to ignore errors and wait for the first successful result you could 
combine it with <code class="language-plaintext highlighter-rouge">onErrorHandleWith</code> and <code class="language-plaintext highlighter-rouge">timeout</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.exceptions.DummyException</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">timeout</span> <span class="k">=</span> <span class="mf">30.</span><span class="n">second</span>

<span class="k">val</span> <span class="nv">task1</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">3.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">task2</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">DummyException</span><span class="o">(</span><span class="s">"error"</span><span class="o">)).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">task3</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">DummyException</span><span class="o">(</span><span class="s">"error"</span><span class="o">)).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">tasks</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">task1</span><span class="o">,</span> <span class="n">task2</span><span class="o">,</span> <span class="n">task3</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">result</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">chooseFirstOfList</span><span class="o">(</span><span class="nv">tasks</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">onErrorHandleWith</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">never</span><span class="o">))).</span><span class="py">timeout</span><span class="o">(</span><span class="n">timeout</span><span class="o">)</span>

<span class="nv">result</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span> <span class="c1">// will print 10</span>
</code></pre></div></div>
<p>It will turn any failed tasks into non-terminating.</p>

<p>Timeout is necessary in case all tasks fail.</p>
    
      <h3 id="delay-execution">
        
        
          Delay Execution <a href="#delay-execution" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.delayExecution</code>, as the name says, delays the execution of a
given task by the given timespan.</p>

<p>In this example we are delaying the execution of the source by 3
seconds:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="s">"Side-effect!"</span><span class="o">)</span>
  <span class="s">"Hello, world!"</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">delayed</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>
<span class="nv">delayed</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div></div>

<p>Or, instead of a delay we might want to use another <code class="language-plaintext highlighter-rouge">Task</code> as the
signal for starting the execution, so the following example is
equivalent to the one above:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">trigger</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">unit</span><span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="s">"Side-effect!"</span><span class="o">)</span>
  <span class="s">"Hello, world!"</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">delayed</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">delayExecutionWith</span><span class="o">(</span><span class="n">trigger</span><span class="o">)</span>
<span class="nv">delayed</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div></div>
    
      <h3 id="delay-signaling-of-the-result">
        
        
          Delay Signaling of the Result <a href="#delay-signaling-of-the-result" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.delayResult</code> delays the signaling of the result, but not the
execution of the <code class="language-plaintext highlighter-rouge">Task</code>. Consider this example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="s">"Side-effect!"</span><span class="o">)</span>
  <span class="s">"Hello, world!"</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">delayed</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">source</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
    <span class="o">.</span><span class="py">delayResult</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">delayed</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div></div>

<p>Here, you’ll see the “side-effect happening after only 1 second, but
the signaling of the result will happen after another 5 seconds.</p>

<p>There’s also another variant called <code class="language-plaintext highlighter-rouge">delayResultBySelector</code>, where you
can have another task signal the right moment when to signal the
result downstream. This allows to customize the delay based on the
result signaled by the source:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="s">"Side-effect!"</span><span class="o">)</span>
  <span class="nv">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">selector</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">unit</span><span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="nv">x</span><span class="o">.</span><span class="py">seconds</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">delayed</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">source</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
    <span class="o">.</span><span class="py">delayResultBySelector</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nf">selector</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="o">}</span>

<span class="nv">delayed</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span>
  <span class="nf">println</span><span class="o">(</span>
    <span class="n">s</span><span class="s">"Result: $x "</span> <span class="o">+</span>
    <span class="n">s</span><span class="s">"(signaled after at least ${x+1} seconds)"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>
    
      <h3 id="restart-until-predicate-is-true">
        
        
          Restart Until Predicate is True <a href="#restart-until-predicate-is-true" class="anchor">#</a>
        
        
      </h3>

<p>The <code class="language-plaintext highlighter-rouge">Task</code> being a spec, we can restart it at will.
<code class="language-plaintext highlighter-rouge">Task.restartUntil(predicate)</code> does just that, executing the source
over and over again, until the given predicate is true:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">val</span> <span class="nv">randomEven</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="nv">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">())</span>
    <span class="o">.</span><span class="py">restartUntil</span><span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">randomEven</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; -2097793116</span>
<span class="nv">randomEven</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; 1246761488</span>
<span class="nv">randomEven</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; 1053678416</span>
</code></pre></div></div>
    
      <h3 id="clean-up-resources-on-finish">
        
        
          Clean-up Resources on Finish <a href="#clean-up-resources-on-finish" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.doOnFinish</code> executes the supplied
<code class="language-plaintext highlighter-rouge">Option[Throwable] =&gt; Task[Unit]</code> function when the source finishes,
being meant for cleaning up resources or executing
some scheduled side-effect:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">withFinishCb</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">doOnFinish</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
    <span class="nf">println</span><span class="o">(</span><span class="s">"Was success!"</span><span class="o">)</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">unit</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Had failure: $ex"</span><span class="o">)</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">unit</span>
<span class="o">}</span>

<span class="nv">withFinishCb</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Was success!</span>
<span class="c1">//=&gt; 1</span>
</code></pre></div></div>
    
      <h3 id="convert-to-reactive-publisher">
        
        
          Convert to Reactive Publisher <a href="#convert-to-reactive-publisher" class="anchor">#</a>
        
        
      </h3>

<p>Did you know that Monix integrates with the
<a href="http://www.reactive-streams.org/">Reactive Streams</a>
specification?</p>

<p>Well, <code class="language-plaintext highlighter-rouge">Task</code> can be seen as an <code class="language-plaintext highlighter-rouge">org.reactivestreams.Publisher</code> that
emits exactly one event upon subscription and then stops. And we can
convert any <code class="language-plaintext highlighter-rouge">Task</code> to such a publisher directly:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="nv">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">())</span>

<span class="k">val</span> <span class="nv">publisher</span><span class="k">:</span> <span class="kt">org.reactivestreams.Publisher</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">task</span><span class="o">.</span><span class="py">toReactivePublisher</span>
</code></pre></div></div>

<p>This is meant for interoperability purposes with other libraries, but
if you’re inclined to use it directly, it’s a little lower level,
but doable:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">org.reactivestreams._</span>

<span class="nv">publisher</span><span class="o">.</span><span class="py">subscribe</span><span class="o">(</span><span class="k">new</span> <span class="nc">Subscriber</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">onSubscribe</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Subscription</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="nv">s</span><span class="o">.</span><span class="py">request</span><span class="o">(</span><span class="nv">Long</span><span class="o">.</span><span class="py">MaxValue</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">onNext</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"OnNext: $e"</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">onComplete</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="nf">println</span><span class="o">(</span><span class="s">"OnComplete"</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">onError</span><span class="o">(</span><span class="n">ex</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="nv">System</span><span class="o">.</span><span class="py">err</span><span class="o">.</span><span class="py">println</span><span class="o">(</span><span class="n">s</span><span class="s">"ERROR: $ex"</span><span class="o">)</span>
<span class="o">})</span>

<span class="c1">// Will print:</span>
<span class="c1">//=&gt; OnNext: -228329246</span>
<span class="c1">//=&gt; OnComplete</span>
</code></pre></div></div>

<p>Awesome, isn’t it?</p>

<p>(◑‿◐)</p>
    
      <h2 id="error-handling">
        
        
          Error Handling <a href="#error-handling" class="anchor">#</a>
        
        
      </h2>

<p><code class="language-plaintext highlighter-rouge">Task</code> takes error handling very seriously. You see, there’s this famous
<a href="https://en.wikipedia.org/wiki/If_a_tree_falls_in_a_forest">thought experiment</a>
regarding <em>observation</em>:</p>

<blockquote>
  <p>“<em>If a tree falls in a forest and no one is around to hear it, does
it make a sound?</em>”</p>
</blockquote>

<p>Now this applies very well to error handling, because if an error is
triggered by an asynchronous process and there’s nobody to hear it, no
handler to catch it and log it or recover from it, then it didn’t
happen. And what you’ll get is
<a href="https://en.wikipedia.org/wiki/Nondeterministic_algorithm">nondeterminism</a>
without any hints of the error involved.</p>

<p>This is why Monix will always attempt to catch and signal or at least
log any errors that happen. In case signaling is not possible for
whatever reason (like the callback was already called), then the
logging is done by means of the provided <code class="language-plaintext highlighter-rouge">Scheduler.reportFailure</code>,
which defaults to <code class="language-plaintext highlighter-rouge">System.err</code>, unless you provide something more
concrete, like going through SLF4J or whatever.</p>

<p>Even though Monix expects for the arguments given to its operators,
like <code class="language-plaintext highlighter-rouge">flatMap</code>, to be pure or at least protected from errors, it still
catches errors, signaling them on <code class="language-plaintext highlighter-rouge">runOnComplete</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="nv">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">even</span> <span class="k">if</span> <span class="n">even</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">=&gt;</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">even</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">odd</span> <span class="k">=&gt;</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="nv">odd</span><span class="o">.</span><span class="py">toString</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runOnComplete</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">//=&gt; Success(-924040280)</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runOnComplete</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">//=&gt; Failure(java.lang.IllegalStateException: 834919637)</span>
</code></pre></div></div>

<p>In case an error happens in the callback provided to <code class="language-plaintext highlighter-rouge">runOnComplete</code>, then
Monix can no longer signal an <code class="language-plaintext highlighter-rouge">onError</code>, because it would be a
contract violation (see <a href="/docs/2x/eval/callback.html">Callback</a>). But it still
logs the error:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="c1">// Ensures asynchronous execution, just to show</span>
<span class="c1">// that the action doesn't happen on the</span>
<span class="c1">// current thread</span>
<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runOnComplete</span> <span class="o">{</span> <span class="n">r</span> <span class="k">=&gt;</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="nv">r</span><span class="o">.</span><span class="py">toString</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// After 1 second, this will log the whole stack trace:</span>
<span class="c1">//=&gt; java.lang.IllegalStateException: Success(2)</span>
<span class="c1">//=&gt;    ...</span>
<span class="c1">//=&gt;	at monix.eval.Task$$anon$3.onSuccess(Task.scala:78)</span>
<span class="c1">//=&gt;	at monix.eval.Callback$SafeCallback.onSuccess(Callback.scala:66)</span>
<span class="c1">//=&gt;	at monix.eval.Task$.trampoline$1(Task.scala:1248)</span>
<span class="c1">//=&gt;	at monix.eval.Task$.monix$eval$Task$$resume(Task.scala:1304)</span>
<span class="c1">//=&gt;	at monix.eval.Task$AsyncStateRunnable$$anon$20.onSuccess(Task.scala:1432)</span>
<span class="c1">//=&gt;    ....</span>
</code></pre></div></div>

<p>Similarly, when using <code class="language-plaintext highlighter-rouge">Task.create</code>, Monix attempts to catch any
uncaught errors, but because we did not know what happened in the
provided callback, we cannot signal the error as it would be a
contract violation (see <a href="/docs/2x/eval/callback.html">Callback</a>), but Monix does
log the error:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">create</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span> <span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">callback</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="s">"FTW!"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">future</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span>

<span class="c1">// Logs the following to System.err:</span>
<span class="c1">//=&gt; java.lang.IllegalStateException: FTW!</span>
<span class="c1">//=&gt;    ...</span>
<span class="c1">//=&gt; 	at monix.eval.Task$$anonfun$create$1.apply(Task.scala:576)</span>
<span class="c1">//=&gt; 	at monix.eval.Task$$anonfun$create$1.apply(Task.scala:571)</span>
<span class="c1">//=&gt; 	at monix.eval.Task$AsyncStateRunnable.run(Task.scala:1429)</span>
<span class="c1">//=&gt;    ...</span>

<span class="c1">// The Future NEVER COMPLETES, OOPS!</span>
<span class="nv">future</span><span class="o">.</span><span class="py">onComplete</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
</code></pre></div></div>

<p><strong>WARNING:</strong> In this case the consumer side never gets a completion
signal. The moral of the story is: even if Monix makes a best effort
to do the right thing, you should protect your freaking code against
unwanted exceptions, especially in <code class="language-plaintext highlighter-rouge">Task.create</code>!!!</p>
    
      <h3 id="overriding-the-error-logging">
        
        
          Overriding the Error Logging <a href="#overriding-the-error-logging" class="anchor">#</a>
        
        
      </h3>

<p>The article on <a href="/docs/2x/execution/scheduler.html">Scheduler</a> has recipes
for building your own <code class="language-plaintext highlighter-rouge">Scheduler</code> instances, with your own logic. But
here’s a quick snippet for building such a <code class="language-plaintext highlighter-rouge">Scheduler</code> that could do
logging by means of a library, such as the standard
<a href="http://www.slf4j.org/">SLF4J</a>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Scheduler</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.</span><span class="o">{</span><span class="n">global</span> <span class="k">=&gt;</span> <span class="n">default</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">monix.execution.UncaughtExceptionReporter</span>
<span class="k">import</span> <span class="nn">org.slf4j.LoggerFactory</span>

<span class="k">val</span> <span class="nv">reporter</span> <span class="k">=</span> <span class="nc">UncaughtExceptionReporter</span> <span class="o">{</span> <span class="n">ex</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="nv">logger</span> <span class="k">=</span> <span class="nv">LoggerFactory</span><span class="o">.</span><span class="py">getLogger</span><span class="o">(</span><span class="s">"monix"</span><span class="o">)</span>
  <span class="nv">logger</span><span class="o">.</span><span class="py">error</span><span class="o">(</span><span class="s">"Uncaught exception"</span><span class="o">,</span> <span class="n">ex</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">global</span><span class="k">:</span> <span class="kt">Scheduler</span> <span class="o">=</span>
  <span class="nc">Scheduler</span><span class="o">(</span><span class="n">default</span><span class="o">,</span> <span class="n">reporter</span><span class="o">)</span>
</code></pre></div></div>
    
      <h3 id="trigger-a-timeout">
        
        
          Trigger a Timeout <a href="#trigger-a-timeout" class="anchor">#</a>
        
        
      </h3>

<p>In case a <code class="language-plaintext highlighter-rouge">Task</code> is too slow to execute, we can cancel it and trigger
a <code class="language-plaintext highlighter-rouge">TimeoutException</code> using <code class="language-plaintext highlighter-rouge">Task.timeout</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span>
  <span class="nc">Task</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span>

<span class="c1">// Triggers error if the source does not</span>
<span class="c1">// complete in 3 seconds after runOnComplete</span>
<span class="k">val</span> <span class="nv">timedOut</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">timeout</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>

<span class="nv">timedOut</span><span class="o">.</span><span class="py">runOnComplete</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">//=&gt; Failure(TimeoutException)</span>
</code></pre></div></div>

<p>On timeout the source gets canceled (if it’s a source that supports
cancelation). And instead of an error, we can timeout to a <code class="language-plaintext highlighter-rouge">fallback</code>
task. The following example is equivalent to the above one:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span>
  <span class="nc">Task</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">timedOut</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">timeoutTo</span><span class="o">(</span>
  <span class="mf">3.</span><span class="n">seconds</span><span class="o">,</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">TimeoutException</span><span class="o">)</span>
<span class="o">)</span>

<span class="nv">timedOut</span><span class="o">.</span><span class="py">runOnComplete</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">//=&gt; Failure(TimeoutException)</span>
</code></pre></div></div>
    
      <h3 id="recovering-from-error">
        
        
          Recovering from Error <a href="#recovering-from-error" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.onErrorHandleWith</code> is an operation that takes a function mapping
possible exceptions to a desired fallback outcome, so we could do
this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span>
    <span class="o">.</span><span class="py">timeout</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">recovered</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">onErrorHandleWith</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">TimeoutException</span> <span class="o">=&gt;</span>
    <span class="c1">// Oh, we know about timeouts, recover it</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="s">"Recovered!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span>
    <span class="c1">// We have no idea what happened, raise error!</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="n">other</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">recovered</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Recovered!</span>
</code></pre></div></div>

<p>There’s also <code class="language-plaintext highlighter-rouge">Task.onErrorRecoverWith</code> that takes a partial function
instead, so we can omit the “other” branch:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">recovered</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">onErrorRecoverWith</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">TimeoutException</span> <span class="o">=&gt;</span>
    <span class="c1">// Oh, we know about timeouts, recover it</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="s">"Recovered!"</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">recovered</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Recovered!</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Task.onErrorHandleWith</code> and <code class="language-plaintext highlighter-rouge">Task.onErrorRecoverWith</code> are the
equivalent of <code class="language-plaintext highlighter-rouge">flatMap</code>, only for errors. In case we know or can
evaluate a fallback result eagerly, we could use the shortcut
operation <code class="language-plaintext highlighter-rouge">Task.onErrorHandle</code> like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">recovered</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">onErrorHandle</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">TimeoutException</span> <span class="o">=&gt;</span>
    <span class="c1">// Oh, we know about timeouts, recover it</span>
    <span class="s">"Recovered!"</span>
  <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span>
    <span class="k">throw</span> <span class="n">other</span> <span class="c1">// Rethrowing</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Or the partial function version with <code class="language-plaintext highlighter-rouge">onErrorRecover</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">recovered</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">onErrorRecover</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">TimeoutException</span> <span class="o">=&gt;</span>
    <span class="c1">// Oh, we know about timeouts, recover it</span>
    <span class="s">"Recovered!"</span>
<span class="o">}</span>
</code></pre></div></div>
    
      <h3 id="restart-on-error">
        
        
          Restart On Error <a href="#restart-on-error" class="anchor">#</a>
        
        
      </h3>

<p>The <code class="language-plaintext highlighter-rouge">Task</code> type, being just a specification, it can usually restart
whatever process is supposed to deliver the final result and we can
restart the source on error, for how many times are needed:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="nv">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">even</span> <span class="k">if</span> <span class="n">even</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">=&gt;</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">even</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="nv">other</span><span class="o">.</span><span class="py">toString</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">// Will retry 4 times for a random even number,</span>
<span class="c1">// or fail if the maxRetries is reached!</span>
<span class="k">val</span> <span class="nv">randomEven</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">onErrorRestart</span><span class="o">(</span><span class="n">maxRetries</span> <span class="k">=</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>We can also restart with a given predicate:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="nv">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">even</span> <span class="k">if</span> <span class="n">even</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">=&gt;</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">even</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="nv">other</span><span class="o">.</span><span class="py">toString</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">// Will keep retrying for as long as the source fails</span>
<span class="c1">// with an IllegalStateException</span>
<span class="k">val</span> <span class="nv">randomEven</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">onErrorRestartIf</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">IllegalStateException</span> <span class="o">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Or we could implement our own retry with exponential backoff, because
it’s cool doing so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">retryBackoff</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">source</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span>
  <span class="n">maxRetries</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">firstDelay</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="nv">source</span><span class="o">.</span><span class="py">onErrorHandleWith</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">Exception</span> <span class="o">=&gt;</span>
      <span class="nf">if</span> <span class="o">(</span><span class="n">maxRetries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="c1">// Recursive call, it's OK as Monix is stack-safe</span>
        <span class="nf">retryBackoff</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">maxRetries</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">firstDelay</span><span class="o">*</span><span class="mi">2</span><span class="o">)</span>
          <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="n">firstDelay</span><span class="o">)</span>
      <span class="k">else</span>
        <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
    
      <h3 id="expose-errors">
        
        
          Expose Errors <a href="#expose-errors" class="anchor">#</a>
        
        
      </h3>

<p>The <code class="language-plaintext highlighter-rouge">Task</code> monadic context is hiding errors that happen, much like
Scala’s <code class="language-plaintext highlighter-rouge">Try</code> or <code class="language-plaintext highlighter-rouge">Future</code>. But sometimes we want to expose those
errors such that we can recover more efficiently:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Try</span><span class="o">,</span> <span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">materialized</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">source</span><span class="o">.</span><span class="py">materialize</span>

<span class="c1">// Now we can flatMap over both success and failure:</span>
<span class="k">val</span> <span class="nv">recovered</span> <span class="k">=</span> <span class="nv">materialized</span><span class="o">.</span><span class="py">flatMap</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">recovered</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; 0</span>
</code></pre></div></div>

<p>There’s also the reverse of materialize, which is <code class="language-plaintext highlighter-rouge">Task.dematerialize</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Try</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">)</span>

<span class="c1">// Exposing errors</span>
<span class="k">val</span> <span class="nv">materialized</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">materialize</span>
<span class="c1">// materialize: Task[Try[Int]] = ???</span>

<span class="c1">// Hiding errors again</span>
<span class="k">val</span> <span class="nv">dematerialized</span> <span class="k">=</span> <span class="nv">materialized</span><span class="o">.</span><span class="py">dematerialize</span>
<span class="c1">// dematerialized: Task[Int] = ???</span>
</code></pre></div></div>

<p>We can also convert any <code class="language-plaintext highlighter-rouge">Task</code> into a <code class="language-plaintext highlighter-rouge">Task[Throwable]</code> that will
expose any errors that happen and will also terminate with an
<code class="language-plaintext highlighter-rouge">NoSuchElementException</code> in case the source completes with success:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">throwable</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">failed</span>
<span class="c1">// throwable: Task[Throwable] = ???</span>

<span class="nv">throwable</span><span class="o">.</span><span class="py">runAsync</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; java.lang.IllegalStateException</span>
</code></pre></div></div>


  <div class="buttons">
    <a href="/docs/2x/">Contents</a> •
    <a href="https://github.com/monix/monix.io/blob/main/_docs/2x/eval/task.md">
      Edit Page</a> •
    
    <a href="https://gitter.im/monix/monix">
      Join Chat</a> •
    <a href="/social.html">
      Follow</a>
  </div>
</div>
      </article>
    </div>
    <!-- Here goes scripts and stuff, but right now there's nothing. -->
  </body>
</html>
