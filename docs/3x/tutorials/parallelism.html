<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  
  <title>Parallel Processing &mdash; Monix</title>

  <link rel="canonical" href="https://monix.io/docs/current/tutorials/parallelism.html" />

  <!-- Twitter Cards -->
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:image:src" content="https://monix.io/public/images/monix-logo-rect.png">
  <meta name="twitter:site" content="@monix" />  
  <meta name="twitter:creator" content="@monix" />  
  <meta name="twitter:title" content="Parallel Processing &amp;mdash; Monix" />
  <meta name="twitter:description" content="Recipes for achieving parallelism" />
  <meta name="twitter:url" content="https://monix.io/docs/3x/tutorials/parallelism.html">
  <!-- Facebook Open-Graph -->
  <meta property="fb:app_id" content="2160100887367418" />

  <meta content="Monix" property="og:site_name">
  <meta content="Parallel Processing &amp;mdash; Monix" property="og:title">
  <meta content="Recipes for achieving parallelism" property="og:description">
  <meta content="https://monix.io/docs/3x/tutorials/parallelism.html" property="og:url">
  <meta content="2021-05-14T14:48:18+00:00" property="article:modified_time">
    
  <meta content="article" property="og:type">
  <meta property="og:image" content="https://monix.io/public/images/monix-logo.png" />
  <meta property="og:image:secure_url" content="https://monix.io/public/images/monix-logo.png" />
  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/all.css?1635892108300815428">
  <!--[if lt IE 9]>
  <link rel="stylesheet" href="/public/css/forkme.ie.css?1635892108300815428">
  <![endif]-->

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Web App Manifest, see: http://manifest.sysapps.org/ -->
  <link rel="manifest" href="/manifest.json">
  <!-- Icons -->
  <link rel="icon" sizes="48x48" href="/public/icons/icon-48x48.png">
  <link rel="icon" sizes="72x72" href="/public/icons/icon-72x72.png">
  <link rel="icon" sizes="96x96" href="/public/icons/icon-96x96.png">
  <link rel="icon" sizes="144x144" href="/public/icons/icon-144x144.png">
  <link rel="icon" sizes="192x192" href="/public/icons/icon-192x192.png">
  <link rel="icon" sizes="240x240" href="/public/icons/icon-240x240.png">
  <link rel="icon" sizes="384x384" href="/public/icons/icon-384x384.png">
  <!-- Mobile Safari / iOS Icons -->
  <link rel="apple-touch-icon" sizes="48x48" href="/public/icons/icon-48x48.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/public/icons/icon-72x72.png">
  <link rel="apple-touch-icon" sizes="96x96" href="/public/icons/icon-96x96.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/public/icons/icon-144x144.png">
  <link rel="apple-touch-icon" sizes="192x192" href="/public/icons/icon-192x192.png">
  <link rel="apple-touch-icon" sizes="240x240" href="/public/icons/icon-240x240.png">
  <link rel="apple-touch-icon" sizes="384x384" href="/public/icons/icon-384x384.png">
  <!-- Standard Favicon -->
  <link rel="shortcut icon" href="/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="Feed" href="/blog/atom.xml">
</head>


  <body class="monix layout">
    <div class="wrapper">
      <aside class="sidebar plus">
  <div class="container">
    <div class="sidebar-about">
      <a class="github-fork-ribbon left-top" href="https://github.com/monix/monix"
        title="Fork me on GitHub">Fork me on GitHub</a>

      <h1>
        <a href="/">
          <img src="/public/images/monix-logo.png"
            alt="Monix Logo" title="Monix" class="logo" />
        </a>
      </h1>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">About</a>
      <a class="sidebar-nav-item" href="/blog/">Blog</a>
      <a class="sidebar-nav-item active" href="/docs/current/">Documentation</a>
      <a class="sidebar-nav-item" href="/presentations/">Presentations</a>
      <a class="sidebar-nav-item" href="/social.html">Follow @Monix</a>
      <a class="sidebar-nav-item" href="/privacy.html">Privacy Policy</a>
    </nav>
  </div>
</aside>


      <article class="content container">
        <div class="page">
      <h1 class="page-title">
        
        
          Parallel Processing
        
        
      </h1>

  
  <time class="post-date" itemprop="dateModified"
    datetime="2021-05-14">
    <b>Page updated at:</b> 14 May 2021
  </time>
  <nav role="navigation" id="type-info">
    
    
    
    <a href="https://github.com/monix/monix.io/blob/master/_docs/3x/tutorials/parallelism.md">Edit Page</a>
    
  </nav>
  
  <div id="version3x">
    You are viewing the documentation for the latest Monix 3.x series.<br/>
    Older versions:
    
      <a href="/docs/2x/tutorials/parallelism.html">2.x</a>
  </div>

  <nav role="navigation" id="toc">
    <ul>
  <li><a href="#parallelism-with-task">Parallelism with Task</a>
    <ul>
      <li><a href="#the-naive-way">The Naive Way</a></li>
      <li><a href="#imposing-a-parallelism-limit">Imposing a Parallelism Limit</a></li>
      <li><a href="#batched-observables">Batched Observables</a></li>
    </ul>
  </li>
  <li><a href="#observablemapparallelunordered">Observable.mapParallelUnordered</a></li>
  <li><a href="#observablemergemap">Observable.mergeMap</a></li>
  <li><a href="#consumerloadbalancer">Consumer.loadBalancer</a></li>
</ul>

  </nav>

  <p>Monix provides multiple ways for achieving parallelism, depending on use-case.</p>

<p>The samples in this document are copy/paste-able, but to get the imports out of the way:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// On evaluation a Scheduler is needed</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
<span class="c1">// For Task</span>
<span class="k">import</span> <span class="nn">monix.eval._</span>
<span class="c1">// For Observable</span>
<span class="k">import</span> <span class="nn">monix.reactive._</span>
</code></pre></div></div>
    
      <h2 id="parallelism-with-task">
        
        
          Parallelism with Task <a href="#parallelism-with-task" class="anchor">#</a>
        
        
      </h2>

<p>We can do parallel execution in batches, that does deterministic
(ordered) signaling of results with the help of <a href="/docs/3x/eval/task.html">Task</a>.</p>
    
      <h3 id="the-naive-way">
        
        
          The Naive Way <a href="#the-naive-way" class="anchor">#</a>
        
        
      </h3>

<p>The following example uses
<a href="/api/3.4/monix/eval/Task$.htmll#parSequenceN[A](parallelism:Int)(in:Iterable[monix.eval.Task[A]]):monix.eval.Task[List[A]]">Task.parSequence</a>,
which does parallel processing while preserving result ordering.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">items</span> <span class="k">=</span> <span class="mi">0</span> <span class="n">until</span> <span class="mi">1000</span>

<span class="c1">// The list of all tasks needed for execution</span>
<span class="k">val</span> <span class="nv">tasks</span> <span class="k">=</span> <span class="nv">items</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="o">))</span>
<span class="c1">// Processing in parallel</span>
<span class="k">val</span> <span class="nv">aggregate</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">parSequence</span><span class="o">(</span><span class="n">tasks</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">toList</span><span class="o">)</span>

<span class="c1">// Evaluation:</span>
<span class="nv">aggregate</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; List(0, 2, 4, 6, 8, 10, 12, 14, 16,...</span>
</code></pre></div></div>

<p>If ordering of results does not matter, you can also use 
<a href="/api/3.4/monix/eval/Task$.htmll#parSequenceUnordered[A](in:Iterable[monix.eval.Task[A]]):monix.eval.Task[List[A]]">Task.parSequenceUnordered</a>
instead of <code class="language-plaintext highlighter-rouge">parSequence</code>, which might yield better results, given its non-blocking execution.</p>
    
      <h3 id="imposing-a-parallelism-limit">
        
        
          Imposing a Parallelism Limit <a href="#imposing-a-parallelism-limit" class="anchor">#</a>
        
        
      </h3>

<p>The <code class="language-plaintext highlighter-rouge">Task.parSequence</code> builder, as exemplified above, will potentially execute
all given tasks in parallel, the problem being that this can lead to inefficiency.
For example we might be doing HTTP requests and starting 10000 HTTP
requests in parallel is not necessarily wise as it can choke the
server on the other end.</p>

<p>To solve this we can split the workload in batches of parallel tasks that
are then sequenced:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">items</span> <span class="k">=</span> <span class="mi">0</span> <span class="n">until</span> <span class="mi">1000</span>
<span class="c1">// The list of all tasks needed for execution</span>
<span class="k">val</span> <span class="nv">tasks</span> <span class="k">=</span> <span class="nv">items</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="o">))</span>
<span class="c1">// Building batches of 10 tasks to execute in parallel:</span>
<span class="k">val</span> <span class="nv">batches</span> <span class="k">=</span> <span class="nv">tasks</span><span class="o">.</span><span class="py">sliding</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">parSequence</span><span class="o">(</span><span class="n">b</span><span class="o">)).</span><span class="py">toIterable</span>
<span class="c1">// Sequencing batches, then flattening the final result</span>
<span class="k">val</span> <span class="nv">aggregate</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">sequence</span><span class="o">(</span><span class="n">batches</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">flatten</span><span class="o">.</span><span class="py">toList</span><span class="o">)</span>

<span class="c1">// Evaluation:</span>
<span class="nv">aggregate</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; List(0, 2, 4, 6, 8, 10, 12, 14, 16,...</span>
</code></pre></div></div>

<p>Note how this strategy is difficult to achieve with Scala’s <code class="language-plaintext highlighter-rouge">Future</code>
because even though we have <code class="language-plaintext highlighter-rouge">Future.sequence</code>, its behavior is strict
and is thus not able to differentiate well between sequencing and
parallelism, this behavior being controlled by passing a lazy or a
strict sequence to <code class="language-plaintext highlighter-rouge">Future.sequence</code>, which is obviously error-prone.</p>
    
      <h3 id="batched-observables">
        
        
          Batched Observables <a href="#batched-observables" class="anchor">#</a>
        
        
      </h3>

<p>We can also combine this with <code class="language-plaintext highlighter-rouge">Observable.flatMap</code> for doing requests
in batches:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval._</span>
<span class="k">import</span> <span class="nn">monix.reactive._</span>

<span class="c1">// The `bufferIntrospective` will do buffering, up to a certain</span>
<span class="c1">// `bufferSize`, for as long as the downstream is busy and then</span>
<span class="c1">// stream a whole sequence of all buffered events at once</span>
<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1000</span><span class="o">).</span><span class="py">bufferIntrospective</span><span class="o">(</span><span class="mi">256</span><span class="o">)</span>

<span class="c1">// Processing in batches, powered by `Task`</span>
<span class="k">val</span> <span class="nv">batched</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">items</span> <span class="k">=&gt;</span>
  <span class="c1">// The list of all tasks needed for execution</span>
  <span class="k">val</span> <span class="nv">tasks</span> <span class="k">=</span> <span class="nv">items</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="o">))</span>
  <span class="c1">// Building batches of 10 tasks to execute in parallel:</span>
  <span class="k">val</span> <span class="nv">batches</span> <span class="k">=</span> <span class="nv">tasks</span><span class="o">.</span><span class="py">sliding</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">parSequence</span><span class="o">(</span><span class="n">b</span><span class="o">)).</span><span class="py">toIterable</span>
  <span class="c1">// Sequencing batches, then flattening the final result</span>
  <span class="k">val</span> <span class="nv">aggregate</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">sequence</span><span class="o">(</span><span class="n">batches</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">flatten</span><span class="o">.</span><span class="py">iterator</span><span class="o">)</span>
  <span class="c1">// Converting into an observable, needed for flatMap</span>
  <span class="nv">Observable</span><span class="o">.</span><span class="py">fromIterator</span><span class="o">(</span><span class="n">aggregate</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Evaluation:</span>
<span class="nv">batched</span><span class="o">.</span><span class="py">toListL</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; List(0, 2, 4, 6, 8, 10, 12, 14, 16,...</span>
</code></pre></div></div>

<p>Note the use of 
<a href="/api/3.4/monix/reactive/Observable.html#bufferIntrospective(maxSize:Int):Self[List[A]]">bufferIntrospective</a>,
which buffers incoming events while the downstream is busy, after which
it emits the buffer as a single bundle. The
<a href="/api/3.4/monix/reactive/Observable.html#bufferTumbling(count:Int):Self[Seq[A]]">bufferTumbling</a>
operator can be a more deterministic alternative.</p>
    
      <h2 id="observablemapparallelunordered">
        
        
          Observable.mapParallelUnordered <a href="#observablemapparallelunordered" class="anchor">#</a>
        
        
      </h2>

<p>Another way to achieve parallelism is to use the 
<a href="/api/3.4/monix/reactive/Observable.html#mapParallelUnordered[B](parallelism:Int)(f:A=&gt;monix.eval.Task[B]):Self[B]">Observable.mapParallelUnordered</a>
operator:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1000</span><span class="o">)</span>
<span class="c1">// The parallelism factor needs to be specified</span>
<span class="k">val</span> <span class="nv">processed</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">mapParallelUnordered</span><span class="o">(</span><span class="n">parallelism</span> <span class="k">=</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
  <span class="nc">Task</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Evaluation:</span>
<span class="nv">processed</span><span class="o">.</span><span class="py">toListL</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; List(2, 10, 0, 4, 8, 6, 12...</span>
</code></pre></div></div>

<p>Compared with using <code class="language-plaintext highlighter-rouge">Task.parSequence</code> as exemplified above, this operator
<strong>does not maintain ordering</strong> of results as signaled by the source.</p>

<p>This leads to a more efficient execution, because the source doesn’t
get back-pressured for as long as there’s at least one worker active,
whereas with the batched execution strategy exemplified above we can
have inefficiencies due to a single async task that takes too long to
complete.</p>
    
      <h2 id="observablemergemap">
        
        
          Observable.mergeMap <a href="#observablemergemap" class="anchor">#</a>
        
        
      </h2>

<p>If <code class="language-plaintext highlighter-rouge">Observable.mapParallelUnordered</code> works with <code class="language-plaintext highlighter-rouge">Task</code>, then 
<a href="https://monix.io/api/2.2/monix/reactive/Observable.html#mergeMap[B](f:A=%3Emonix.reactive.Observable[B])(implicitos:monix.reactive.OverflowStrategy[B]):Self[B]">Observable.mergeMap</a>
works by merging <code class="language-plaintext highlighter-rouge">Observable</code> instances.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1000</span><span class="o">)</span>
<span class="c1">// The parallelism factor needs to be specified</span>
<span class="k">val</span> <span class="nv">processed</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">mergeMap</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
  <span class="nv">Observable</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="o">).</span><span class="py">executeAsync</span>
<span class="o">}</span>

<span class="c1">// Evaluation:</span>
<span class="nv">processed</span><span class="o">.</span><span class="py">toListL</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; List(0, 4, 6, 2, 8, 10, 12, 14...</span>
</code></pre></div></div>

<p>Note that <code class="language-plaintext highlighter-rouge">mergeMap</code> is similar with <code class="language-plaintext highlighter-rouge">concatMap</code> (aliased by <code class="language-plaintext highlighter-rouge">flatMap</code>
in Monix), except that the observable streams emitted by the source
get subscribed in parallel and thus the result is non-deterministic.</p>

<p>Note that this <code class="language-plaintext highlighter-rouge">mergeMap</code> call, as exemplified above, does not have an
optional <code class="language-plaintext highlighter-rouge">parallelism</code> parameter, which means that if the source is
chatty, we can end up with <em>a lot</em> of observables subscribed in
parallel. The issue is that the <code class="language-plaintext highlighter-rouge">mergeMap</code> operator is not meant for
actual processing in parallel, but for joining active, concurrent
streams.</p>
    
      <h2 id="consumerloadbalancer">
        
        
          Consumer.loadBalancer <a href="#consumerloadbalancer" class="anchor">#</a>
        
        
      </h2>

<p>We can apply a <code class="language-plaintext highlighter-rouge">mapParallelUnordered</code> like operation on the consumer side, as
exemplified in the <a href="/docs/3x/reactive/consumer.html">Consumer</a> tutorial, by means of a
load-balanced consumer, being able to do a final aggregate of the
results of all workers:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval._</span>
<span class="k">import</span> <span class="nn">monix.reactive._</span>

<span class="c1">// A consumer that folds over the elements of the stream,</span>
<span class="c1">// producing a sum as a result</span>
<span class="k">val</span> <span class="nv">sumConsumer</span> <span class="k">=</span> <span class="nv">Consumer</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">[</span><span class="kt">Long</span>,<span class="kt">Long</span><span class="o">](</span><span class="mi">0L</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>

<span class="c1">// For processing sums in parallel, useless of course, but can become </span>
<span class="c1">// really helpful for logic sprinkled with I/O bound stuff</span>
<span class="k">val</span> <span class="nv">loadBalancer</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Consumer</span>
    <span class="o">.</span><span class="py">loadBalance</span><span class="o">(</span><span class="n">parallelism</span><span class="k">=</span><span class="mi">10</span><span class="o">,</span> <span class="n">sumConsumer</span><span class="o">)</span>
    <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">sum</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">observable</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">100000</span><span class="o">)</span>
<span class="c1">// Our consumer turns our observable into a Task processing sums, w00t!</span>
<span class="k">val</span> <span class="nv">task</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="nv">observable</span><span class="o">.</span><span class="py">consumeWith</span><span class="o">(</span><span class="n">loadBalancer</span><span class="o">)</span>

<span class="c1">// Consume the whole stream and get the result</span>
<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; 4999950000</span>
</code></pre></div></div>

<p>Read the <a href="/docs/3x/reactive/consumer.html">Consumer</a> document for more details.</p>


  <div class="buttons">
    <a href="/docs/3x/">Contents</a> •
    <a href="https://github.com/monix/monix.io/blob/master/_docs/3x/tutorials/parallelism.md">
      Edit Page</a> •
    
    <a href="https://gitter.im/monix/monix">
      Join Chat</a> •
    <a href="/social.html">
      Follow</a>
  </div>

  </div>
      </article>
    </div>
    <script type="text/javascript">
  var _paq = window._paq || [];
  // Disabling cookies for privacy reasons
  _paq.push(['disableCookies']);
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="https://ly.monix.io/";
    _paq.push(['setTrackerUrl', u+'m.php']);
    _paq.push(['setSiteId', '2']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'m.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<noscript>
  
  <img src="https://ly.monix.io/m.php?idsite=2&rec=1&action_name=Parallel+Processing" style="border:0" alt="" />
</noscript>


  </body>
</html>
