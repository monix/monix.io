<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  
  <title>Observable &mdash; Monix</title>

  <link rel="canonical" href="https://monix.io/docs/current/reactive/observable.html" />

  <!-- Twitter Cards -->
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:image:src" content="https://monix.io/public/images/monix-logo-rect.png">
  <meta name="twitter:site" content="@monix" />  
  <meta name="twitter:creator" content="@monix" />  
  <meta name="twitter:title" content="Observable &amp;mdash; Monix" />
  <meta name="twitter:description" content="A data type for modeling and processing asynchronous and reactive streaming of events with non-blocking back-pressure." />
  <meta name="twitter:url" content="https://monix.io/docs/3x/reactive/observable.html">
  <!-- Facebook Open-Graph -->
  <meta property="fb:app_id" content="2160100887367418" />

  <meta content="Monix" property="og:site_name">
  <meta content="Observable &amp;mdash; Monix" property="og:title">
  <meta content="A data type for modeling and processing asynchronous and reactive streaming of events with non-blocking back-pressure." property="og:description">
  <meta content="https://monix.io/docs/3x/reactive/observable.html" property="og:url">
  <meta content="2022-03-29T17:05:41+00:00" property="article:modified_time">
    
  <meta content="article" property="og:type">
  <meta property="og:image" content="https://monix.io/public/images/monix-logo.png" />
  <meta property="og:image:secure_url" content="https://monix.io/public/images/monix-logo.png" />
  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/all.css?1648573955934635456">
  <!--[if lt IE 9]>
  <link rel="stylesheet" href="/public/css/forkme.ie.css?1648573955934635456">
  <![endif]-->

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Web App Manifest, see: http://manifest.sysapps.org/ -->
  <link rel="manifest" href="/manifest.json">
  <!-- Icons -->
  <link rel="icon" sizes="48x48" href="/public/icons/icon-48x48.png">
  <link rel="icon" sizes="72x72" href="/public/icons/icon-72x72.png">
  <link rel="icon" sizes="96x96" href="/public/icons/icon-96x96.png">
  <link rel="icon" sizes="144x144" href="/public/icons/icon-144x144.png">
  <link rel="icon" sizes="192x192" href="/public/icons/icon-192x192.png">
  <link rel="icon" sizes="240x240" href="/public/icons/icon-240x240.png">
  <link rel="icon" sizes="384x384" href="/public/icons/icon-384x384.png">
  <!-- Mobile Safari / iOS Icons -->
  <link rel="apple-touch-icon" sizes="48x48" href="/public/icons/icon-48x48.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/public/icons/icon-72x72.png">
  <link rel="apple-touch-icon" sizes="96x96" href="/public/icons/icon-96x96.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/public/icons/icon-144x144.png">
  <link rel="apple-touch-icon" sizes="192x192" href="/public/icons/icon-192x192.png">
  <link rel="apple-touch-icon" sizes="240x240" href="/public/icons/icon-240x240.png">
  <link rel="apple-touch-icon" sizes="384x384" href="/public/icons/icon-384x384.png">
  <!-- Standard Favicon -->
  <link rel="shortcut icon" href="/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="Feed" href="/blog/atom.xml">
</head>


  <body class="monix layout">
    <div class="wrapper">
      <aside class="sidebar plus">
  <div class="container">
    <div class="sidebar-about">
      <a class="github-fork-ribbon left-top" href="https://github.com/monix/monix"
        title="Fork me on GitHub">Fork me on GitHub</a>

      <h1>
        <a href="/">
          <img src="/public/images/monix-logo.png"
            alt="Monix Logo" title="Monix" class="logo" />
        </a>
      </h1>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">About</a>
      <a class="sidebar-nav-item" href="/blog/">Blog</a>
      <a class="sidebar-nav-item active" href="/docs/current/">Documentation</a>
      <a class="sidebar-nav-item" href="/presentations/">Presentations</a>
      <a class="sidebar-nav-item" href="/social.html">Follow @Monix</a>
      <a class="sidebar-nav-item" href="/privacy.html">Privacy Policy</a>
    </nav>
  </div>
</aside>


      <article class="content container">
        <div class="page">
      <h1 class="page-title">
        
        
          Observable
        
        
      </h1>

  
  <time class="post-date" itemprop="dateModified"
    datetime="2022-03-29">
    <b>Page updated at:</b> 29 Mar 2022
  </time>
  <nav role="navigation" id="type-info">
    <a href="/api/3.4/monix/reactive/Observable.html">API Documentation</a>
    <a href="https://github.com/monix/monix/blob/v3.4.0/monix-reactive/shared/src/main/scala/monix/reactive/Observable.scala">Source Code</a>
    
    <a href="https://github.com/monix/monix.io/blob/main/_docs/3x/reactive/observable.md">Edit Page</a>
  </nav>
  
  <div id="version3x">
    You are viewing the documentation for the latest Monix 3.x series.<br/>
    Older versions:
    
      <a href="/docs/2x/reactive/observable.html">2.x</a>
  </div>

  <nav role="navigation" id="toc">
    <ul>
  <li><a href="#introduction">Introduction</a>
    <ul>
      <li><a href="#design-summary">Design Summary</a></li>
      <li><a href="#learning-resources">Learning resources</a></li>
    </ul>
  </li>
  <li><a href="#observable-contract">Observable Contract</a>
    <ul>
      <li><a href="#how-it-works-internally">How it works internally</a></li>
    </ul>
  </li>
  <li><a href="#observable-and-functional-programming">Observable and Functional Programming</a></li>
  <li><a href="#execution">Execution</a>
    <ul>
      <li><a href="#consumer">Consumer</a></li>
      <li><a href="#foldleft-methods">FoldLeft Methods</a></li>
    </ul>
  </li>
  <li><a href="#building-an-observable">Building an Observable</a>
    <ul>
      <li><a href="#observablepure-now">Observable.pure (now)</a></li>
      <li><a href="#observabledelay-eval">Observable.delay (eval)</a></li>
      <li><a href="#observableevalonce">Observable.evalOnce</a></li>
      <li><a href="#observablefromiterable">Observable.fromIterable</a></li>
      <li><a href="#observablesuspend-defer">Observable.suspend (defer)</a></li>
      <li><a href="#observableraiseerror">Observable.raiseError</a></li>
    </ul>
  </li>
  <li><a href="#sending-elements-to-an-observable">Sending elements to an Observable</a>
    <ul>
      <li><a href="#observablecreate">Observable.create</a></li>
      <li><a href="#observablerepeatevalf--concurrent-data-structure">Observable.repeatEvalF + concurrent data structure</a></li>
      <li><a href="#concurrentsubject">ConcurrentSubject</a></li>
    </ul>
  </li>
  <li><a href="#back-pressure-buffering-throttling">Back-pressure, buffering, throttling</a>
    <ul>
      <li><a href="#overflowstrategy">OverflowStrategy</a></li>
      <li><a href="#asynchronous-processing">Asynchronous processing</a></li>
      <li><a href="#processing-elements-in-batches">Processing elements in batches</a></li>
      <li><a href="#limiting-the-rate-of-emission-of-elements">Limiting the rate of emission of elements</a></li>
    </ul>
  </li>
  <li><a href="#transforming-observables">Transforming Observables</a>
    <ul>
      <li><a href="#map">map</a></li>
      <li><a href="#mapeval">mapEval</a></li>
      <li><a href="#mapparallel">mapParallel</a></li>
      <li><a href="#flatmap-concatmap">flatMap (concatMap)</a></li>
      <li><a href="#mergemap">mergeMap</a></li>
      <li><a href="#switchmap">switchMap</a></li>
      <li><a href="#summary">Summary</a></li>
    </ul>
  </li>
  <li><a href="#scheduling">Scheduling</a>
    <ul>
      <li><a href="#intervalwithfixeddelay-interval">intervalWithFixedDelay (interval)</a></li>
      <li><a href="#intervalatfixedrate">intervalAtFixedRate</a></li>
    </ul>
  </li>
  <li><a href="#error-handling">Error Handling</a>
    <ul>
      <li><a href="#handleerror-onerrorhandle">handleError (onErrorHandle)</a></li>
      <li><a href="#handleerrorwith-onerrorhandlewith">handleErrorWith (onErrorHandleWith)</a></li>
      <li><a href="#recover-onerrorrecover">recover (onErrorRecover)</a></li>
      <li><a href="#recoverwith-onerrorrecoverwith">recoverWith (onErrorRecoverWith)</a></li>
      <li><a href="#onerrorfallbackto">onErrorFallbackTo</a></li>
      <li><a href="#onerrorrestart">onErrorRestart</a></li>
      <li><a href="#onerrorrestartif">onErrorRestartIf</a></li>
      <li><a href="#retrying-with-delay">Retrying with delay</a></li>
      <li><a href="#dropping-failed-elements">Dropping failed elements</a></li>
      <li><a href="#monaderror-instance">MonadError instance</a></li>
    </ul>
  </li>
  <li><a href="#reacting-to-internal-events">Reacting to internal events</a>
    <ul>
      <li><a href="#doonnext">doOnNext</a></li>
    </ul>
  </li>
  <li><a href="#subjects">Subjects</a></li>
  <li><a href="#sharing-an-observable">Sharing an Observable</a>
    <ul>
      <li><a href="#connectableobservable">ConnectableObservable</a></li>
      <li><a href="#back-pressure">Back-pressure</a></li>
      <li><a href="#configuring-underlying-subject">Configuring underlying Subject</a></li>
      <li><a href="#doing-it-the-pure-way">Doing it the pure way</a></li>
    </ul>
  </li>
  <li><a href="#interoperability-with-other-streams-api-akka-streams-fs2">Interoperability with other Streams API (Akka Streams, FS2)</a>
    <ul>
      <li><a href="#akka-streams">Akka Streams</a></li>
      <li><a href="#fs2">FS2</a></li>
    </ul>
  </li>
</ul>

  </nav>
    
      <h2 id="introduction">
        
        
          Introduction <a href="#introduction" class="anchor">#</a>
        
        
      </h2>

<p>The <code class="language-plaintext highlighter-rouge">Observable</code> is a data type for modeling and processing
asynchronous and reactive streaming of events with non-blocking
back-pressure.</p>

<p>The <code class="language-plaintext highlighter-rouge">Observable</code> is strongly inspired by
<a href="http://reactivex.io/">ReactiveX</a>, but with an idiomatic Scala API and
influenced by the Scala ecosystem of projects such as
<a href="http://typelevel.org/cats/">Cats</a> and
<a href="http://scalaz.org/">Scalaz</a>. It’s also compatible with the
<a href="http://www.reactive-streams.org/">Reactive Streams</a> specification,
hence it has good interoperability.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We need a Scheduler in scope in order to make </span>
<span class="c1">// the Observable produce elements when subscribed</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
<span class="k">import</span> <span class="nn">monix.reactive._</span>

<span class="k">import</span> <span class="nn">concurrent.duration._</span>

<span class="c1">// We first build an observable that emits a tick per second, </span>
<span class="c1">// the series of elements being an auto-incremented long</span>
<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">interval</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
  <span class="c1">// Filtering out odd numbers, making it emit every 2 seconds</span>
  <span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
  <span class="c1">// We then make it emit the same element twice</span>
  <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nc">Observable</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span>
  <span class="c1">// This stream would be infinite, so we limit it to 10 items</span>
  <span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
  
<span class="c1">// Observables are lazy, nothing happens until you subscribe...</span>
<span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span> <span class="n">source</span>
  <span class="c1">// On consuming it, we want to dump the contents to stdout</span>
  <span class="c1">// for debugging purposes</span>
  <span class="o">.</span><span class="py">dump</span><span class="o">(</span><span class="s">"O"</span><span class="o">)</span>
  <span class="c1">// Finally, start consuming it</span>
  <span class="o">.</span><span class="py">subscribe</span><span class="o">()</span>

</code></pre></div></div>

<p>At its simplest, an <code class="language-plaintext highlighter-rouge">Observable</code> is a replacement for your regular
<a href="#scala.collection.Iterable">Iterable</a>
or Scala 
<a href="#scala.collection.immutable.Stream">Stream</a>, 
but with the ability to process asynchronous events without blocking. 
In fact, you can convert any <code class="language-plaintext highlighter-rouge">Iterable</code> into an <code class="language-plaintext highlighter-rouge">Observable</code>.</p>

<p>But this <code class="language-plaintext highlighter-rouge">Observable</code> implementation scales to complex problems, touching on
<em><a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">functional reactive programming (FRP)</a></em>,
and it can also model complex interactions between producers and consumers,
being a potent alternative for
<a href="http://akka.io/">the actor model</a>.</p>
    
      <h3 id="design-summary">
        
        
          Design Summary <a href="#design-summary" class="anchor">#</a>
        
        
      </h3>

<p>A visual representation of where it sits in the design space:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">Single</th>
      <th style="text-align: center">Multiple</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>Synchronous</strong></td>
      <td style="text-align: center">A</td>
      <td style="text-align: center">Iterable[A]</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>Asynchronous</strong></td>
      <td style="text-align: center">Future[A] / Task[A]</td>
      <td style="text-align: center">Observable[A]</td>
    </tr>
  </tbody>
</table>

<p>The Monix <code class="language-plaintext highlighter-rouge">Observable</code>:</p>

<ul>
  <li>models lazy &amp; asynchronous streaming of events</li>
  <li>highly composable and lawful</li>
  <li>basically the
<a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer pattern</a>
on steroids</li>
  <li>you can also think of it as being like a Scala
<a href="#scala.concurrent.Future">Future</a> or like
a <a href="/docs/3x/eval/task.html">Task</a>, except with the ability to stream 
multiple items instead of just one, or you can think of it as an asynchronous 
and non-blocking
<a href="#scala.collection.Iterable">Iterable</a>
with benefits</li>
  <li>models producer-consumer relationships, where you can have a single
producer pushing data into one or multiple consumers</li>
  <li>works best for unidirectional communications</li>
  <li>allows fine-grained control over the <a href="/docs/3x/execution/scheduler.html#execution-model">execution model</a></li>
  <li>doesn’t trigger the execution, or any effects until a client <code class="language-plaintext highlighter-rouge">subscribe</code>s</li>
  <li>allows cancellation of active streams</li>
  <li>never blocks any threads in its implementation</li>
  <li>does not expose any API calls that can block threads</li>
  <li>compatible with <a href="http://www.scala-js.org/">Scala.js</a> like the rest of Monix</li>
</ul>

<p>See <strong><a href="/docs/3x/reactive/observable-comparisons.html">comparisons with similar tools, like Akka or FS2</a></strong>.</p>
    
      <h3 id="learning-resources">
        
        
          Learning resources <a href="#learning-resources" class="anchor">#</a>
        
        
      </h3>

<p>The following documentation barely scratches the surface of <code class="language-plaintext highlighter-rouge">Observable</code> and is rather incomplete.
If you find it lacking, make sure to check either the <a href="/api/3.4/monix/reactive/Observable.html">Observable API</a> or
look at the comments <a href="https://github.com/monix/monix">in the code</a> directly. We put a lot of focus on scaladocs.</p>

<p>Another great resource is the <a href="http://reactivex.io/">ReactiveX</a> documentation, which opens doors
to plenty of books, blog posts and Stack Overflow answers.
There are significant differences in the model, but the majority of functions behave the same, so it is a fantastic source
of examples and additional explanations.</p>

<p>And last but not the least, we are always happy to help on <a href="https://gitter.im/monix/monix">gitter channel</a>. Any feedback
regarding the documentation itself (like confusing wording) is really appreciated too.</p>
    
      <h2 id="observable-contract">
        
        
          Observable Contract <a href="#observable-contract" class="anchor">#</a>
        
        
      </h2>

<p>An <code class="language-plaintext highlighter-rouge">Observable</code> can be thought of as the next layer of abstraction with regard to <code class="language-plaintext highlighter-rouge">Observer</code> and <code class="language-plaintext highlighter-rouge">Subscriber</code>.</p>

<p>An <code class="language-plaintext highlighter-rouge">Observable</code> can be described in the following way:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Observable</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">subscribe</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">Observer</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Cancelable</span>
<span class="o">}</span>
</code></pre></div></div>

<p>where an <code class="language-plaintext highlighter-rouge">Observer</code> is:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Observer</span><span class="o">[</span><span class="kt">-T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">onNext</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Ack</span><span class="o">]</span>

  <span class="k">def</span> <span class="nf">onError</span><span class="o">(</span><span class="n">ex</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>

  <span class="k">def</span> <span class="nf">onComplete</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
</code></pre></div></div>

<p>An <code class="language-plaintext highlighter-rouge">Observer</code> subscribes to an <code class="language-plaintext highlighter-rouge">Observable</code>, so the <code class="language-plaintext highlighter-rouge">Observable</code> internals need to respect the <code class="language-plaintext highlighter-rouge">Observer</code> <a href="/docs/3x/reactive/observers.html#contract">contract</a> when it passes element(s) to it. You can consider it being a higher level interface which abstracts away the details of the contract and handles it for the user.</p>
    
      <h3 id="how-it-works-internally">
        
        
          How it works internally <a href="#how-it-works-internally" class="anchor">#</a>
        
        
      </h3>

<p>If you are inexperienced with non-blocking reactive streams, it probably sounds confusing. The understanding of the underlying model 
is not necessary to be a successful user of the <code class="language-plaintext highlighter-rouge">Observable</code>, but if you would like to know anyway (also perhaps to contribute your own low level operators),
the following paragraph tries to explain the essence of how it works. Note that the implementations of many operators are sometimes obfuscated with optimizations, which make them look much more
complicated than they really are.</p>

<p>An <code class="language-plaintext highlighter-rouge">Observable</code> will pass through the generated items to the <code class="language-plaintext highlighter-rouge">Observer</code>, by calling <code class="language-plaintext highlighter-rouge">onNext</code>.
Imagine the following situation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Observable</span><span class="o">.</span><span class="py">fromIterable</span><span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">3</span><span class="o">)</span>
  <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="o">)</span>
  <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="o">)</span>
  <span class="o">.</span><span class="py">sum</span>
  <span class="o">.</span><span class="py">firstL</span> <span class="c1">// returns Task[Long]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">fromIterable</code> is a builder which creates an <code class="language-plaintext highlighter-rouge">Observable</code>. Hence, it implements <code class="language-plaintext highlighter-rouge">subscribe</code>. This method passes 
each element to its subscribers by calling its <code class="language-plaintext highlighter-rouge">onNext</code> method. Once the sequence is empty it calls <code class="language-plaintext highlighter-rouge">onComplete</code> to signal that there aren’t any 
elements left to process and the entire <code class="language-plaintext highlighter-rouge">Observable</code> can end. 
Note that the <code class="language-plaintext highlighter-rouge">observer.onNext(elem)</code> returns a <code class="language-plaintext highlighter-rouge">Future[Ack]</code>. To obey the contract and preserve back-pressure, the <code class="language-plaintext highlighter-rouge">Observable</code> will have to wait for its result before it can pass the next element. 
<code class="language-plaintext highlighter-rouge">Ack</code> can be either <code class="language-plaintext highlighter-rouge">Continue</code> (ok to send the next element) or <code class="language-plaintext highlighter-rouge">Stop</code> (we should shut down).
This way, we can stop the downstream processing (by calling <code class="language-plaintext highlighter-rouge">onComplete</code>) and the upstream (returning <code class="language-plaintext highlighter-rouge">Stop</code> after <code class="language-plaintext highlighter-rouge">onNext</code>).</p>

<p><code class="language-plaintext highlighter-rouge">map</code> is essentially an <code class="language-plaintext highlighter-rouge">Observer =&gt; Observer</code> function. It implements <code class="language-plaintext highlighter-rouge">onNext</code>, <code class="language-plaintext highlighter-rouge">onError</code> and <code class="language-plaintext highlighter-rouge">onComplete</code>.
 The happy path goes like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(1) fromIterable calls map1.onNext(i)
(2) map1 does some transformation and calls map2.onNext(i + 2)
(3) map2 does some transformation and calls sumL.onNext(i * 3)
(4) sum saves and acknowledges the incoming items and holds off on calling firstL.onNext until it receives an onComplete signal.
(5) firstL waits for the first onNext signal to complete a Task
</code></pre></div></div>

<p>Points (1) to (3) iterate until the entire sequence of elements (in this case, numbers) are consumed. 
When <code class="language-plaintext highlighter-rouge">sum</code> acknowledges (returns from <code class="language-plaintext highlighter-rouge">onNext</code> method) to its caller <code class="language-plaintext highlighter-rouge">map2</code>, <code class="language-plaintext highlighter-rouge">map2</code> in turn can acknowledge to its caller <code class="language-plaintext highlighter-rouge">map1</code>, which then
acknowledges to its caller <code class="language-plaintext highlighter-rouge">fromIterable</code> - only then can a new element be sent. 
In case any <code class="language-plaintext highlighter-rouge">onNext</code> invocations return a <code class="language-plaintext highlighter-rouge">Stop</code>, this would also propagate upstream and there wouldn’t be any new elements generated.</p>

<p>If you try to jump into the source code of operators, you will see that they are obfuscated by concurrency, error handling 
and lots of optimizations, but the essence of the model works as described above. There is nothing more to it, no extra
interpreters or materializers to add an extra layer of indirection - so if this section makes sense to you, you should have
a decent idea of what’s going on “behind the scenes”.</p>
    
      <h2 id="observable-and-functional-programming">
        
        
          Observable and Functional Programming <a href="#observable-and-functional-programming" class="anchor">#</a>
        
        
      </h2>

<p>The <code class="language-plaintext highlighter-rouge">Observable</code> internals are written in an imperative, Java-like style. It doesn’t look pretty and can be discouraging
if you’re trying to write your own operator. However, by using a relatively simple model (in terms of operations to do) the implementation
is very performant and this design choice is a big reason why it does so well <a href="https://github.com/monix/streaming-benchmarks">in comparison to the competition</a>.</p>

<p>Despite a mostly-imperative base, an <code class="language-plaintext highlighter-rouge">Observable</code> exposes a vast number of purely functional operators that compose really well, allowing you to build functionality on top of them in
similar way to how it’s done in other streaming libraries from the FP ecosystem.</p>

<p>If you’re mostly using available methods and want to write a purely functional application then you’re in luck because the 
dirty internals don’t leak outside and the majority of the API and the process of constructing and executing <code class="language-plaintext highlighter-rouge">Observable</code>s are all pure.</p>

<p>The main drawback in comparison to purely functional streams, such as <a href="https://github.com/functional-streams-for-scala/fs2">fs2</a> or
<a href="/api/3.4/monix/tail/Iterant.html">Iterant</a>, is the presence of impure functions in the API. If you have inexperienced 
team members, they could be tempted to use them. Fortunately, all of them are marked with the <code class="language-plaintext highlighter-rouge">@UnsafeBecauseImpure</code> annotation and are explained in the ScalaDoc. 
There should always be a referentially transparent replacement to solve your specific use case but if your team is not fully committed to FP, these functions can be very useful.</p>

<p>For instance, an efficient and convenient way to share an <code class="language-plaintext highlighter-rouge">Observable</code> is by using a <strong>hot</strong> <code class="language-plaintext highlighter-rouge">Observable</code> - but it’s not referentially transparent.
Nevertheless, you could do the same thing using the <code class="language-plaintext highlighter-rouge">doOnNext</code> or <code class="language-plaintext highlighter-rouge">doOnNextF</code> together with some purely functional concurrency structures from <code class="language-plaintext highlighter-rouge">Cats-Effect</code> such as <code class="language-plaintext highlighter-rouge">Ref</code> or <code class="language-plaintext highlighter-rouge">MVar</code> to share state in a more controlled manner.</p>

<p>Just like in Scala itself, the decision is up to the user to choose what’s better for them and their team.</p>
    
      <h2 id="execution">
        
        
          Execution <a href="#execution" class="anchor">#</a>
        
        
      </h2>

<p>When you create an <code class="language-plaintext highlighter-rouge">Observable</code> nothing actually happens until <code class="language-plaintext highlighter-rouge">subscribe</code> is called.
Processing can be triggered directly by calling <code class="language-plaintext highlighter-rouge">subscribe()(implicit s: Scheduler): Cancelable</code> which starts
in the background and return a <code class="language-plaintext highlighter-rouge">Cancelable</code> which can be used to stop the streaming.</p>

<p>If you write programs in purely functional manner and would rather combine the results of <code class="language-plaintext highlighter-rouge">Observable</code>s, 
you can convert them to <a href="/docs/3x/eval/task.html">Task</a>s and compose them all the way through your program until the very end (Main method).
The resulting <code class="language-plaintext highlighter-rouge">Task</code> can also be cancelled and is the recommended way to execute an <code class="language-plaintext highlighter-rouge">Observable</code>.</p>

<p>Two main ways to convert an <code class="language-plaintext highlighter-rouge">Observable</code> into a <code class="language-plaintext highlighter-rouge">Task</code> are described below.</p>
    
      <h3 id="consumer">
        
        
          Consumer <a href="#consumer" class="anchor">#</a>
        
        
      </h3>

<p>One of the ways to trigger an <code class="language-plaintext highlighter-rouge">Observable</code> is to use a <a href="/docs/3x/reactive/consumer.html">Consumer</a> - which can thought of as a function that converts an <code class="language-plaintext highlighter-rouge">Observable</code> into a <code class="language-plaintext highlighter-rouge">Task</code>.</p>

<p>You can either create your own <code class="language-plaintext highlighter-rouge">Consumer</code> or use one of the many prebuilt ones:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">list</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> 
    <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1000</span><span class="o">)</span>
      <span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
      <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
      
<span class="k">val</span> <span class="nv">consumer</span><span class="k">:</span> <span class="kt">Consumer</span><span class="o">[</span><span class="kt">Long</span>, <span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">Consumer</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">(</span><span class="mi">0L</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
    
<span class="k">val</span> <span class="nv">task</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">list</span><span class="o">.</span><span class="py">consumeWith</span><span class="o">(</span><span class="n">consumer</span><span class="o">)</span>
</code></pre></div></div>

<p>You can find more examples in the <a href="/docs/3x/reactive/consumer.html">Consumer documentation</a>.</p>
    
      <h3 id="foldleft-methods">
        
        
          FoldLeft Methods <a href="#foldleft-methods" class="anchor">#</a>
        
        
      </h3>

<p>Any method suffixed with <code class="language-plaintext highlighter-rouge">L</code> in the API converts an <code class="language-plaintext highlighter-rouge">Observable</code> into a <code class="language-plaintext highlighter-rouge">Task</code>.</p>

<p>For example, you can use the <code class="language-plaintext highlighter-rouge">firstL</code> method to obtain the first element of the <code class="language-plaintext highlighter-rouge">Observable</code>:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Task(0)</span>
<span class="k">val</span> <span class="nv">task</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1000</span><span class="o">).</span><span class="py">firstL</span>
</code></pre></div></div>

<p>The following example achieves the same result as the previous section on <code class="language-plaintext highlighter-rouge">Consumer</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">list</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> 
    <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1000</span><span class="o">)</span>
      <span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
      <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
       
<span class="k">val</span> <span class="nv">task</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">list</span><span class="o">.</span><span class="py">foldLeftL</span><span class="o">(</span><span class="mi">0L</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>
    
      <h2 id="building-an-observable">
        
        
          Building an Observable <a href="#building-an-observable" class="anchor">#</a>
        
        
      </h2>

<p>These methods are available via the <code class="language-plaintext highlighter-rouge">Observable</code> companion object. Below are several examples:</p>
    
      <h3 id="observablepure-now">
        
        
          Observable.pure (now) <a href="#observablepure-now" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable.pure</code> (alias for <code class="language-plaintext highlighter-rouge">now</code>) simply lifts an already known value in the <code class="language-plaintext highlighter-rouge">Observable</code> context.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">obs</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">now</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">// obs: monix.reactive.Observable[String] = NowObservable@327a283b</span>
</code></pre></div></div>
    
      <h3 id="observabledelay-eval">
        
        
          Observable.delay (eval) <a href="#observabledelay-eval" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable.delay</code> (alias for <code class="language-plaintext highlighter-rouge">eval</code>) lifts non-strict value in the <code class="language-plaintext highlighter-rouge">Observable</code>. It is evaluated upon subscription.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">obs</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">delay</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="c1">// obs: monix.reactive.Observable[String] = EvalAlwaysObservable@48a8050</span>
<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">obs</span><span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">// task: monix.eval.Task[Unit] = Task.Async$1782722529</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>

<span class="c1">// The evaluation (and thus all contained side effects)</span>
<span class="c1">// gets triggered on each runToFuture:</span>
<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>
    
      <h3 id="observableevalonce">
        
        
          Observable.evalOnce <a href="#observableevalonce" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable.evalOnce</code> takes a non-strict value and converts it into an Observable
that emits a single element and memoizes the value for subsequent invocations.
It also has guaranteed idempotency and thread-safety:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">obs</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">evalOnce</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="c1">// obs: monix.reactive.Observable[String] = EvalOnceObservable@3233e694</span>
<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">obs</span><span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">// task: monix.eval.Task[Unit] = Task.Async$1782722529</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>

<span class="c1">// Result was memoized on the first run!</span>
<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>
    
      <h3 id="observablefromiterable">
        
        
          Observable.fromIterable <a href="#observablefromiterable" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable.fromIterable</code> converts any <code class="language-plaintext highlighter-rouge">Iterable</code> into an <code class="language-plaintext highlighter-rouge">Observable</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">obs</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">fromIterable</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="c1">// obs: monix.reactive.Observable[Int] = IterableAsObservable@7b0e123d</span>

<span class="nv">obs</span><span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">).</span><span class="py">runToFuture</span>
<span class="c1">//=&gt; 1</span>
<span class="c1">//=&gt; 2</span>
<span class="c1">//=&gt; 3</span>
</code></pre></div></div>
    
      <h3 id="observablesuspend-defer">
        
        
          Observable.suspend (defer) <a href="#observablesuspend-defer" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable.suspend</code> (alias for defer) allows suspending side effects:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>
<span class="k">import</span> <span class="nn">scala.io.Source</span>

<span class="k">def</span> <span class="nf">readFile</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> 
    <span class="nv">Observable</span><span class="o">.</span><span class="py">suspend</span> <span class="o">{</span>
        <span class="c1">// The side effect won't happen until subscription</span>
        <span class="k">val</span> <span class="nv">lines</span> <span class="k">=</span> <span class="nv">Source</span><span class="o">.</span><span class="py">fromFile</span><span class="o">(</span><span class="n">path</span><span class="o">).</span><span class="py">getLines</span><span class="o">()</span>
        <span class="nv">Observable</span><span class="o">.</span><span class="py">fromIterator</span><span class="o">(</span><span class="nc">Task</span><span class="o">(</span><span class="n">lines</span><span class="o">))</span>
    <span class="o">}</span>
</code></pre></div></div>
    
      <h3 id="observableraiseerror">
        
        
          Observable.raiseError <a href="#observableraiseerror" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable.raiseError</code> constructs an Observable that calls <code class="language-plaintext highlighter-rouge">onError</code> on any subscriber emitting specified <code class="language-plaintext highlighter-rouge">Exception</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"my exception"</span><span class="o">))</span>
<span class="c1">// observable: monix.reactive.Observable[Int]</span>

<span class="o">{</span>
<span class="n">observable</span>
  <span class="o">.</span><span class="py">onErrorHandle</span> <span class="o">{</span><span class="n">ex</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Got exception: ${ex.getMessage}"</span><span class="o">);</span> <span class="mi">1</span><span class="o">}</span>
  <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">//=&gt; Got exception: my exception</span>
<span class="c1">//=&gt; 1</span>
</code></pre></div></div>
    
      <h2 id="sending-elements-to-an-observable">
        
        
          Sending elements to an Observable <a href="#sending-elements-to-an-observable" class="anchor">#</a>
        
        
      </h2>

<p>There are several options to feed an <code class="language-plaintext highlighter-rouge">Observable</code> with elements from another part of an application.</p>
    
      <h3 id="observablecreate">
        
        
          Observable.create <a href="#observablecreate" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable.create</code> is a builder for creating an <code class="language-plaintext highlighter-rouge">Observable</code> from sources which can’t be back-pressured.
It takes a <code class="language-plaintext highlighter-rouge">f: Subscriber.Sync[A] =&gt; Cancelable</code>. <code class="language-plaintext highlighter-rouge">Subscriber.Sync</code> is an <code class="language-plaintext highlighter-rouge">Observer</code> with a built-in <code class="language-plaintext highlighter-rouge">Scheduler</code> which 
doesn’t have to worry about the back-pressure contract, which makes it safe to use even for inexperienced <code class="language-plaintext highlighter-rouge">Observable</code> users. 
An <code class="language-plaintext highlighter-rouge">Observable</code> which is returned by the method will receive all elements which were sent to the <code class="language-plaintext highlighter-rouge">Subscriber</code>.
Since they could be sent concurrently, it buffers the elements when busy, according to the specified <code class="language-plaintext highlighter-rouge">OverflowStrategy</code>.
<code class="language-plaintext highlighter-rouge">Cancelable</code> can contain special logic in case the subscription is canceled:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.Ack</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>
<span class="k">import</span> <span class="nn">monix.reactive.OverflowStrategy</span>
<span class="k">import</span> <span class="nn">monix.reactive.observers.Subscriber</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">def</span> <span class="nf">producerLoop</span><span class="o">(</span><span class="n">sub</span><span class="k">:</span> <span class="kt">Subscriber</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">deferFuture</span><span class="o">(</span><span class="nv">sub</span><span class="o">.</span><span class="py">onNext</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">100.</span><span class="n">millis</span><span class="o">)</span>
    <span class="o">.</span><span class="py">flatMap</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nv">Ack</span><span class="o">.</span><span class="py">Continue</span> <span class="k">=&gt;</span> <span class="nf">producerLoop</span><span class="o">(</span><span class="n">sub</span><span class="o">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
      <span class="k">case</span> <span class="nv">Ack</span><span class="o">.</span><span class="py">Stop</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">unit</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">source</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Observable</span><span class="o">.</span><span class="py">create</span><span class="o">(</span><span class="nv">OverflowStrategy</span><span class="o">.</span><span class="py">Unbounded</span><span class="o">)</span> <span class="o">{</span> <span class="n">sub</span> <span class="k">=&gt;</span>
    <span class="nf">producerLoop</span><span class="o">(</span><span class="n">sub</span><span class="o">)</span>
      <span class="o">.</span><span class="py">guarantee</span><span class="o">(</span><span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="s">"Producer has been completed"</span><span class="o">)))</span>
      <span class="o">.</span><span class="py">runToFuture</span><span class="o">(</span><span class="nv">sub</span><span class="o">.</span><span class="py">scheduler</span><span class="o">)</span>
  <span class="o">}</span>

<span class="nv">source</span><span class="o">.</span><span class="py">takeUntil</span><span class="o">(</span><span class="nv">Observable</span><span class="o">.</span><span class="py">unit</span><span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">250.</span><span class="n">millis</span><span class="o">)).</span><span class="py">dump</span><span class="o">(</span><span class="s">"O"</span><span class="o">)</span>

<span class="c1">// Output after execution:</span>
<span class="c1">// 0: O --&gt; 0</span>
<span class="c1">// 1: O --&gt; 1</span>
<span class="c1">// Producer has been completed</span>
<span class="c1">// 2: O completed</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Subscriber</code> has an underlying <code class="language-plaintext highlighter-rouge">Scheduler</code> which can be used to run <code class="language-plaintext highlighter-rouge">producerLoop</code> inside of <code class="language-plaintext highlighter-rouge">Observable.create</code>.
Note that the function is still pure - no side effect can be observed before the <code class="language-plaintext highlighter-rouge">Observable</code> is executed.</p>

<p><code class="language-plaintext highlighter-rouge">Task#runToFuture</code> returns a <code class="language-plaintext highlighter-rouge">CancelableFuture</code>. You can use it to return a <code class="language-plaintext highlighter-rouge">Cancelable</code> from a function, or you can just use 
<code class="language-plaintext highlighter-rouge">Cancelable.empty</code>.
The former choice will be able to cancel a <code class="language-plaintext highlighter-rouge">producerLoop</code> during <code class="language-plaintext highlighter-rouge">delayExecution(100.millis)</code> if the <code class="language-plaintext highlighter-rouge">source</code> is canceled. 
The latter will short-circuit when a <code class="language-plaintext highlighter-rouge">Stop</code> event is returned.</p>
    
      <h3 id="observablerepeatevalf--concurrent-data-structure">
        
        
          Observable.repeatEvalF + concurrent data structure <a href="#observablerepeatevalf--concurrent-data-structure" class="anchor">#</a>
        
        
      </h3>

<p>The <code class="language-plaintext highlighter-rouge">monix-catnap</code> module provides a <a href="https://monix.io/api/3.0/monix/catnap/ConcurrentQueue.html">ConcurrentQueue</a> which can be used 
with the <code class="language-plaintext highlighter-rouge">Observable.repeatEvalF</code> builder to create an <code class="language-plaintext highlighter-rouge">Observable</code> from it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.catnap.ConcurrentQueue</span>
<span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>

<span class="k">def</span> <span class="nf">feedItem</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">queue</span><span class="k">:</span> <span class="kt">ConcurrentQueue</span><span class="o">[</span><span class="kt">Task</span>, <span class="kt">A</span><span class="o">],</span> <span class="n">item</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">queue</span><span class="o">.</span><span class="py">offer</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">processStream</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">observable</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">observable</span>
    <span class="o">.</span><span class="py">mapParallelUnordered</span><span class="o">(</span><span class="mi">3</span><span class="o">)(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">completedL</span>
<span class="o">}</span>

<span class="o">{</span>
  <span class="nv">ConcurrentQueue</span><span class="o">.</span><span class="py">unbounded</span><span class="o">[</span><span class="kt">Task</span>, <span class="kt">Int</span><span class="o">]().</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">queue</span> <span class="k">=&gt;</span>
    <span class="nc">Task</span>
      <span class="o">.</span><span class="py">parZip2</span><span class="o">(</span>
        <span class="nf">feedItem</span><span class="o">(</span><span class="n">queue</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
        <span class="nf">processStream</span><span class="o">(</span><span class="nv">Observable</span><span class="o">.</span><span class="py">repeatEvalF</span><span class="o">(</span><span class="nv">queue</span><span class="o">.</span><span class="py">poll</span><span class="o">))</span>
      <span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">ConcurrentQueue</code> has a bounded variant which will back-pressure the producer if it is too fast.</p>

<p>If you’re curious as to why we have to <code class="language-plaintext highlighter-rouge">flatMap</code> in this case, <a href="https://vimeo.com/294736344">see the excellent presentation by Fabio Labella</a>.
Note that you can also create an <code class="language-plaintext highlighter-rouge">Observable</code> from the other tools for concurrency, such as <code class="language-plaintext highlighter-rouge">MVar</code> or <code class="language-plaintext highlighter-rouge">Deferred</code>.</p>
    
      <h3 id="concurrentsubject">
        
        
          ConcurrentSubject <a href="#concurrentsubject" class="anchor">#</a>
        
        
      </h3>

<p>You can use a <code class="language-plaintext highlighter-rouge">ConcurrentSubject</code> to get similar functionality:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.Ack</span>
<span class="k">import</span> <span class="nn">monix.reactive.subjects.ConcurrentSubject</span>
<span class="k">import</span> <span class="nn">monix.reactive.</span><span class="o">{</span><span class="nc">MulticastStrategy</span><span class="o">,</span> <span class="nc">Observable</span><span class="o">,</span> <span class="nc">Observer</span><span class="o">}</span>

<span class="k">val</span> <span class="nv">subject</span><span class="k">:</span> <span class="kt">ConcurrentSubject</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">ConcurrentSubject</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nv">MulticastStrategy</span><span class="o">.</span><span class="py">replay</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">feedItem</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">observer</span><span class="k">:</span> <span class="kt">Observer</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">item</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Ack</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">deferFuture</span><span class="o">(</span><span class="nv">observer</span><span class="o">.</span><span class="py">onNext</span><span class="o">(</span><span class="n">item</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">processStream</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">observable</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">observable</span>
    <span class="o">.</span><span class="py">mapParallelUnordered</span><span class="o">(</span><span class="mi">3</span><span class="o">)(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">completedL</span>
<span class="o">}</span>

<span class="o">{</span>
<span class="nc">Task</span>
  <span class="o">.</span><span class="py">parZip2</span><span class="o">(</span>
    <span class="nf">feedItem</span><span class="o">(</span><span class="n">subject</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
    <span class="nf">processStream</span><span class="o">(</span><span class="n">subject</span><span class="o">)</span>
  <span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>One important difference is that <code class="language-plaintext highlighter-rouge">subject</code> will be shared between subscribers (here it is implied in the <code class="language-plaintext highlighter-rouge">processStream</code> method).
It might not be noticeable with <code class="language-plaintext highlighter-rouge">MulticastStrategy.replay</code> which caches incoming elements. 
If we use a different strategy such as <code class="language-plaintext highlighter-rouge">MulticastStrategy.publish</code>, <code class="language-plaintext highlighter-rouge">processStream</code> won’t receive any elements which were sent before subscription.</p>

<p><a href="#subjects">More on Subjects later.</a></p>
    
      <h2 id="back-pressure-buffering-throttling">
        
        
          Back-pressure, buffering, throttling <a href="#back-pressure-buffering-throttling" class="anchor">#</a>
        
        
      </h2>

<p>The <code class="language-plaintext highlighter-rouge">Observable</code> is back-pressured, i.e. if the producer (upstream) is faster than consumer (downstream), the producer will 
wait for an <code class="language-plaintext highlighter-rouge">Ack</code> from the consumer before sending the next element. However, that’s not always desirable.
For instance, we might want to process messages in batches for better throughput, or have strict latency requirements 
which we need to fulfil even at the cost of dropping some messages. Fortunately, Monix provides a ton of operators in this space.</p>
    
      <h3 id="overflowstrategy">
        
        
          OverflowStrategy <a href="#overflowstrategy" class="anchor">#</a>
        
        
      </h3>

<p>Many operators which limit, or disable back-pressure will take an <a href="https://monix.io/api/3.0/monix/reactive/OverflowStrategy.html">OverflowStrategy</a> as a parameter.
The following are the policies available:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Unbounded</code> does not limit the size of the buffer, which means an upstream won’t ever be back-pressured. If there is a lot of traffic and the downstream is very slow, it can lead to high latencies and even out of memory errors if the buffer grows too large.</li>
  <li><code class="language-plaintext highlighter-rouge">Fail(bufferSize: Int)</code> will send an <code class="language-plaintext highlighter-rouge">onError</code> signal to downstream, ending the <code class="language-plaintext highlighter-rouge">Observable</code> if the buffer grows too large.</li>
  <li><code class="language-plaintext highlighter-rouge">Backpressure(bufferSize: Int)</code> will back-pressure an upstream if the buffer grows too large.</li>
  <li><code class="language-plaintext highlighter-rouge">DropNew(bufferSize: Int)</code> will drop incoming elements if the buffer grows too large. This version is more efficient than <code class="language-plaintext highlighter-rouge">DropOld</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">DropOld(bufferSize: Int)</code> will drop the oldest elements if the buffer grows too large.</li>
  <li><code class="language-plaintext highlighter-rouge">ClearBuffer(bufferSize: Int)</code> will clear the buffer if it grows beyond limit.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">DropNew</code>, <code class="language-plaintext highlighter-rouge">DropOld</code> and <code class="language-plaintext highlighter-rouge">ClearBuffer</code> allow to send a signal downstream if the buffer reaches its capacity.</p>
    
      <h3 id="asynchronous-processing">
        
        
          Asynchronous processing <a href="#asynchronous-processing" class="anchor">#</a>
        
        
      </h3>

<p>We can think of a back-pressured stream as synchronous processing, where the upstream waits until a particular element has been fully processed.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"C"</span><span class="o">,</span> <span class="s">"D"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">mapEval</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"1: Processing $i"</span><span class="o">);</span> <span class="n">i</span> <span class="o">++</span> <span class="n">i</span> <span class="o">})</span>
    <span class="o">.</span><span class="py">mapEval</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"2: Processing $i"</span><span class="o">)</span> <span class="o">}.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">100.</span><span class="n">millis</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">// Output when executed</span>
<span class="c1">// 1: Processing A</span>
<span class="c1">// 2: Processing AA</span>
<span class="c1">// 1: Processing B</span>
<span class="c1">// 2: Processing BB</span>
<span class="c1">// 1: Processing C</span>
<span class="c1">// 2: Processing CC</span>
<span class="c1">// 1: Processing D</span>
<span class="c1">// 2: Processing DD</span>
</code></pre></div></div>

<p>Asynchronous processing would then be a case in which the downstream acknowledges new events immediately and processes them independently.
The <code class="language-plaintext highlighter-rouge">Observable</code> provides the <code class="language-plaintext highlighter-rouge">asyncBoundary</code> method which creates a buffered asynchronous boundary. 
The buffer is configured according to the <code class="language-plaintext highlighter-rouge">OverflowStrategy</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"C"</span><span class="o">,</span> <span class="s">"D"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">mapEval</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"1: Processing $i"</span><span class="o">);</span> <span class="n">i</span> <span class="o">++</span> <span class="n">i</span> <span class="o">})</span>
    <span class="o">.</span><span class="py">asyncBoundary</span><span class="o">(</span><span class="nv">OverflowStrategy</span><span class="o">.</span><span class="py">Unbounded</span><span class="o">)</span>
    <span class="o">.</span><span class="py">mapEval</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"2: Processing $i"</span><span class="o">)</span> <span class="o">}.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">100.</span><span class="n">millis</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">// Output when executed</span>
<span class="c1">// 1: Processing A</span>
<span class="c1">// 1: Processing B</span>
<span class="c1">// 1: Processing C</span>
<span class="c1">// 1: Processing D</span>
<span class="c1">// 2: Processing AA</span>
<span class="c1">// 2: Processing BB</span>
<span class="c1">// 2: Processing CC</span>
<span class="c1">// 2: Processing DD</span>
</code></pre></div></div>

<p>In the example above, we introduced <code class="language-plaintext highlighter-rouge">asyncBoundary</code> before last <code class="language-plaintext highlighter-rouge">mapEval</code> which introduced an unbounded buffer before this operation.
From the perspective of the upstream, the downstream is always keeping up with all the elements so it can always take the next one from the source.
Anything after the <code class="language-plaintext highlighter-rouge">asyncBoundary</code> is back-pressured as usual - each <code class="language-plaintext highlighter-rouge">2: Processing XX</code> will be emitted in 100 millisecond intervals.</p>

<p>You can use another <code class="language-plaintext highlighter-rouge">OverflowStrategy</code>, e.g. <code class="language-plaintext highlighter-rouge">OverflowStrategy.BackPressure(2)</code>, which would return following output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1: Processing A
1: Processing B
1: Processing C
2: Processing AA
2: Processing BB
1: Processing D
2: Processing CC
2: Processing DD
</code></pre></div></div>

<p>When <code class="language-plaintext highlighter-rouge">AA</code> is being processed in the second stage, the source can send two more (size of the buffer) elements, 
after which, it is back-pressured until there is more space available.</p>
    
      <h3 id="processing-elements-in-batches">
        
        
          Processing elements in batches <a href="#processing-elements-in-batches" class="anchor">#</a>
        
        
      </h3>

<p>Operations like <code class="language-plaintext highlighter-rouge">asyncBoundary</code> and <code class="language-plaintext highlighter-rouge">ConcurrentSubject</code> will introduce internal buffers which we can’t access.
We can also buffer elements to process elements in batches.</p>
    
      <h4 id="buffersliding">
        
        
          bufferSliding <a href="#buffersliding" class="anchor">#</a>
        
        
      </h4>

<p><code class="language-plaintext highlighter-rouge">Observable#bufferSliding</code> emits buffers every <code class="language-plaintext highlighter-rouge">skip</code> items, each containing <code class="language-plaintext highlighter-rouge">count</code> items.
If the stream completes, it will emit an incomplete buffer downstream. 
In case of an error, it will be dropped.</p>

<p>The bundles can overlap, depending on parameters:</p>
<ul>
  <li>In case of <code class="language-plaintext highlighter-rouge">skip == count</code>, then all elements are emitted without any overlap</li>
  <li>In case of <code class="language-plaintext highlighter-rouge">skip &lt; count</code>, then buffers overlap with the number of elements repeated being <code class="language-plaintext highlighter-rouge">count - skip</code></li>
  <li>In case of <code class="language-plaintext highlighter-rouge">skip &gt; count</code>, then <code class="language-plaintext highlighter-rouge">skip - count</code> elements start getting dropped between windows</li>
</ul>

<p>Let’s take a look at an example demonstrating the case of <code class="language-plaintext highlighter-rouge">skip &gt; count</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">).</span><span class="py">bufferSliding</span><span class="o">(</span><span class="n">count</span> <span class="k">=</span> <span class="mi">2</span><span class="o">,</span> <span class="n">skip</span> <span class="k">=</span> <span class="mi">3</span><span class="o">).</span><span class="py">dump</span><span class="o">(</span><span class="s">"O"</span><span class="o">)</span>

<span class="c1">// Output when executed</span>
<span class="c1">// 0: O --&gt; WrappedArray(2, 3)</span>
<span class="c1">// 1: O --&gt; WrappedArray(5, 6)</span>
<span class="c1">// 2: O completed</span>
</code></pre></div></div>

<p><img src="/public/images/marbles/buffer-sliding-1.png" align="center" style="max-width: 100%" /></p>

<p>The element <code class="language-plaintext highlighter-rouge">4</code> has been skipped. If the situation was reversed, it would be duplicated instead:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">).</span><span class="py">bufferSliding</span><span class="o">(</span><span class="n">count</span> <span class="k">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">skip</span> <span class="k">=</span> <span class="mi">2</span><span class="o">).</span><span class="py">dump</span><span class="o">(</span><span class="s">"O"</span><span class="o">)</span>

<span class="c1">// Output when executed</span>
<span class="c1">// 0: O --&gt; WrappedArray(2, 3, 4)</span>
<span class="c1">// 1: O --&gt; WrappedArray(4, 5, 6)</span>
<span class="c1">// 2: O completed</span>
</code></pre></div></div>

<p><img src="/public/images/marbles/buffer-sliding-2.png" align="center" style="max-width: 100%" /></p>

<p>For <code class="language-plaintext highlighter-rouge">skip == count</code> scenario, take a look at the <code class="language-plaintext highlighter-rouge">bufferTumbling</code> example.</p>
    
      <h4 id="buffertumbling">
        
        
          bufferTumbling <a href="#buffertumbling" class="anchor">#</a>
        
        
      </h4>

<p><code class="language-plaintext highlighter-rouge">Observable#bufferTumbling</code> will gather elements and emit them in non-overlapping bundles of a specified <code class="language-plaintext highlighter-rouge">count</code>. 
It is essentially <code class="language-plaintext highlighter-rouge">bufferSliding</code> where <code class="language-plaintext highlighter-rouge">count</code> is equal to <code class="language-plaintext highlighter-rouge">skip</code>.
If the stream completes, it will emit an incomplete buffer downstream. 
In case of an error, it will be dropped.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bufferTumbling</span><span class="o">(</span><span class="n">count</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">).</span><span class="py">bufferTumbling</span><span class="o">(</span><span class="n">count</span> <span class="k">=</span> <span class="mi">2</span><span class="o">).</span><span class="py">dump</span><span class="o">(</span><span class="s">"O"</span><span class="o">)</span>
  
<span class="c1">// Output when executed</span>
<span class="c1">// 0: O --&gt; WrappedArray(2, 3)</span>
<span class="c1">// 1: O --&gt; WrappedArray(4, 5)</span>
<span class="c1">// 2: O --&gt; WrappedArray(6)</span>
<span class="c1">// 3: O completed</span>
</code></pre></div></div>

<p><img src="/public/images/marbles/buffer-tumbling.png" align="center" style="max-width: 100%" /></p>
    
      <h4 id="buffertimed">
        
        
          bufferTimed <a href="#buffertimed" class="anchor">#</a>
        
        
      </h4>

<p>You can also buffer elements depending on a duration, using <code class="language-plaintext highlighter-rouge">bufferTimed(timespan: FiniteDuration)</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Observable</span><span class="o">.</span><span class="py">intervalAtFixedRate</span><span class="o">(</span><span class="mf">100.</span><span class="n">millis</span><span class="o">).</span><span class="py">bufferTimed</span><span class="o">(</span><span class="n">timespan</span> <span class="k">=</span> <span class="mf">1.</span><span class="n">second</span><span class="o">).</span><span class="py">dump</span><span class="o">(</span><span class="s">"O"</span><span class="o">)</span>
  
<span class="c1">// Emits 10 elements each second when executed</span>
<span class="c1">// 0: O --&gt; List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)</span>
<span class="c1">// 1: O --&gt; List(10, 11, 12, 13, 14, 15, 16, 17, 18, 19)</span>
<span class="c1">// 2: O --&gt; List(20, 21, 22, 23, 24, 25, 26, 27, 28, 29)</span>
<span class="c1">// ...</span>
</code></pre></div></div>
    
      <h4 id="buffertimedandcounted">
        
        
          bufferTimedAndCounted <a href="#buffertimedandcounted" class="anchor">#</a>
        
        
      </h4>

<p>Using either <code class="language-plaintext highlighter-rouge">bufferTimed</code> or <code class="language-plaintext highlighter-rouge">bufferCounted</code> has its drawbacks. 
In <code class="language-plaintext highlighter-rouge">bufferTimed</code>, the buffer sizes can be very inconsistent, so you might have to wait on more elements even if we could
already be processing them, increasing latency. 
When using <code class="language-plaintext highlighter-rouge">bufferCounted</code>, there is a risk of waiting a very long time (or forever) until there are enough elements to send downstream.
If these are possible issues in an application, you could use <code class="language-plaintext highlighter-rouge">bufferTimedAndCounted</code> to do both at the same time.</p>

<p>This buffering method emits non-overlapping bundles, each of a fixed duration specified by the <code class="language-plaintext highlighter-rouge">timespan</code> argument,
or a maximum size specified by the <code class="language-plaintext highlighter-rouge">maxCount</code> argument (whichever is reached first).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="o">(</span><span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">++</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">never</span><span class="o">)</span>
    <span class="o">.</span><span class="py">bufferTimedAndCounted</span><span class="o">(</span><span class="n">timespan</span> <span class="k">=</span> <span class="mf">1.</span><span class="n">second</span><span class="o">,</span> <span class="n">maxCount</span> <span class="k">=</span> <span class="mi">2</span><span class="o">)</span>
    <span class="o">.</span><span class="py">dump</span><span class="o">(</span><span class="s">"O"</span><span class="o">)</span>
<span class="o">}</span>
  
<span class="c1">// Output when executed</span>
<span class="c1">// 0: O --&gt; List(1, 2)</span>
<span class="c1">// 1: O --&gt; List(3)</span>
<span class="c1">// 2: O --&gt; List()</span>
<span class="c1">// 3: O --&gt; List()</span>
<span class="c1">// ...</span>
</code></pre></div></div>
    
      <h4 id="bufferintrospective">
        
        
          bufferIntrospective <a href="#bufferintrospective" class="anchor">#</a>
        
        
      </h4>

<p>There are more sophisticated buffering options available and one of them is <code class="language-plaintext highlighter-rouge">bufferIntrospective(maxSize: Int)</code>.
This operator buffers elements only if the downstream is busy, otherwise it sends them as they come.
Once the buffer is full, it will back-pressure upstream.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
    <span class="o">.</span><span class="py">doOnNext</span><span class="o">(</span><span class="n">l</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Started $l"</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">bufferIntrospective</span><span class="o">(</span><span class="n">maxSize</span> <span class="k">=</span> <span class="mi">2</span><span class="o">)</span>
    <span class="o">.</span><span class="py">doOnNext</span><span class="o">(</span><span class="n">l</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Emitted batch $l"</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">mapEval</span><span class="o">(</span><span class="n">l</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Processed batch $l"</span><span class="o">)).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">500.</span><span class="n">millis</span><span class="o">))</span>
<span class="o">}</span>
  
<span class="c1">// Output when executed</span>
<span class="c1">// Started 1</span>
<span class="c1">// Emitted batch List(1)</span>
<span class="c1">// Started 2</span>
<span class="c1">// Started 3</span>
<span class="c1">// Processed batch List(1)</span>
<span class="c1">// Emitted batch List(2, 3)</span>
<span class="c1">// Started 4</span>
<span class="c1">// Started 5</span>
<span class="c1">// Processed batch List(2, 3)</span>
<span class="c1">// Emitted batch List(4, 5)</span>
<span class="c1">// Processed batch List(4, 5)</span>
</code></pre></div></div>

<p>The example is a quite involved one so let’s break it down:</p>
<ul>
  <li>Element <code class="language-plaintext highlighter-rouge">1</code> can be started immediately and since the downstream is free, it is passed until the end</li>
  <li>There is a free space in the buffer, so elements <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">3</code> can be started</li>
  <li>Now, the buffer is filled-up, so the upstream is back-pressured</li>
  <li>Once the first batch has been processed, <code class="language-plaintext highlighter-rouge">bufferIntrospective</code> can send a new one</li>
  <li>There is a space in the buffer again so <code class="language-plaintext highlighter-rouge">4</code> and <code class="language-plaintext highlighter-rouge">5</code> can start, and they will be emitted when the current batch has been processed</li>
</ul>
    
      <h4 id="bufferwithselector">
        
        
          bufferWithSelector <a href="#bufferwithselector" class="anchor">#</a>
        
        
      </h4>

<p>Next sophisticated buffering operator is <code class="language-plaintext highlighter-rouge">bufferWithSelector(selector, maxSize)</code>. 
It takes a selector <code class="language-plaintext highlighter-rouge">Observable</code> and emits a new buffer whenever it emits an element. 
The second parameter, <code class="language-plaintext highlighter-rouge">maxSize</code> determines the maximum size of the buffer - if it is exceeded, the upstream will be back-pressured.
Any size below 1 will use an unbounded buffer.</p>

<p>Let’s take a look at an example similar to the one with <code class="language-plaintext highlighter-rouge">bufferIntrospective</code> but this time it will emit elements every 100 milliseconds.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
    <span class="o">.</span><span class="py">doOnNext</span><span class="o">(</span><span class="n">l</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Started $l"</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">bufferWithSelector</span><span class="o">(</span><span class="n">selector</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">intervalAtFixedRate</span><span class="o">(</span><span class="n">initialDelay</span> <span class="k">=</span> <span class="mf">100.</span><span class="n">millis</span><span class="o">,</span> <span class="n">period</span> <span class="k">=</span> <span class="mf">100.</span><span class="n">millis</span><span class="o">),</span> <span class="n">maxSize</span> <span class="k">=</span> <span class="mi">2</span><span class="o">)</span>
    <span class="o">.</span><span class="py">doOnNext</span><span class="o">(</span><span class="n">l</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Emitted batch $l"</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">mapEval</span><span class="o">(</span><span class="n">l</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Processed batch $l"</span><span class="o">)).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">500.</span><span class="n">millis</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">// Output when executed</span>
<span class="c1">// Started 1</span>
<span class="c1">// Started 2</span>
<span class="c1">// Started 3</span>
<span class="c1">// Emitted batch List(1, 2)</span>
<span class="c1">// Started 4</span>
<span class="c1">// Processed batch List(1, 2)</span>
<span class="c1">// Emitted batch List(3, 4)</span>
<span class="c1">// Started 5</span>
<span class="c1">// Processed batch List(3, 4)</span>
<span class="c1">// Emitted batch List(5)</span>
<span class="c1">// Processed batch List(5)</span>
</code></pre></div></div>

<p>The output can be a bit confusing because it suggests that element <code class="language-plaintext highlighter-rouge">3</code> has been started before emitting the first batch.
In reality, it was back-pressured as expected but emitting a batch downstream and acknowledging upstream is a concurrent operation, so
it could happen before the “Emitted batch …” print-out.</p>

<p>Since <code class="language-plaintext highlighter-rouge">bufferWithSelector</code> takes an <code class="language-plaintext highlighter-rouge">Observable</code>, it can be used to customize buffering to a pretty great extent.
For instance, we could use <a href="https://typelevel.org/cats-effect/concurrency/mvar.md">MVar</a> or <a href="https://typelevel.org/cats-effect/concurrency/semaphore.html">Semaphore</a> to
buffer messages until we receive a signal from a different part of the application.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bufferUntilSignalled</span><span class="o">(</span><span class="n">mvar</span><span class="k">:</span> <span class="kt">MVar</span><span class="o">[</span><span class="kt">Task</span>, <span class="kt">Unit</span><span class="o">])</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Long</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10000</span><span class="o">)</span>
    <span class="o">.</span><span class="py">bufferWithSelector</span><span class="o">(</span><span class="nv">Observable</span><span class="o">.</span><span class="py">repeatEvalF</span><span class="o">(</span><span class="nv">mvar</span><span class="o">.</span><span class="py">take</span><span class="o">))</span>
    <span class="c1">// do something with buffers</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">program</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">mvar</span> <span class="k">&lt;-</span> <span class="nv">MVar</span><span class="o">.</span><span class="py">empty</span><span class="o">[</span><span class="kt">Task</span>, <span class="kt">Unit</span><span class="o">]</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nf">bufferUntilSignalled</span><span class="o">(</span><span class="n">mvar</span><span class="o">).</span><span class="py">completedL</span><span class="o">.</span><span class="py">startAndForget</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nv">mvar</span><span class="o">.</span><span class="py">put</span><span class="o">(())</span> <span class="c1">// signal buffer to be sent</span>
<span class="o">}</span> <span class="nf">yield</span> <span class="o">()</span>
</code></pre></div></div>
    
      <h4 id="buffertimedwithpressure">
        
        
          bufferTimedWithPressure <a href="#buffertimedwithpressure" class="anchor">#</a>
        
        
      </h4>

<p><code class="language-plaintext highlighter-rouge">Observable#bufferTimedWithPressure</code> is similar to <code class="language-plaintext highlighter-rouge">bufferTimedAndCounted</code> but it applies back-pressure if the buffer is full,
instead of emitting it. Another difference is that it allows to pass a function to calculate the weight of an element.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Elem</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">A</span> <span class="k">extends</span> <span class="nc">Elem</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">B</span> <span class="k">extends</span> <span class="nc">Elem</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">C</span> <span class="k">extends</span> <span class="nc">Elem</span>

<span class="k">val</span> <span class="nv">sizeOf</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="mi">1</span>
  <span class="k">case</span> <span class="n">B</span> <span class="k">=&gt;</span> <span class="mi">2</span>
  <span class="k">case</span> <span class="n">C</span> <span class="k">=&gt;</span> <span class="mi">3</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">,</span> <span class="n">C</span><span class="o">,</span> <span class="n">C</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">)</span>
    <span class="o">.</span><span class="py">bufferTimedWithPressure</span><span class="o">(</span><span class="n">period</span> <span class="k">=</span> <span class="mf">1.</span><span class="n">second</span><span class="o">,</span> <span class="n">maxSize</span> <span class="k">=</span> <span class="mi">3</span><span class="o">,</span> <span class="n">sizeOf</span> <span class="k">=</span> <span class="n">sizeOf</span><span class="o">)</span>
    <span class="o">.</span><span class="py">dump</span><span class="o">(</span><span class="s">"O"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Output when executed</span>
<span class="c1">// 0: O --&gt; List(A, B)</span>
<span class="c1">// 1: O --&gt; List(C)</span>
<span class="c1">// 2: O --&gt; List(C)</span>
<span class="c1">// 3: O --&gt; List(A, B)</span>
<span class="c1">// 4: O completed</span>
</code></pre></div></div>
    
      <h3 id="limiting-the-rate-of-emission-of-elements">
        
        
          Limiting the rate of emission of elements <a href="#limiting-the-rate-of-emission-of-elements" class="anchor">#</a>
        
        
      </h3>

<p>The following subsection covers some of the operators that can help with limiting the rate and/or filtering of incoming events.
As usual, there is more information in the API and if you’re missing something familiar from ReactiveX then it is most likely an easy addition - so do not hesitate to open an issue.</p>
    
      <h4 id="throttle">
        
        
          throttle <a href="#throttle" class="anchor">#</a>
        
        
      </h4>

<p>The purpose of <code class="language-plaintext highlighter-rouge">throttle(period, n)</code> is to control the rate of events emitted downstream.
The operator will buffer incoming events up to <code class="language-plaintext highlighter-rouge">n</code> and emit them each <code class="language-plaintext highlighter-rouge">period</code> as individual elements.
Once the internal buffer is filled, it will back-pressure the upstream.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Emits 1 element per 1 second</span>
<span class="nv">Observable</span><span class="o">.</span><span class="py">fromIterable</span><span class="o">(</span><span class="mi">0</span> <span class="n">to</span> <span class="mi">10</span><span class="o">).</span><span class="py">throttle</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div></div>

<p>An important difference from the other throttling operators is that <code class="language-plaintext highlighter-rouge">throttle</code> does not skip any elements.</p>
    
      <h4 id="throttlefirst">
        
        
          throttleFirst <a href="#throttlefirst" class="anchor">#</a>
        
        
      </h4>

<p><code class="language-plaintext highlighter-rouge">Observable#throttleFirst(interval)</code> emits only the first item from the source in specified intervals.
Other elements will be dropped. The most classic use case of this operator is to avoid multiple clicks on the same button
in user-facing features.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">Observable</span><span class="o">.</span><span class="py">fromIterable</span><span class="o">(</span><span class="mi">0</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span>
    <span class="o">.</span><span class="py">delayOnNext</span><span class="o">(</span><span class="mf">200.</span><span class="n">millis</span><span class="o">)</span>
    <span class="o">.</span><span class="py">throttleFirst</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
    <span class="o">.</span><span class="py">dump</span><span class="o">(</span><span class="s">"O"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Emits in 1 second intervals:</span>
<span class="c1">// 0: O --&gt; 0</span>
<span class="c1">// 1: O --&gt; 5</span>
<span class="c1">// 2: O --&gt; 10</span>
<span class="c1">// 3: O completed</span>
</code></pre></div></div>
    
      <h4 id="throttlelast-sample">
        
        
          throttleLast (sample) <a href="#throttlelast-sample" class="anchor">#</a>
        
        
      </h4>

<p><code class="language-plaintext highlighter-rouge">throttleLast</code> (aliased to <code class="language-plaintext highlighter-rouge">sample</code>) is similar to <code class="language-plaintext highlighter-rouge">throttleFirst</code> but it always emits the most recent (last one) element in the window.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">Observable</span><span class="o">.</span><span class="py">fromIterable</span><span class="o">(</span><span class="mi">0</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span>
    <span class="o">.</span><span class="py">delayOnNext</span><span class="o">(</span><span class="mf">200.</span><span class="n">millis</span><span class="o">)</span>
    <span class="o">.</span><span class="py">throttleLast</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
    <span class="o">.</span><span class="py">dump</span><span class="o">(</span><span class="s">"O"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Emits in 1 second intervals:</span>
<span class="c1">// 0: O --&gt; 3</span>
<span class="c1">// 1: O --&gt; 8</span>
<span class="c1">// 2: O --&gt; 10</span>
<span class="c1">// 3: O completed</span>
</code></pre></div></div>
    
      <h4 id="throttlewithtimeout-debounce">
        
        
          throttleWithTimeout (debounce) <a href="#throttlewithtimeout-debounce" class="anchor">#</a>
        
        
      </h4>

<p><code class="language-plaintext highlighter-rouge">throttleWithTimeout</code> (aliased to <code class="language-plaintext highlighter-rouge">debounce</code>) will drop any events that were emitted in a short succession.
An event will be passed to downstream only after a given <code class="language-plaintext highlighter-rouge">timeout</code> passes. Each event resets the timer, even if it is dropped.
The operator will wait until it is “calm” and then emit the latest event.
This behavior is different from <code class="language-plaintext highlighter-rouge">throttleFirst</code> and <code class="language-plaintext highlighter-rouge">throttleLast</code> where the time window was static.</p>

<p>This operator is well-suited for situations like a search query - it can be quite expensive for the downstream to process<br />
each key entered by a user, so instead we could wait until the user stopped typing before we send the events.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="o">(</span><span class="nc">Observable</span><span class="o">(</span><span class="s">"M"</span><span class="o">,</span> <span class="s">"O"</span><span class="o">,</span> <span class="s">"N"</span><span class="o">,</span> <span class="s">"I"</span><span class="o">,</span> <span class="s">"X"</span><span class="o">)</span> <span class="o">++</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">never</span><span class="o">)</span>
    <span class="o">.</span><span class="py">delayOnNext</span><span class="o">(</span><span class="mf">100.</span><span class="n">millis</span><span class="o">)</span>
    <span class="o">.</span><span class="py">scan</span><span class="o">(</span><span class="s">""</span><span class="o">)(</span><span class="k">_</span> <span class="o">++</span> <span class="k">_</span><span class="o">)</span>
    <span class="o">.</span><span class="py">debounce</span><span class="o">(</span><span class="mf">200.</span><span class="n">millis</span><span class="o">)</span>
    <span class="o">.</span><span class="py">dump</span><span class="o">(</span><span class="s">"O"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Output:</span>
<span class="c1">// 0: O --&gt; MONIX</span>
</code></pre></div></div>

<p>Note that if the source emits elements too fast and ends, all elements will be skipped, as presented in the next example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">Observable</span><span class="o">.</span><span class="py">fromIterable</span><span class="o">(</span><span class="mi">0</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span>
    <span class="o">.</span><span class="py">delayOnNext</span><span class="o">(</span><span class="mf">200.</span><span class="n">millis</span><span class="o">)</span>
    <span class="o">.</span><span class="py">throttleWithTimeout</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
    <span class="o">.</span><span class="py">dump</span><span class="o">(</span><span class="s">"O"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Output after execution</span>
<span class="c1">// 0: O completed</span>
</code></pre></div></div>
    
      <h2 id="transforming-observables">
        
        
          Transforming Observables <a href="#transforming-observables" class="anchor">#</a>
        
        
      </h2>
    
      <h3 id="map">
        
        
          map <a href="#map" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable#map</code> applies a function <code class="language-plaintext highlighter-rouge">f</code> to all elements in the source stream.</p>

<p><img src="/public/images/marbles/map.png" align="center" style="max-width: 100%" /></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Scheduler</span>
<span class="k">import</span> <span class="nn">monix.execution.exceptions.DummyException</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>

<span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span> 
  <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
    <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">el</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"new elem: $el"</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">stream</span><span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">).</span><span class="py">runToFuture</span>

<span class="c1">// new elem: 1</span>
<span class="c1">// new elem: 2</span>
<span class="c1">// new elem: 3</span>
<span class="c1">// new elem: 4</span>
</code></pre></div></div>

<p>Prefer to use functions that are total because any exception will terminate the stream (see <a href="#error-handling">Error Handling</a> section) :</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">failed</span> <span class="k">=</span> <span class="o">{</span> 
  <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
    <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="nc">DummyException</span><span class="o">(</span><span class="s">"avoid it!"</span><span class="o">))</span>
<span class="o">}</span>

<span class="nv">failed</span><span class="o">.</span><span class="py">subscribe</span><span class="o">()</span>

<span class="c1">// monix.execution.exceptions.DummyException: avoid it!</span>
<span class="c1">//	at MapObservable$.$anonfun$failedStream$1(MapObservable.scala:14)</span>
<span class="c1">//	at MapObservable$.$anonfun$failedStream$1$adapted(MapObservable.scala:14)</span>
<span class="c1">//	at monix.reactive.internal.operators.MapOperator$$anon$1.onNext(MapOperator.scala:41)</span>
</code></pre></div></div>
    
      <h3 id="mapeval">
        
        
          mapEval <a href="#mapeval" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable#mapEval</code> is similar to <code class="language-plaintext highlighter-rouge">map</code> but it takes a <code class="language-plaintext highlighter-rouge">f: A =&gt; Task[B]</code> which represents a function with an effectful result that can produce at most one value.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">).</span><span class="py">mapEval</span><span class="o">(</span><span class="n">l</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">evalAsync</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$l: run asynchronously"</span><span class="o">)))</span>

<span class="nv">stream</span><span class="o">.</span><span class="py">subscribe</span><span class="o">()</span>

<span class="c1">// 1: run asynchronously</span>
<span class="c1">// 2: run asynchronously</span>
<span class="c1">// 3: run asynchronously</span>
<span class="c1">// 4: run asynchronously</span>
</code></pre></div></div>

<p>There is also a <code class="language-plaintext highlighter-rouge">mapEvalF</code> variant for other types which can be converted to a <code class="language-plaintext highlighter-rouge">Task</code>, i.e. <code class="language-plaintext highlighter-rouge">Future</code>, <code class="language-plaintext highlighter-rouge">cats.effect.IO</code>, <code class="language-plaintext highlighter-rouge">ZIO</code> etc.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.Future</span>

<span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">).</span><span class="py">mapEvalF</span><span class="o">(</span><span class="n">l</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$l: run asynchronously"</span><span class="o">)))</span>

<span class="nv">stream</span><span class="o">.</span><span class="py">subscribe</span><span class="o">()</span>

<span class="c1">// 1: run asynchronously</span>
<span class="c1">// 2: run asynchronously</span>
<span class="c1">// 3: run asynchronously</span>
<span class="c1">// 4: run asynchronously</span>
</code></pre></div></div>
    
      <h3 id="mapparallel">
        
        
          mapParallel <a href="#mapparallel" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">mapEval</code> can process elements asynchronously but does it one-by-one. 
In case we would like to run <code class="language-plaintext highlighter-rouge">n</code> tasks in parallel, we can use either <code class="language-plaintext highlighter-rouge">mapParallelOrdered</code> or <code class="language-plaintext highlighter-rouge">mapParallelUnordered</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span>
    <span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
    <span class="o">.</span><span class="py">mapParallelOrdered</span><span class="o">(</span><span class="n">parallelism</span> <span class="k">=</span> <span class="mi">2</span><span class="o">)(</span><span class="n">i</span> <span class="k">=&gt;</span>
      <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i: start asynchronously"</span><span class="o">))</span>
        <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nv">Task</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">4.</span><span class="n">second</span><span class="o">)</span> <span class="k">else</span> <span class="nv">Task</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">))</span>
        <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">i</span><span class="o">)</span>
    <span class="o">).</span><span class="py">foreachL</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i: done"</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">// 2: start asynchronously</span>
<span class="c1">// 1: start asynchronously</span>
<span class="c1">// 1: done</span>
<span class="c1">// 3: start asynchronously</span>
<span class="c1">// 2: done</span>
<span class="c1">// 3: done</span>
<span class="c1">// 4: start asynchronously</span>
<span class="c1">// 4: done</span>
</code></pre></div></div>

<p>The order of execution of <code class="language-plaintext highlighter-rouge">Tasks</code> inside <code class="language-plaintext highlighter-rouge">mapParallelOrdered</code> is nondeterministic, but they will always be passed to the downstream in the FIFO order, i.e. all <code class="language-plaintext highlighter-rouge">done</code> prints will have increasing indices in this example.
In case we don’t need this guarantee, we can use <code class="language-plaintext highlighter-rouge">mapParallelUnordered</code> which is faster. The code above would result in the following output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2: start asynchronously
1: start asynchronously
1: done
3: start asynchronously
3: done
4: start asynchronously
2: done
4: done
</code></pre></div></div>
    
      <h3 id="flatmap-concatmap">
        
        
          flatMap (concatMap) <a href="#flatmap-concatmap" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable#flatMap</code> (aliased to <code class="language-plaintext highlighter-rouge">concatMap</code>) applies a function which returns an <code class="language-plaintext highlighter-rouge">Observable</code>. 
For each input element, the resulting <code class="language-plaintext highlighter-rouge">Observable</code> is processed before the next input element.</p>

<p><img src="/public/images/marbles/flat-map.png" align="center" style="max-width: 100%" /></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
    <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Observable</span><span class="o">(</span><span class="n">s</span><span class="s">"${i}A"</span><span class="o">,</span> <span class="n">s</span><span class="s">"${i}B"</span><span class="o">))</span>
    <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// 2A</span>
<span class="c1">// 2B</span>
<span class="c1">// 3A</span>
<span class="c1">// 3B</span>
<span class="c1">// 4A</span>
<span class="c1">// 4B</span>
</code></pre></div></div>

<p>Note that if a function returns an infinite <code class="language-plaintext highlighter-rouge">Observable</code>, it will never process the next elements from the source:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
    <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">never</span> <span class="k">else</span> <span class="nc">Observable</span><span class="o">(</span><span class="n">s</span><span class="s">"${i}A"</span><span class="o">,</span> <span class="n">s</span><span class="s">"${i}B"</span><span class="o">))</span>
    <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Nothing is printed</span>
</code></pre></div></div>
    
      <h3 id="mergemap">
        
        
          mergeMap <a href="#mergemap" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable#mergeMap</code> takes a function which can return an <code class="language-plaintext highlighter-rouge">Observable</code> but it can process the source <em>concurrently</em>. It doesn’t back-pressure on elements
from the source and subscribes to all of the <code class="language-plaintext highlighter-rouge">Observable</code>s produced from the source until they terminate. These produced <code class="language-plaintext highlighter-rouge">Observable</code>s are often called <em>inner</em> or <em>child</em>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">++</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">50.</span><span class="n">millis</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">source</span>
    <span class="o">.</span><span class="py">mergeMap</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Observable</span><span class="o">(</span><span class="n">s</span><span class="s">"${i}A"</span><span class="o">,</span> <span class="n">s</span><span class="s">"${i}B"</span><span class="o">).</span><span class="py">delayOnNext</span><span class="o">(</span><span class="mf">50.</span><span class="n">millis</span><span class="o">))</span>
    <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The possible result of the snippet above is depicted in the following picture:</p>

<p><img src="/public/images/marbles/merge-map.png" align="center" style="max-width: 100%" /></p>

<p>Since the inner <code class="language-plaintext highlighter-rouge">Observables</code> are executed concurrently, we can also return an <code class="language-plaintext highlighter-rouge">Observable</code> which takes a very long time or does not terminate at all without slowing down the entire stream.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
    <span class="o">.</span><span class="py">mergeMap</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">never</span> <span class="k">else</span> <span class="nc">Observable</span><span class="o">(</span><span class="n">s</span><span class="s">"${i}A"</span><span class="o">,</span> <span class="n">s</span><span class="s">"${i}B"</span><span class="o">))</span>
    <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// 3A</span>
<span class="c1">// 3B</span>
<span class="c1">// 4A</span>
<span class="c1">// 4B</span>
</code></pre></div></div>

<p>Keep in mind that <code class="language-plaintext highlighter-rouge">mergeMap</code> keeps all active subscriptions so it is possible to end up with a memory leak if we forget to close the infinite <code class="language-plaintext highlighter-rouge">Observable</code>.
In case one of the <code class="language-plaintext highlighter-rouge">Observable</code>s returns an error, other active streams will be canceled and resulting <code class="language-plaintext highlighter-rouge">Observable</code> will return the original error:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
    <span class="o">.</span><span class="py">mergeMap</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span>
      <span class="nf">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="nc">DummyException</span><span class="o">(</span><span class="s">"fail"</span><span class="o">))</span>
      <span class="k">else</span> <span class="nc">Observable</span><span class="o">(</span><span class="n">s</span><span class="s">"${i}A"</span><span class="o">,</span> <span class="n">s</span><span class="s">"${i}B"</span><span class="o">).</span><span class="py">doOnSubscriptionCancel</span><span class="o">(</span><span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i: cancelled"</span><span class="o">)))</span>
    <span class="o">)</span>
    <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// 2A</span>
<span class="c1">// 2B</span>
<span class="c1">// 4: cancelled</span>
<span class="c1">// Exception in thread "main" monix.execution.exceptions.DummyException: fail</span>
</code></pre></div></div>
    
      <h3 id="switchmap">
        
        
          switchMap <a href="#switchmap" class="anchor">#</a>
        
        
      </h3>
<p>Similar to <code class="language-plaintext highlighter-rouge">mergeMap</code>, <code class="language-plaintext highlighter-rouge">Observable#switchMap</code> does not back-pressure on elements from the source stream but instead <em>switches</em> to the first <code class="language-plaintext highlighter-rouge">Observable</code> returned by the provided function that will produce an element. It then cancels the other inner streams so there is only one active subscription at the time. It is safer than <code class="language-plaintext highlighter-rouge">mergeMap</code> in a way because there is no danger of a memory leak - although, it interrupts ongoing requests if something new arrives.</p>

<p><img src="/public/images/marbles/switch-map.png" align="center" style="max-width: 100%" /></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.ExitCase</span>

<span class="k">def</span> <span class="nf">child</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="n">s</span><span class="s">"${i}A"</span><span class="o">,</span> <span class="n">s</span><span class="s">"${i}B"</span><span class="o">,</span> <span class="n">s</span><span class="s">"${i}C"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">delayOnNext</span><span class="o">(</span><span class="mf">50.</span><span class="n">millis</span><span class="o">)</span>
    <span class="o">.</span><span class="py">guaranteeCase</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nv">ExitCase</span><span class="o">.</span><span class="py">Completed</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i: Request has been completed."</span><span class="o">))</span>
      <span class="k">case</span> <span class="nv">ExitCase</span><span class="o">.</span><span class="py">Error</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i: Request has encountered an error."</span><span class="o">))</span>
      <span class="k">case</span> <span class="nv">ExitCase</span><span class="o">.</span><span class="py">Canceled</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$i: Request has been canceled."</span><span class="o">))</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
    <span class="o">.</span><span class="py">delayOnNext</span><span class="o">(</span><span class="mf">100.</span><span class="n">millis</span><span class="o">)</span>
    <span class="o">.</span><span class="py">switchMap</span><span class="o">(</span><span class="n">child</span><span class="o">)</span>
    <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// 2A</span>
<span class="c1">// 2: Request has been canceled.</span>
<span class="c1">// 3A</span>
<span class="c1">// 3B</span>
<span class="c1">// 3: Request has been canceled.</span>
<span class="c1">// 4A</span>
<span class="c1">// 4B</span>
<span class="c1">// 4C</span>
<span class="c1">// 4: Request has been completed.</span>
</code></pre></div></div>
    
      <h3 id="summary">
        
        
          Summary <a href="#summary" class="anchor">#</a>
        
        
      </h3>

<p>If you want to back-pressure a source <code class="language-plaintext highlighter-rouge">Observable</code> when emitting new events, use:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">map</code> for pure, synchronous functions which return only one value</li>
  <li><code class="language-plaintext highlighter-rouge">mapEval</code> or <code class="language-plaintext highlighter-rouge">mapParallel</code> for effectful, possibly asynchronous functions which return up to one value</li>
  <li><code class="language-plaintext highlighter-rouge">flatMap</code> for effectful, possibly asynchronous functions which return a stream of values</li>
</ul>

<p>If you want to process source <code class="language-plaintext highlighter-rouge">Observable</code>s concurrently, use:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">mergeMap</code> if you want to process all inner streams</li>
  <li><code class="language-plaintext highlighter-rouge">switchMap</code> if you want to keep only the most recent inner stream</li>
</ul>
    
      <h2 id="scheduling">
        
        
          Scheduling <a href="#scheduling" class="anchor">#</a>
        
        
      </h2>

<p><code class="language-plaintext highlighter-rouge">Observable</code> is a great fit not only for streaming data but also for control flow such as scheduling. 
It provides several builders for this purpose and is quite easy to combine with <code class="language-plaintext highlighter-rouge">Task</code> if all you want is to
run a <code class="language-plaintext highlighter-rouge">Task</code> in specific intervals.</p>
    
      <h3 id="intervalwithfixeddelay-interval">
        
        
          intervalWithFixedDelay (interval) <a href="#intervalwithfixeddelay-interval" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable.intervalWithFixedDelay</code> takes a <code class="language-plaintext highlighter-rouge">delay</code> and an optional <code class="language-plaintext highlighter-rouge">initialDelay</code>. It creates an <code class="language-plaintext highlighter-rouge">Observable</code> that
emits auto-incremented natural numbers (<code class="language-plaintext highlighter-rouge">Long</code>s) spaced by a given time interval. It starts from 0 with an <code class="language-plaintext highlighter-rouge">initialDelay</code> (or immediately), 
after which it emits incremented numbers spaced by the <code class="language-plaintext highlighter-rouge">delay</code> of time. The given <code class="language-plaintext highlighter-rouge">delay</code> of time acts as a fixed 
delay between successive events.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.schedulers.TestScheduler</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>

<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="c1">// using `TestScheduler` to manipulate time</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">sc</span> <span class="k">=</span> <span class="nc">TestScheduler</span><span class="o">()</span>

<span class="k">val</span> <span class="nv">stream</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span>
    <span class="o">.</span><span class="py">intervalWithFixedDelay</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span>
    <span class="o">.</span><span class="py">mapEval</span><span class="o">(</span><span class="n">l</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">l</span><span class="o">))</span>
    <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">stream</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">(</span><span class="n">sc</span><span class="o">)</span>

<span class="nv">sc</span><span class="o">.</span><span class="py">tick</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span> <span class="c1">// prints 0</span>
<span class="nv">sc</span><span class="o">.</span><span class="py">tick</span><span class="o">(</span><span class="mf">4.</span><span class="n">second</span><span class="o">)</span> <span class="c1">// prints 1</span>
<span class="nv">sc</span><span class="o">.</span><span class="py">tick</span><span class="o">(</span><span class="mf">4.</span><span class="n">second</span><span class="o">)</span> <span class="c1">// prints 2</span>
<span class="nv">sc</span><span class="o">.</span><span class="py">tick</span><span class="o">(</span><span class="mf">4.</span><span class="n">second</span><span class="o">)</span> <span class="c1">// prints 3</span>
</code></pre></div></div>
    
      <h3 id="intervalatfixedrate">
        
        
          intervalAtFixedRate <a href="#intervalatfixedrate" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable.intervalAtFixedRate</code> is similar to <code class="language-plaintext highlighter-rouge">Observable.intervalWithFixedDelay</code>, but the time it takes to
process an <code class="language-plaintext highlighter-rouge">onNext</code> event gets deducted from the specified <code class="language-plaintext highlighter-rouge">period</code>. In other words, the created <code class="language-plaintext highlighter-rouge">Observable</code>
tries to emit events spaced by the given time interval, regardless of how long the processing of <code class="language-plaintext highlighter-rouge">onNext</code> takes.</p>

<p>The difference should be clearer after looking at the example below. 
Notice how it makes up for time spent in each <code class="language-plaintext highlighter-rouge">mapEval</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.schedulers.TestScheduler</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>

<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="c1">// using `TestScheduler` to manipulate time</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">sc</span> <span class="k">=</span> <span class="nc">TestScheduler</span><span class="o">()</span>

<span class="k">val</span> <span class="nv">stream</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span>
    <span class="o">.</span><span class="py">intervalAtFixedRate</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span>
    <span class="o">.</span><span class="py">mapEval</span><span class="o">(</span><span class="n">l</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">sleep</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">l</span><span class="o">))</span>
    <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">stream</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">(</span><span class="n">sc</span><span class="o">)</span>

<span class="nv">sc</span><span class="o">.</span><span class="py">tick</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span> <span class="c1">// prints 0</span>
<span class="nv">sc</span><span class="o">.</span><span class="py">tick</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span> <span class="c1">// prints 1</span>
<span class="nv">sc</span><span class="o">.</span><span class="py">tick</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span> <span class="c1">// prints 2</span>
<span class="nv">sc</span><span class="o">.</span><span class="py">tick</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span> <span class="c1">// prints 3</span>
</code></pre></div></div>
    
      <h2 id="error-handling">
        
        
          Error Handling <a href="#error-handling" class="anchor">#</a>
        
        
      </h2>

<p>Failing in any operator in an <code class="language-plaintext highlighter-rouge">Observable</code> will lead to the termination of the stream. It will inform the downstream and the upstream
about the failure, stopping the entire <code class="language-plaintext highlighter-rouge">Observable</code> chain - unless the error is handled.</p>

<p>Note that most errors should be handled at the <code class="language-plaintext highlighter-rouge">Effect</code> level (e.g. <code class="language-plaintext highlighter-rouge">Task</code>, <code class="language-plaintext highlighter-rouge">IO</code> in <code class="language-plaintext highlighter-rouge">mapEval</code>), and not by using <code class="language-plaintext highlighter-rouge">Observable</code> error handling operators. 
If the <code class="language-plaintext highlighter-rouge">Observable</code> encounters an error, it cannot ignore and keep going. The best you can do (without using some bigger machinery) is to restart the <code class="language-plaintext highlighter-rouge">Observable</code> or replace it with different one.</p>
    
      <h3 id="handleerror-onerrorhandle">
        
        
          handleError (onErrorHandle) <a href="#handleerror-onerrorhandle" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable.handleError</code> (alias for <code class="language-plaintext highlighter-rouge">onErrorHandle</code>) mirrors the original source unless an error happens - in which case it falls back to an <code class="language-plaintext highlighter-rouge">Observable</code> emitting one specific element generated by given total function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.reactive.Observable</span>

<span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">++</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">)</span> <span class="o">++</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="o">{</span>
<span class="n">observable</span>
  <span class="o">.</span><span class="py">onErrorHandle</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="mi">4</span><span class="o">)</span>
  <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">//=&gt; 1</span>
<span class="c1">//=&gt; 2</span>
<span class="c1">//=&gt; 3</span>
<span class="c1">//=&gt; 4</span>
</code></pre></div></div>
    
      <h3 id="handleerrorwith-onerrorhandlewith">
        
        
          handleErrorWith (onErrorHandleWith) <a href="#handleerrorwith-onerrorhandlewith" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable.handleErrorWith</code> (alias for <code class="language-plaintext highlighter-rouge">onErrorHandleWith</code>) mirrors the original source unless an error happens - in which case it falls back to an <code class="language-plaintext highlighter-rouge">Observable</code> generated by the given total function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.reactive.Observable</span>

<span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">++</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">)</span> <span class="o">++</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="o">{</span>
<span class="n">observable</span>
  <span class="o">.</span><span class="py">onErrorHandleWith</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">))</span>
  <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">//=&gt; 1</span>
<span class="c1">//=&gt; 2</span>
<span class="c1">//=&gt; 3</span>
<span class="c1">//=&gt; 4</span>
</code></pre></div></div>
    
      <h3 id="recover-onerrorrecover">
        
        
          recover (onErrorRecover) <a href="#recover-onerrorrecover" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable.recover</code> (alias for <code class="language-plaintext highlighter-rouge">onErrorRecover</code>) mirrors the original source unless an error happens - in which case it falls back to an <code class="language-plaintext highlighter-rouge">Observable</code> emitting one specified element generated by given partial function. The difference between <code class="language-plaintext highlighter-rouge">recover</code> and <code class="language-plaintext highlighter-rouge">handleError</code> is that the latter takes a total function as a parameter.</p>
    
      <h3 id="recoverwith-onerrorrecoverwith">
        
        
          recoverWith (onErrorRecoverWith) <a href="#recoverwith-onerrorrecoverwith" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable.recoverWith</code> (alias for <code class="language-plaintext highlighter-rouge">onErrorRecoverWith</code>) mirrors the original source unless an error happens - in which case it falls back to an <code class="language-plaintext highlighter-rouge">Observable</code> generated by the given partial function. The difference between <code class="language-plaintext highlighter-rouge">recoverWith</code> and <code class="language-plaintext highlighter-rouge">handleErrorWith</code> is that the latter takes a total function as a parameter.</p>
    
      <h3 id="onerrorfallbackto">
        
        
          onErrorFallbackTo <a href="#onerrorfallbackto" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable.onErrorFallbackTo</code> mirrors the behavior of the source, unless it is terminated with an <code class="language-plaintext highlighter-rouge">onError</code>, in which case the streaming of events continues with the specified backup sequence regardless of the error.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.reactive.Observable</span>

<span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">++</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">)</span> <span class="o">++</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="o">{</span>
<span class="n">observable</span>
  <span class="o">.</span><span class="py">onErrorFallbackTo</span><span class="o">(</span><span class="nc">Observable</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">))</span>
  <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">//=&gt; 1</span>
<span class="c1">//=&gt; 2</span>
<span class="c1">//=&gt; 3</span>
<span class="c1">//=&gt; 4</span>
</code></pre></div></div>

<p>This is equivalent to:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>
<span class="n">observable</span>
  <span class="o">.</span><span class="py">handleErrorWith</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>
    
      <h3 id="onerrorrestart">
        
        
          onErrorRestart <a href="#onerrorrestart" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable.onErrorRestart</code> mirrors the behavior of the source unless it is terminated with an <code class="language-plaintext highlighter-rouge">onError</code>, in which case it tries re-subscribing to the source with the hope that it will complete without an error.</p>

<p>The number of retries is limited by the specified <code class="language-plaintext highlighter-rouge">maxRetries</code> parameter.</p>

<p>There is also <code class="language-plaintext highlighter-rouge">onErrorRestartUnlimited</code> variant for an unlimited number of retries.</p>
    
      <h3 id="onerrorrestartif">
        
        
          onErrorRestartIf <a href="#onerrorrestartif" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Observable.onErrorRestartIf</code> mirrors the behavior of the source unless it is terminated with an <code class="language-plaintext highlighter-rouge">onError</code>, in which case it invokes the  provided function and tries re-subscribing to the source with the hope that it will complete without an error.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.reactive.Observable</span>

<span class="k">case</span> <span class="k">object</span> <span class="nc">TimeoutException</span> <span class="k">extends</span> <span class="nc">Exception</span>

<span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">++</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="nc">TimeoutException</span><span class="o">)</span> <span class="o">++</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="o">{</span>
<span class="n">observable</span>
  <span class="o">.</span><span class="py">onErrorRestartIf</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">TimeoutException</span> <span class="k">=&gt;</span> <span class="kc">true</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
  <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">//=&gt; 1</span>
<span class="c1">//=&gt; 2</span>
<span class="c1">//=&gt; 3</span>
<span class="c1">//=&gt; 1</span>
<span class="c1">//=&gt; 2</span>
<span class="c1">//=&gt; 3</span>
<span class="c1">// ... fails and restarts infinitely</span>
</code></pre></div></div>
    
      <h3 id="retrying-with-delay">
        
        
          Retrying with delay <a href="#retrying-with-delay" class="anchor">#</a>
        
        
      </h3>

<p>Since <code class="language-plaintext highlighter-rouge">Observable</code> methods compose pretty nicely, you could easily combine them to write some custom retry mechanisms, like the one below:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">retryWithDelay</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">source</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">delay</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> 
  <span class="nv">source</span><span class="o">.</span><span class="py">onErrorHandleWith</span> <span class="o">{</span> <span class="k">_</span> <span class="k">=&gt;</span>
    <span class="nf">retryWithDelay</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">delay</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="n">delay</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>It can be customized further. For example, we can also implement an exponential back-off:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">retryBackoff</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">source</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span>
  <span class="n">maxRetries</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">firstDelay</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">source</span><span class="o">.</span><span class="py">onErrorHandleWith</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">Exception</span> <span class="o">=&gt;</span>
      <span class="nf">if</span> <span class="o">(</span><span class="n">maxRetries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="nf">retryBackoff</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">maxRetries</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">firstDelay</span><span class="o">*</span><span class="mi">2</span><span class="o">)</span>
          <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="n">firstDelay</span><span class="o">)</span>
      <span class="k">else</span>
        <span class="nv">Observable</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
    
      <h3 id="dropping-failed-elements">
        
        
          Dropping failed elements <a href="#dropping-failed-elements" class="anchor">#</a>
        
        
      </h3>

<p>Sometimes we would like to ignore elements that caused failure and keep going, but 
if something fails in an <code class="language-plaintext highlighter-rouge">Observable</code> operator (e.g. mapEval), the entire <code class="language-plaintext highlighter-rouge">Observable</code> is stopped with a failure.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">task</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="nc">DummyException</span><span class="o">(</span><span class="s">"error"</span><span class="o">))</span>
  <span class="k">else</span> <span class="nc">Task</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="o">}</span>

<span class="o">{</span>
<span class="n">observable</span>
  <span class="o">.</span><span class="py">mapEval</span><span class="o">(</span><span class="n">task</span><span class="o">)</span>
  <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"elem: $e"</span><span class="o">))</span>
<span class="o">}</span>
<span class="c1">//=&gt; elem: 1</span>
<span class="c1">//=&gt; Exception in thread "main" monix.execution.exceptions.DummyException: error</span>
</code></pre></div></div>

<p>There is nothing like a <code class="language-plaintext highlighter-rouge">supervision mechanism</code> (like in Akka Streams), but if we control it at the <code class="language-plaintext highlighter-rouge">Effect</code> level, we could achieve similar behavior.
For instance, we could wrap our elements in <code class="language-plaintext highlighter-rouge">Option</code> or <code class="language-plaintext highlighter-rouge">Either</code> and then do a <code class="language-plaintext highlighter-rouge">collect { case Right(e) =&gt; e }</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">task</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="nc">DummyException</span><span class="o">(</span><span class="s">"error"</span><span class="o">))</span>
  <span class="k">else</span> <span class="nc">Task</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="o">}</span>

<span class="o">{</span>
<span class="n">observable</span>
  <span class="o">.</span><span class="py">mapEval</span><span class="o">(</span><span class="nf">task</span><span class="o">(</span><span class="k">_</span><span class="o">).</span><span class="py">attempt</span><span class="o">)</span> <span class="c1">// attempt transforms Task[A] into Task[Either[Throwable, A]] with all errors handled</span>
  <span class="o">.</span><span class="py">collect</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">evt</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">evt</span><span class="o">}</span>
  <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"elem: $e"</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">//=&gt; elem: 1</span>
<span class="c1">//=&gt; elem: 3</span>
</code></pre></div></div>

<p>It’s not as nice as having one global Supervisor that handles the errors if something goes wrong, but as long as you follow
basic rules such as not throwing exceptions and remembering that any <code class="language-plaintext highlighter-rouge">Task</code> can fail then you should be good to go.</p>
    
      <h3 id="monaderror-instance">
        
        
          MonadError instance <a href="#monaderror-instance" class="anchor">#</a>
        
        
      </h3>

<p>The <code class="language-plaintext highlighter-rouge">Observable</code> provides a <code class="language-plaintext highlighter-rouge">MonadError[Observable, Throwable]</code> instance so you can use any <code class="language-plaintext highlighter-rouge">MonadError</code> operator for error handling.
If you are curious what it brings you in practice, check the methods in <a href="https://github.com/typelevel/cats/blob/main/core/src/main/scala/cats/MonadError.scala">cats.MonadError</a> and <a href="https://github.com/typelevel/cats/blob/main/core/src/main/scala/cats/ApplicativeError.scala">cats.ApplicativeError</a>.</p>

<p>Many of these methods (and more) are defined directly on the <code class="language-plaintext highlighter-rouge">Observable</code> and the rest can be acquired by calling <code class="language-plaintext highlighter-rouge">import cats.implicits._</code>.</p>
    
      <h2 id="reacting-to-internal-events">
        
        
          Reacting to internal events <a href="#reacting-to-internal-events" class="anchor">#</a>
        
        
      </h2>

<p>If you remember, an <code class="language-plaintext highlighter-rouge">Observable</code> internally calls <code class="language-plaintext highlighter-rouge">onNext</code> on every element, <code class="language-plaintext highlighter-rouge">onError</code> during error and <code class="language-plaintext highlighter-rouge">onComplete</code> after
stream completion. There are many other methods for executing a given callback when the stream acquires a specific type of event.
Usually these method names start with <code class="language-plaintext highlighter-rouge">doOn</code> or <code class="language-plaintext highlighter-rouge">doAfter</code>.</p>
    
      <h3 id="doonnext">
        
        
          doOnNext <a href="#doonnext" class="anchor">#</a>
        
        
      </h3>

<p>Executes a given callback for each element generated by the source <code class="language-plaintext highlighter-rouge">Observable</code>, useful for doing side-effects.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">counter</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="o">{</span>
<span class="n">observable</span>
  <span class="o">.</span><span class="py">doOnNext</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="n">counter</span> <span class="o">+=</span> <span class="n">e</span><span class="o">))</span>
  <span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"elem: $e, counter: $counter"</span><span class="o">))</span>
<span class="o">}</span>
<span class="c1">//=&gt; elem: 1, counter: 1</span>
<span class="c1">//=&gt; elem: 2, counter: 3</span>
<span class="c1">//=&gt; elem: 3, counter: 6</span>
</code></pre></div></div>

<p>You could also write it preserving referential transparency using <code class="language-plaintext highlighter-rouge">Ref</code> from <code class="language-plaintext highlighter-rouge">Cats-Effect</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.concurrent.Ref</span>
<span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>

<span class="k">def</span> <span class="nf">observable</span><span class="o">(</span><span class="n">counterRef</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">Task</span>, <span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="o">.</span><span class="py">doOnNext</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nv">counterRef</span><span class="o">.</span><span class="py">update</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="n">e</span><span class="o">))</span>
    <span class="o">.</span><span class="py">mapEval</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nv">counterRef</span><span class="o">.</span><span class="py">get</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">counter</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"elem: $e, counter: $counter"</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">completedL</span>
<span class="o">}</span>

<span class="nc">Ref</span><span class="o">[</span><span class="kt">Task</span><span class="o">].</span><span class="py">of</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="py">flatMap</span><span class="o">(</span><span class="n">observable</span><span class="o">)</span>
<span class="c1">// After executing:</span>
<span class="c1">//=&gt; elem: 1, counter: 1</span>
<span class="c1">//=&gt; elem: 2, counter: 3</span>
<span class="c1">//=&gt; elem: 3, counter: 6</span>
</code></pre></div></div>

<p>There is also a <code class="language-plaintext highlighter-rouge">doOnNextF</code> variant which works for data types other than <code class="language-plaintext highlighter-rouge">Task</code>.</p>
    
      <h2 id="subjects">
        
        
          Subjects <a href="#subjects" class="anchor">#</a>
        
        
      </h2>

<p><code class="language-plaintext highlighter-rouge">Subject</code> acts both as an <code class="language-plaintext highlighter-rouge">Observer</code> and as an <code class="language-plaintext highlighter-rouge">Observable</code>. Use <code class="language-plaintext highlighter-rouge">Subject</code> if you need to send elements to the <code class="language-plaintext highlighter-rouge">Observable</code>
from other parts of the application.
It is presented in the following example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.Ack</span>
<span class="k">import</span> <span class="nn">monix.reactive.subjects.ConcurrentSubject</span>
<span class="k">import</span> <span class="nn">monix.reactive.</span><span class="o">{</span><span class="nc">MulticastStrategy</span><span class="o">,</span> <span class="nc">Observable</span><span class="o">,</span> <span class="nc">Observer</span><span class="o">}</span>

<span class="k">val</span> <span class="nv">subject</span><span class="k">:</span> <span class="kt">ConcurrentSubject</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">ConcurrentSubject</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nv">MulticastStrategy</span><span class="o">.</span><span class="py">replay</span><span class="o">)</span>

<span class="k">def</span> <span class="nf">feedItem</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">observer</span><span class="k">:</span> <span class="kt">Observer</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">item</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Ack</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">deferFuture</span><span class="o">(</span><span class="nv">observer</span><span class="o">.</span><span class="py">onNext</span><span class="o">(</span><span class="n">item</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">processStream</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">observable</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">observable</span>
    <span class="o">.</span><span class="py">mapParallelUnordered</span><span class="o">(</span><span class="mi">3</span><span class="o">)(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">completedL</span>
<span class="o">}</span>

<span class="o">{</span>
<span class="nc">Task</span>
  <span class="o">.</span><span class="py">parZip2</span><span class="o">(</span>
    <span class="nf">feedItem</span><span class="o">(</span><span class="n">subject</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span>
    <span class="nf">processStream</span><span class="o">(</span><span class="n">subject</span><span class="o">)</span>
  <span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Subject</code> is also often used to specify a multicast strategy in shared (hot) <code class="language-plaintext highlighter-rouge">Observable</code>s to specify which elements are sent to
new subscribers. There are several strategies available - you can find their short characteristics below.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AsyncSubject</code> emits the last element (and only the last value) emitted by the source and only after the source completes.</li>
  <li><code class="language-plaintext highlighter-rouge">BehaviorSubject</code> emits the most recently emitted element by the source, or the <code class="language-plaintext highlighter-rouge">initialValue</code> in case no element has yet been emitted, then continue to emit events subsequent to the time of invocation.</li>
  <li><code class="language-plaintext highlighter-rouge">ConcurrentSubject</code> allows feeding events without the need to respect the back-pressure (waiting on <code class="language-plaintext highlighter-rouge">Ack</code> after <code class="language-plaintext highlighter-rouge">onNext</code>). It is similar to an <a href="https://en.wikipedia.org/wiki/Actor_model">Actor</a> and can serve as its replacement in many cases.</li>
  <li><code class="language-plaintext highlighter-rouge">PublishSubject</code> emits to a subscriber only those elements that were emitted by the source subsequent to the time of the subscription.</li>
  <li><code class="language-plaintext highlighter-rouge">PublishToOneSubject</code> is a <code class="language-plaintext highlighter-rouge">PublishSubject</code> that can be subscribed at most once.</li>
  <li><code class="language-plaintext highlighter-rouge">ReplaySubject</code> emits to a subscriber all the elements that were emitted by the source, regardless of when the observer subscribes.</li>
  <li><code class="language-plaintext highlighter-rouge">Var</code> emits the most recently emitted element by the source, or the <code class="language-plaintext highlighter-rouge">initial</code> element in case none has yet been emitted, then continue to emit events subsequent to the time of invocation via an underlying <code class="language-plaintext highlighter-rouge">ConcurrentSubject</code>. This is equivalent to a <code class="language-plaintext highlighter-rouge">ConcurrentSubject.behavior(Unbounded)</code> with the ability to expose the current value for immediate usage on top of that.</li>
</ul>

<p>For more information, refer to descriptions and methods in <code class="language-plaintext highlighter-rouge">monix.reactive.subjects</code> package.</p>
    
      <h2 id="sharing-an-observable">
        
        
          Sharing an Observable <a href="#sharing-an-observable" class="anchor">#</a>
        
        
      </h2>

<p>As mentioned before - an <code class="language-plaintext highlighter-rouge">Observable</code> doesn’t emit any items until something subscribes to it. 
If it can serve only one subscriber it is called a <em>cold Observable.</em></p>

<p>On the other hand there is also a notion of a <em>hot Observable</em> denoted as a <code class="language-plaintext highlighter-rouge">ConnectableObservable</code> whose source can be shared between many subscribers.</p>
    
      <h3 id="connectableobservable">
        
        
          ConnectableObservable <a href="#connectableobservable" class="anchor">#</a>
        
        
      </h3>

<p>Similar to the standard version, a <code class="language-plaintext highlighter-rouge">ConnectableObservable</code> is lazy, i.e. it will start processing elements after
processing <code class="language-plaintext highlighter-rouge">connect()</code>. The crucial difference is that mapping a <code class="language-plaintext highlighter-rouge">ConnectableObservable</code> returns an <code class="language-plaintext highlighter-rouge">Observable</code> which
shares the source according to the specified strategy, represented by a <code class="language-plaintext highlighter-rouge">Subject</code>.</p>

<p>Consider the following example which uses <code class="language-plaintext highlighter-rouge">publish</code> to create a <code class="language-plaintext highlighter-rouge">ConnectableObservable</code> on top of a <code class="language-plaintext highlighter-rouge">PublishSubject</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.</span><span class="o">{</span><span class="nc">Cancelable</span><span class="o">,</span> <span class="nc">Scheduler</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>
<span class="k">import</span> <span class="nn">monix.reactive.observables.ConnectableObservable</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nv">Scheduler</span><span class="o">.</span><span class="py">global</span>

<span class="k">val</span> <span class="nv">source</span><span class="k">:</span> <span class="kt">ConnectableObservable</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">Observable</span><span class="o">.</span><span class="py">intervalAtFixedRate</span><span class="o">(</span><span class="mf">100.</span><span class="n">millis</span><span class="o">)</span>
    <span class="o">.</span><span class="py">doOnNext</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"source: $i"</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">publish</span>
<span class="o">}</span>

<span class="c1">// at this point source starts printing</span>
<span class="k">val</span> <span class="nv">cancelable</span><span class="k">:</span> <span class="kt">Cancelable</span> <span class="o">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">connect</span><span class="o">()</span>

<span class="k">val</span> <span class="nv">o1</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="py">foreachL</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"o1: $i"</span><span class="o">)).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">200.</span><span class="n">millis</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">o2</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">take</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="py">foreachL</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"o2: $i"</span><span class="o">))</span>

<span class="nv">Task</span><span class="o">.</span><span class="py">parZip2</span><span class="o">(</span><span class="n">o1</span><span class="o">,</span> <span class="n">o2</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nv">cancelable</span><span class="o">.</span><span class="py">cancel</span><span class="o">())</span>
<span class="c1">// Sample Output after running:</span>
<span class="c1">// source: 0</span>
<span class="c1">// source: 1</span>
<span class="c1">// source: 2</span>
<span class="c1">// o2: 2</span>
<span class="c1">// source: 3</span>
<span class="c1">// o1: 3</span>
<span class="c1">// source: 4</span>
<span class="c1">// o1: 4</span>
</code></pre></div></div>

<p>Calling <code class="language-plaintext highlighter-rouge">connect()</code> starts the streaming. In this case, it has managed to process 3 elements before <code class="language-plaintext highlighter-rouge">o2</code> subscribed, 
so it didn’t receive all of them. It only received one element because of <code class="language-plaintext highlighter-rouge">take(1)</code>. If it was a normal <code class="language-plaintext highlighter-rouge">Observable</code> it would have been
canceled - but that’s not the case with <code class="language-plaintext highlighter-rouge">ConnectableObservable</code>s. Whenever each subscriber stops, it just unsubscribes. 
If it weren’t for <code class="language-plaintext highlighter-rouge">cancelable.cancel()</code> it would have keep to going on even after all the subscribers stopped listening. Also, note the
<code class="language-plaintext highlighter-rouge">source</code> was ran only once.</p>
    
      <h3 id="back-pressure">
        
        
          Back-pressure <a href="#back-pressure" class="anchor">#</a>
        
        
      </h3>

<p>A source <code class="language-plaintext highlighter-rouge">ConnectableObservable</code> is back-pressured on <em>all</em> subscribers. In other words, it will wait for an acknowledgement from
all active subscribers before processing the next element.</p>

<p>Let’s see it on an example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.</span><span class="o">{</span><span class="nc">Cancelable</span><span class="o">,</span> <span class="nc">Scheduler</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>
<span class="k">import</span> <span class="nn">monix.reactive.observables.ConnectableObservable</span>

<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nv">Scheduler</span><span class="o">.</span><span class="py">global</span>

<span class="k">val</span> <span class="nv">source</span><span class="k">:</span> <span class="kt">ConnectableObservable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span> <span class="c1">// delay to ensure subscribers will get all elements</span>
    <span class="o">.</span><span class="py">doOnNext</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"source: $i"</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">publish</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">cancelable</span><span class="k">:</span> <span class="kt">Cancelable</span> <span class="o">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">connect</span><span class="o">()</span>

<span class="k">val</span> <span class="nv">o1</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">delayOnNext</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">).</span><span class="py">foreachL</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"o1: $i"</span><span class="o">))</span>

<span class="k">val</span> <span class="nv">o2</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"o2: $i"</span><span class="o">))</span>

<span class="nv">Task</span><span class="o">.</span><span class="py">parZip2</span><span class="o">(</span><span class="n">o1</span><span class="o">,</span> <span class="n">o2</span><span class="o">)</span>
<span class="c1">// Sample Output after running:</span>
<span class="c1">// source: 1</span>
<span class="c1">// o2: 1</span>
<span class="c1">// -- 2 second delay -- </span>
<span class="c1">// o1: 1</span>
<span class="c1">// source: 2</span>
<span class="c1">// o2: 2</span>
<span class="c1">// -- 2 second delay -- </span>
<span class="c1">// o1: 2</span>
<span class="c1">// source: 3</span>
<span class="c1">// o2: 3</span>
<span class="c1">// -- 2 second delay -- </span>
<span class="c1">// o1: 3</span>
</code></pre></div></div>

<p>It might not be always desirable if we don’t want to slow down the producer. There are several ways to handle it, depending
on the use case. In general, if we don’t want back-pressure, we need a buffer with a proper overflow strategy.</p>

<p>For instance, we could introduce a buffer per subscriber which can store up to 10 elements and then starts dropping new elements:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">subObservable</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">whileBusyBuffer</span><span class="o">(</span><span class="nv">OverflowStrategy</span><span class="o">.</span><span class="py">DropNew</span><span class="o">(</span><span class="mi">10</span><span class="o">))</span>
</code></pre></div></div>

<p>We could even disable back-pressure completely with a function like <code class="language-plaintext highlighter-rouge">whileBusyDropEvents</code>.
From the perspective of the <code class="language-plaintext highlighter-rouge">source</code>, the subscriber is always processing elements right away so it doesn’t have to wait on it.</p>
    
      <h3 id="configuring-underlying-subject">
        
        
          Configuring underlying Subject <a href="#configuring-underlying-subject" class="anchor">#</a>
        
        
      </h3>

<p>For all plain <code class="language-plaintext highlighter-rouge">Subject</code>s, there are corresponding methods, i.e. <code class="language-plaintext highlighter-rouge">publish</code>, <code class="language-plaintext highlighter-rouge">publishLast</code>, <code class="language-plaintext highlighter-rouge">replay</code> etc. 
Different <code class="language-plaintext highlighter-rouge">Subjects</code> vary in behavior with regard to subscribers, but <code class="language-plaintext highlighter-rouge">source</code> Observables will always be executed just once.</p>

<p>For instance, a <code class="language-plaintext highlighter-rouge">ReplaySubject</code> will cache and send all elements to new subscribers:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nv">Scheduler</span><span class="o">.</span><span class="py">global</span>

<span class="k">val</span> <span class="nv">source</span><span class="k">:</span> <span class="kt">ConnectableObservable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="o">.</span><span class="py">doOnNext</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"source: $i"</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">replay</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">cancelable</span><span class="k">:</span> <span class="kt">Cancelable</span> <span class="o">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">connect</span><span class="o">()</span>

<span class="k">val</span> <span class="nv">o1</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"o1: $i"</span><span class="o">))</span>
<span class="c1">// Sample Output after running:</span>
<span class="c1">// source: 1</span>
<span class="c1">// source: 2</span>
<span class="c1">// source: 3</span>
<span class="c1">// o1: 1</span>
<span class="c1">// o1: 2</span>
<span class="c1">// o1: 3</span>
</code></pre></div></div>

<p>Another example could be <code class="language-plaintext highlighter-rouge">BehaviorSubject</code> which remembers the latest element to feed to new subscribers:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nv">Scheduler</span><span class="o">.</span><span class="py">global</span>

<span class="k">val</span> <span class="nv">source</span><span class="k">:</span> <span class="kt">ConnectableObservable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="o">.</span><span class="py">doOnNext</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"source: $i"</span><span class="o">)))</span>
    <span class="o">.</span><span class="py">behavior</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">cancelable</span><span class="k">:</span> <span class="kt">Cancelable</span> <span class="o">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">connect</span><span class="o">()</span>

<span class="k">val</span> <span class="nv">o1</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">foreachL</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"o1: $i"</span><span class="o">))</span>
<span class="c1">// Sample Output after running:</span>
<span class="c1">// source: 1</span>
<span class="c1">// source: 2</span>
<span class="c1">// source: 3</span>
<span class="c1">// o1: 3</span>
</code></pre></div></div>

<p>If it were a <code class="language-plaintext highlighter-rouge">PublishSubject</code>, the subscriber would not receive any elements because the <code class="language-plaintext highlighter-rouge">source</code> has processed everything
before subscription.</p>
    
      <h3 id="doing-it-the-pure-way">
        
        
          Doing it the pure way <a href="#doing-it-the-pure-way" class="anchor">#</a>
        
        
      </h3>

<p>As you probably noticed, <code class="language-plaintext highlighter-rouge">ConnectableObservable</code> is not very pure because the time of subscription can completely change the result
and the original <code class="language-plaintext highlighter-rouge">source</code> is processed only once. Monix also exposes <code class="language-plaintext highlighter-rouge">publishSelector</code> and <code class="language-plaintext highlighter-rouge">pipeThroughSelector</code> which allows
you to take advantage of Hot <code class="language-plaintext highlighter-rouge">Observable</code>s in more controlled and purely functional fashion.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">s</span> <span class="k">=</span> <span class="nv">Scheduler</span><span class="o">.</span><span class="py">global</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="o">{</span>  
  <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="o">.</span><span class="py">doOnNext</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Produced $i"</span><span class="o">))</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">consume</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">obs</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">obs</span><span class="o">.</span><span class="py">mapEval</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"$name: got $i"</span><span class="o">)))</span>

<span class="k">val</span> <span class="nv">shared</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">source</span><span class="o">.</span><span class="py">publishSelector</span> <span class="o">{</span> <span class="n">hot</span> <span class="k">=&gt;</span>
    <span class="nc">Observable</span><span class="o">(</span>
      <span class="nf">consume</span><span class="o">(</span><span class="s">"Consumer 1"</span><span class="o">,</span> <span class="n">hot</span><span class="o">),</span>
      <span class="nf">consume</span><span class="o">(</span><span class="s">"Consumer 2"</span><span class="o">,</span> <span class="n">hot</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span>
    <span class="o">).</span><span class="py">merge</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="nv">shared</span><span class="o">.</span><span class="py">subscribe</span><span class="o">()</span>
</code></pre></div></div>

<p>The code would print the following output twice:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Produced 1
Consumer 1: got 1
Produced 2
Consumer 1: got 2
Consumer 2: got 2
Produced 3
Consumer 1: got 3
Consumer 2: got 3
</code></pre></div></div>

<p>A <code class="language-plaintext highlighter-rouge">source</code> Observable is shared only in the scope of <code class="language-plaintext highlighter-rouge">publishSelector</code> and we can freely reuse its result and the original source.</p>

<p><code class="language-plaintext highlighter-rouge">publishSelector</code> uses <code class="language-plaintext highlighter-rouge">PublishSubject</code>. It is possible to customize it with a <code class="language-plaintext highlighter-rouge">pipeThroughSelector</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">def</span> <span class="nf">pipeThroughSelector</span><span class="o">[</span><span class="kt">S</span> <span class="k">&gt;:</span> <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">R</span><span class="o">](</span><span class="n">pipe</span><span class="k">:</span> <span class="kt">Pipe</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Observable</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Pipe</code> has variants for all types of subjects, e.g. <code class="language-plaintext highlighter-rouge">source.pipeThroughSelector(Pipe.replay[Int], f)</code>.</p>
    
      <h2 id="interoperability-with-other-streams-api-akka-streams-fs2">
        
        
          Interoperability with other Streams API (Akka Streams, FS2) <a href="#interoperability-with-other-streams-api-akka-streams-fs2" class="anchor">#</a>
        
        
      </h2>

<p>Due to compatibility with the <a href="http://www.reactive-streams.org/">Reactive Streams</a>
specification, an <code class="language-plaintext highlighter-rouge">Observable</code> allows good interoperability with other libraries.</p>

<p>The next subsections contain examples how to convert between Monix <code class="language-plaintext highlighter-rouge">Observable</code> and
two other popular streaming libraries, but it should work in similar way with every other library
compatible with Reactive Streams protocol.</p>
    
      <h3 id="akka-streams">
        
        
          Akka Streams <a href="#akka-streams" class="anchor">#</a>
        
        
      </h3>

<p>Necessary imports and initialization for <code class="language-plaintext highlighter-rouge">Akka Streams</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.reactive.Observable</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
<span class="k">import</span> <span class="nn">akka._</span>
<span class="k">import</span> <span class="nn">akka.stream._</span>
<span class="k">import</span> <span class="nn">akka.stream.scaladsl._</span>
<span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">"akka-streams"</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="nv">materializer</span> <span class="k">=</span> <span class="nc">ActorMaterializer</span><span class="o">()</span>
</code></pre></div></div>

<p>To convert an Akka <code class="language-plaintext highlighter-rouge">Source</code> to a Monix <code class="language-plaintext highlighter-rouge">Observable</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">3</span><span class="o">)</span>
<span class="c1">// source: akka.stream.scaladsl.Source[Int,akka.NotUsed] = Source(SourceShape(StatefulMapConcat.out(1887925338)))</span>

<span class="k">val</span> <span class="nv">publisher</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">runWith</span><span class="o">(</span><span class="nv">Sink</span><span class="o">.</span><span class="py">asPublisher</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">fanout</span> <span class="k">=</span> <span class="kc">false</span><span class="o">))</span>
<span class="c1">// publisher: org.reactivestreams.Publisher[Int] = VirtualPublisher(state = Publisher[StatefulMapConcat.out(1887925338)])</span>

<span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">fromReactivePublisher</span><span class="o">(</span><span class="n">publisher</span><span class="o">)</span>
<span class="c1">// observable: monix.reactive.Observable[Int] = monix.reactive.internal.builders.ReactiveObservable@72f8ecd</span>
</code></pre></div></div>

<p>To go back from a Monix <code class="language-plaintext highlighter-rouge">Observable</code> to an Akka <code class="language-plaintext highlighter-rouge">Source</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="c1">// observable: monix.reactive.Observable[Int] = monix.reactive.internal.builders.IterableAsObservable@4783cc8</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Source</span><span class="o">.</span><span class="py">fromPublisher</span><span class="o">(</span><span class="nv">observable</span><span class="o">.</span><span class="py">toReactivePublisher</span><span class="o">)</span>
<span class="c1">// source: akka.stream.scaladsl.Source[Int,akka.NotUsed] = Source(SourceShape(PublisherSource.out(989856637)))</span>
</code></pre></div></div>
    
      <h3 id="fs2">
        
        
          FS2 <a href="#fs2" class="anchor">#</a>
        
        
      </h3>

<p>To go between an <a href="https://github.com/functional-streams-for-scala/fs2">FS2</a> Stream 
and a Monix <code class="language-plaintext highlighter-rouge">Observable</code> you need to use the <a href="https://github.com/zainab-ali/fs2-reactive-streams">fs2-reactive-streams</a>
library, but otherwise the conversion remains very straightforward.</p>

<p>Necessary imports:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect._</span><span class="o">,</span> <span class="nv">fs2</span><span class="o">.</span><span class="py">_</span>
<span class="k">import</span> <span class="nn">fs2.interop.reactivestreams._</span>
<span class="k">import</span> <span class="nn">monix.reactive.Observable</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
</code></pre></div></div>

<p>To convert an FS2 <code class="language-plaintext highlighter-rouge">Stream</code> to a Monix <code class="language-plaintext highlighter-rouge">Observable</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="nc">Stream</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="py">covary</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span>
<span class="c1">// stream: fs2.Stream[cats.effect.IO,Int] = Stream(..)</span>

<span class="k">val</span> <span class="nv">publisher</span> <span class="k">=</span> <span class="nv">stream</span><span class="o">.</span><span class="py">toUnicastPublisher</span><span class="o">()</span>
<span class="c1">// publisher: fs2.interop.reactivestreams.StreamUnicastPublisher[cats.effect.IO,Int] = fs2.interop.reactivestreams.StreamUnicastPublisher@6418f777</span>

<span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">fromReactivePublisher</span><span class="o">(</span><span class="n">publisher</span><span class="o">)</span>
<span class="c1">// observable: monix.reactive.Observable[Int] = monix.reactive.internal.builders.ReactiveObservable@7130d725</span>
</code></pre></div></div>

<p>To go back from a Monix <code class="language-plaintext highlighter-rouge">Observable</code> to an FS2 <code class="language-plaintext highlighter-rouge">Stream</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">observable</span> <span class="k">=</span> <span class="nc">Observable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="c1">// observable: monix.reactive.Observable[Int] = monix.reactive.internal.builders.IterableAsObservable@4783cc8</span>

<span class="k">val</span> <span class="nv">stream</span> <span class="k">=</span> <span class="nv">observable</span><span class="o">.</span><span class="py">toReactivePublisher</span><span class="o">.</span><span class="py">toStream</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span>
<span class="c1">// stream: fs2.Stream[cats.effect.IO,Int] = Stream(..)</span>
</code></pre></div></div>


  <div class="buttons">
    <a href="/docs/3x/">Contents</a> •
    <a href="https://github.com/monix/monix.io/blob/main/_docs/3x/reactive/observable.md">
      Edit Page</a> •
    
    <a href="https://gitter.im/monix/monix">
      Join Chat</a> •
    <a href="/social.html">
      Follow</a>
  </div>
</div>
      </article>
    </div>
    <!-- Here goes scripts and stuff, but right now there's nothing. -->
  </body>
</html>
