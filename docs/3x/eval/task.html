<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  
  <title>Task &mdash; Monix</title>

  <!-- Twitter Card -->
  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:image" content="https://monix.io/public/images/monix-logo-rect.png" />
  <meta name="twitter:site" content="@monix" />  
  <meta name="twitter:title" content="Task &mdash; Monix" />
  <meta name="twitter:description" content="A data type for controlling possibly lazy &amp; asynchronous computations, useful for controlling side-effects, avoiding nondeterminism and callback-hell." />

  <!-- Facebook Open-Graph -->
  <meta property="fb:app_id" content="2160100887367418" />
  <meta property="og:url" content="https://monix.io/docs/3x/eval/task" />
  
  <meta property="og:type" content="article" />
  <meta property="og:image" content="https://monix.io/public/images/monix-logo.png" />
  <meta property="og:image:secure_url" content="https://monix.io/public/images/monix-logo.png">
  <meta property="og:title" content="Task &mdash; Monix" />
  <meta property="og:description" content="A data type for controlling possibly lazy &amp; asynchronous computations, useful for controlling side-effects, avoiding nondeterminism and callback-hell." />
  
  <!-- Javascript -->
  <script src="//code.jquery.com/jquery-2.2.4.min.js" type="text/javascript" language="javascript"></script>
  <script src="/public/js/toc.js?1541861914894085687" type="text/javascript" language="javascript"></script>
  <script src="/public/js/init.js?1541861914894085687" type="text/javascript" language="javascript"></script>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/all.css?1541861914894085687">
  <!--[if lt IE 9]>
  <link rel="stylesheet" href="/public/css/forkme.ie.css?1541861914894085687">
  <![endif]-->

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Web App Manifest, see: http://manifest.sysapps.org/ -->
  <link rel="manifest" href="/manifest.json">
  <!-- Icons -->
  <link rel="icon" sizes="48x48" href="/public/icons/icon-48x48.png">
  <link rel="icon" sizes="72x72" href="/public/icons/icon-72x72.png">
  <link rel="icon" sizes="96x96" href="/public/icons/icon-96x96.png">
  <link rel="icon" sizes="144x144" href="/public/icons/icon-144x144.png">
  <link rel="icon" sizes="192x192" href="/public/icons/icon-192x192.png">
  <link rel="icon" sizes="240x240" href="/public/icons/icon-240x240.png">
  <link rel="icon" sizes="384x384" href="/public/icons/icon-384x384.png">
  <!-- Mobile Safari / iOS Icons -->
  <link rel="apple-touch-icon" sizes="48x48" href="/public/icons/icon-48x48.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/public/icons/icon-72x72.png">
  <link rel="apple-touch-icon" sizes="96x96" href="/public/icons/icon-96x96.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/public/icons/icon-144x144.png">
  <link rel="apple-touch-icon" sizes="192x192" href="/public/icons/icon-192x192.png">
  <link rel="apple-touch-icon" sizes="240x240" href="/public/icons/icon-240x240.png">
  <link rel="apple-touch-icon" sizes="384x384" href="/public/icons/icon-384x384.png">
  <!-- Standard Favicon -->
  <link rel="shortcut icon" href="/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="Feed" href="/blog/atom.xml">
</head>


  <body class="monix layout">
    <div class="wrapper">
      <aside class="sidebar plus">
  <div class="container">
    <div class="sidebar-about">
      <a class="github-fork-ribbon left-top" href="https://github.com/monix/monix"
        title="Fork me on GitHub">Fork me on GitHub</a>

      <h1>
        <a href="/">
          <img src="/public/images/monix-logo.png"
            alt="Monix Logo" title="Monix" class="logo" />
        </a>
      </h1>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">About</a>
      <a class="sidebar-nav-item" href="/blog/">Blog</a>
      <a class="sidebar-nav-item active" href="/docs/3x/">Documentation</a>
      <a class="sidebar-nav-item" href="/presentations/">Presentations</a>
      <a class="sidebar-nav-item" href="https://github.com/monix/monix">GitHub project</a>
      <a class="sidebar-nav-item" href="/social.html">Follow @Monix</a>
    </nav>
  </div>
</aside>

    
      <article class="content container">
        <div class="page">
  <h1 class="page-title">Task</h1>
  <nav role="navigation" id="type-info">
    <a href="/api/3.0/monix/eval/Task.html">API Documentation</a>
    <a href="https://github.com/monix/monix/blob/v3.0.0-RC2/monix-eval/shared/src/main/scala/monix/eval/Task.scala">Source Code</a>
    
    <a href="https://github.com/monix/monix.io/edit/master/_tut/docs/3x/eval/task.md">Edit Page</a>
  </nav>

  <nav role="navigation" id="toc"></nav>

  <h2 id="introduction">Introduction</h2>

<p>Task is a data type for controlling possibly lazy &amp; asynchronous
computations, useful for controlling side-effects, avoiding
nondeterminism and callback-hell.</p>

<p>To get the imports out of the way:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In order to evaluate tasks, we'll need a Scheduler
</span><span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>

<span class="c1">// A Future type that is also Cancelable
</span><span class="k">import</span> <span class="nn">monix.execution.CancelableFuture</span>

<span class="c1">// Task is in monix.eval
</span><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Executing a sum, which (due to the semantics of apply)
// will happen on another thread. Nothing happens on building
// this instance though, this expression is pure, being
// just a spec! Task by default has lazy behavior ;-)
</span><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">}</span>

<span class="c1">// Tasks get evaluated only on runToFuture!
// Callback style:
</span><span class="k">val</span> <span class="n">cancelable</span> <span class="k">=</span> <span class="n">task</span><span class="o">.</span><span class="n">runAsync</span> <span class="o">{</span> <span class="n">result</span> <span class="k">=&gt;</span>
  <span class="n">result</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nc">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"ERROR: ${ex.getMessage}"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">//=&gt; 2
</span>
<span class="c1">// Or you can convert it into a Future
</span><span class="k">val</span> <span class="n">future</span><span class="k">:</span> <span class="kt">CancelableFuture</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">task</span><span class="o">.</span><span class="n">runToFuture</span>

<span class="c1">// Printing the result asynchronously
</span><span class="n">future</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; 2
</span></code></pre></div></div>

<h3 id="design-summary">Design Summary</h3>

<p>In summary the Monix <code class="highlighter-rouge">Task</code>:</p>

<ul>
  <li>models lazy &amp; asynchronous evaluation</li>
  <li>models a producer pushing only one value to one or multiple consumers</li>
  <li>allows fine-grained control over the <a href="../execution/scheduler.html#execution-model">execution model</a></li>
  <li>doesn’t trigger the execution, or any effects until <code class="highlighter-rouge">runToFuture</code></li>
  <li>doesn’t necessarily execute on another logical thread</li>
  <li>allows for cancelling of a running computation</li>
  <li>allows for controlling of side-effects, being just as
potent as Haskell’s I/O ;-)</li>
  <li>never blocks any threads in its implementation</li>
  <li>does not expose any API calls that can block threads</li>
</ul>

<p>A visual representation of where they sit in the design
space:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">Eager</th>
      <th style="text-align: center">Lazy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>Synchronous</strong></td>
      <td style="text-align: center">A</td>
      <td style="text-align: center">() =&gt; A</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"><a href="./coeval.html">Coeval[A]</a></td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>Asynchronous</strong></td>
      <td style="text-align: center">(A =&gt; Unit) =&gt; Unit</td>
      <td style="text-align: center">(A =&gt; Unit) =&gt; Unit</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">Future[A]</td>
      <td style="text-align: center">Task[A]</td>
    </tr>
  </tbody>
</table>

<h3 id="comparison-with-scalas-future">Comparison with Scala’s Future</h3>

<p><code class="highlighter-rouge">Task</code> sounds similar with Scala’s
<a href="http://docs.scala-lang.org/overviews/core/futures.html">Future</a>, but
has a different character and the two types as you’ll see are actually
complementary. A wise man once said:</p>

<blockquote>
  <p>“<em>A Future represents a value, detached from time</em>” — Viktor Klang</p>
</blockquote>

<p>That’s certainly a poetic notion, making one think about what values
are and how they incorporate time. But more importantly, while we
cannot say that a <code class="highlighter-rouge">Future</code> is a
<a href="https://en.wikipedia.org/wiki/Value_(computer_science)">value</a>,
we can certainly say that it’s a <em>value-wannabe</em>, meaning that when
users receive a <code class="highlighter-rouge">Future</code> reference, they know that whatever process
that’s going to evaluate it has probably already started and it might
have even finished already. This makes the behavior of Scala’s
<code class="highlighter-rouge">Future</code> to be about <em>eager evaluation</em> and certainly its design helps
with that, if you think about how it takes that implicit execution
context whenever you call its operators, like <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">flatMap</code>.</p>

<p>But <code class="highlighter-rouge">Task</code> is different. <code class="highlighter-rouge">Task</code> is about lazy evaluation. Well, not
always lazy, in fact <code class="highlighter-rouge">Task</code> allows for fine-tuning the execution
model, as you’ll see, but that’s the primary distinction between
them. If <code class="highlighter-rouge">Future</code> is like a value, then <code class="highlighter-rouge">Task</code> is like a function. And
in fact <code class="highlighter-rouge">Task</code> can function as a “factory” of <code class="highlighter-rouge">Future</code> instances.</p>

<p>Another distinction is that <code class="highlighter-rouge">Future</code> is “<em>memoized</em>” by default,
meaning that its result is going to be shared between multiple
consumers if needed. But the evaluation of a <code class="highlighter-rouge">Task</code> is not memoized by
default. No, you have to want memoization to happen, you have to
specify it explicitly, as you’ll see.</p>

<p>In terms of efficiency, <code class="highlighter-rouge">Future</code> having eager behavior, happens to be
less efficient because whatever operation you’re doing on it, the
implementation will end up sending <code class="highlighter-rouge">Runnable</code> instances in the
thread-pool and because the result is always memoized on each step,
invoking that machinery (e.g. going into compare-and-set loops)
whatever you’re doing. On the other hand <code class="highlighter-rouge">Task</code> can do execution in
synchronous batches.</p>

<h3 id="comparison-with-the-scalaz-task">Comparison with the Scalaz Task</h3>

<p>It’s no secret that the Monix Task was inspired by the
<a href="https://github.com/scalaz/scalaz">Scalaz</a> Task, an otherwise solid
implementation. The whole Monix library stands on the shoulders of
giants. But where the Monix Task implementation disagrees:</p>

<ol>
  <li>The Scalaz Task is leaking implementation details. This is because
the Scalaz Task is first and foremost about <em>trampolined</em>
execution, but asynchronous execution is about jumping over
asynchronous and thus trampoline boundaries. So the API is limited
by what the trampoline can do and for example in order to not block
the current thread in a big loop, you have to <em>manually insert</em>
async boundaries yourself by means of <code class="highlighter-rouge">Task.executeAsync</code>. The Monix Task
on the other hand manages to do that automatically by default,
which is very useful when running on top of
<a href="http://www.scala-js.org/">Javascript</a>, where
<a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">cooperative multitasking</a>
is not only nice to have, but required.</li>
  <li>The Scalaz Task has a dual synchronous / asynchronous
personality. That is fine for optimization purposes as far as the
producer is concerned (i.e. why fork a thread when you don’t have
to), but from the consumer’s point of view having a <code class="highlighter-rouge">def run: A</code>
means that the API cannot be fully supported on top of Javascript
and on top of the JVM it means that the <code class="highlighter-rouge">Task</code> ends up faking
synchronous evaluation and blocking threads. And <a href="../best-practices/blocking.html">blocking threads
is very unsafe</a>.</li>
  <li>The Scalaz Task cannot cancel running computations. This is
important for nondeterministic operations. For example when you
create a race condition with a <code class="highlighter-rouge">race</code>, you may want to
cancel the slower task that didn’t finish in time, because
unfortunately, if we don’t release resources soon enough, we can
end up with serious leakage that can crash our process.</li>
  <li>The Scalaz Task piggybacks on top of Java’s standard library for
dealing with asynchronous execution. This is bad for portability
reasons, as this API is not supported on top of
<a href="http://www.scala-js.org/">Scala.js</a>.</li>
</ol>

<h2 id="execution-runtofuture--foreach">Execution (runToFuture &amp; foreach)</h2>

<p><code class="highlighter-rouge">Task</code> instances won’t do anything until they are executed by means
of <code class="highlighter-rouge">runToFuture</code>. And there are multiple overloads of it.</p>

<p><code class="highlighter-rouge">Task.runToFuture</code> also wants an implicit
<a href="../execution/scheduler.html">Scheduler</a> in scope, that can supplant
your <code class="highlighter-rouge">ExecutionContext</code> (since it inherits from it). But this is where
the design of <code class="highlighter-rouge">Task</code> diverges from Scala’s own <code class="highlighter-rouge">Future</code>. The <code class="highlighter-rouge">Task</code>
being lazy, it only wants this <code class="highlighter-rouge">Scheduler</code> on execution with
<code class="highlighter-rouge">runToFuture</code>, instead of wanting it on every operation (like <code class="highlighter-rouge">map</code> or
<code class="highlighter-rouge">flatMap</code>), the way that Scala’s <code class="highlighter-rouge">Future</code> does.</p>

<p>So first things first, we need a <code class="highlighter-rouge">Scheduler</code> in scope. The <code class="highlighter-rouge">global</code> is
piggybacking on Scala’s own <code class="highlighter-rouge">global</code>, so now you can do this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
</code></pre></div></div>

<p><strong>NOTE:</strong> The <a href="../execution/scheduler.html">Scheduler</a> can inject a
configurable
<a href="../execution/scheduler.html#execution-model">execution model</a> which
determines how asynchronous boundaries get forced (or not). Read up on
it.</p>

<p>The most straightforward and idiomatic way would be to execute
tasks and get a
<a href="/api/3.0/monix/execution/CancelableFuture.html">CancelableFuture</a>
in return, which is a standard <code class="highlighter-rouge">Future</code> paired with a
<a href="../execution/cancelable.html">Cancelable</a>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.CancelableFuture</span>
<span class="k">import</span> <span class="nn">concurrent.duration._</span>

<span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="kt">CancelableFuture</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">task</span><span class="o">.</span><span class="n">runToFuture</span>

<span class="c1">// If we change our mind
</span><span class="n">result</span><span class="o">.</span><span class="n">cancel</span><span class="o">()</span>
</code></pre></div></div>

<p>Returning a <code class="highlighter-rouge">Future</code> might be too heavy for your needs, you might want
to provide a simple callback. We can also <code class="highlighter-rouge">runAsync</code> with a <code class="highlighter-rouge">Either[Throwable, A] =&gt;
Unit</code> callback, similar to the standard <code class="highlighter-rouge">Future.onComplete</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="n">cancelable</span> <span class="k">=</span> <span class="n">task</span><span class="o">.</span><span class="n">runAsync</span> <span class="o">{</span> <span class="n">result</span> <span class="k">=&gt;</span>
  <span class="n">result</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nc">System</span><span class="o">.</span><span class="n">err</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"ERROR: ${ex.getMessage}"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// If we change our mind...
</span><span class="n">cancelable</span><span class="o">.</span><span class="n">cancel</span><span class="o">()</span>
</code></pre></div></div>

<p>We can also <code class="highlighter-rouge">runAsync</code> with a <a href="(../execution/callback.html)">Callback</a> instance.
This is like a Java-ish API, useful in case, for any reason whatsoever,
you want to keep state. <code class="highlighter-rouge">Callback</code> is also used internally, because it
allows us to guard against contract violations and to avoid the boxing
specific to <code class="highlighter-rouge">Try[T]</code> or <code class="highlighter-rouge">Either[E, A]</code>. Sample:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Callback</span>

<span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="n">cancelable</span> <span class="k">=</span> <span class="n">task</span><span class="o">.</span><span class="n">runAsync</span><span class="o">(</span>
  <span class="k">new</span> <span class="nc">Callback</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">onSuccess</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
      <span class="n">println</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">onError</span><span class="o">(</span><span class="n">ex</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
      <span class="nc">System</span><span class="o">.</span><span class="n">err</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"ERROR: ${ex.getMessage}"</span><span class="o">)</span>
  <span class="o">})</span>

<span class="c1">// If we change our mind...
</span><span class="n">cancelable</span><span class="o">.</span><span class="n">cancel</span><span class="o">()</span>
</code></pre></div></div>

<p>But if you just want to trigger some side-effects quickly, you can
just use <code class="highlighter-rouge">foreach</code> directly:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect!"</span><span class="o">);</span> <span class="s">"Result"</span> <span class="o">}</span>

<span class="n">task</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="n">result</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="o">}</span>
<span class="c1">//=&gt; Effect!
//=&gt; Result
</span>
<span class="c1">// Or we can use for-comprehensions
</span><span class="k">for</span> <span class="o">(</span><span class="n">result</span> <span class="k">&lt;-</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>NOTE: <code class="highlighter-rouge">foreach</code> on <code class="highlighter-rouge">Task</code> does not block, but returns a
<code class="highlighter-rouge">CancelableFuture[Unit]</code> that can be used to block on the execution,
or for cancellation.</p>

<h3 id="blocking-for-a-result">Blocking for a Result</h3>

<p>Monix is <a href="../best-practices/blocking.html">against blocking</a> as a
matter of philosophy, therefore <code class="highlighter-rouge">Task</code> doesn’t have any API calls that
blocks threads, none!</p>

<p>However, on top of the JVM sometimes we have to block. And if we have
to block, Monix doesn’t try to outsmart Scala’s standard library,
because the standard <code class="highlighter-rouge">Await.result</code> and <code class="highlighter-rouge">Await.ready</code> have two healthy
design choices:</p>

<ol>
  <li>These calls use Scala’s <code class="highlighter-rouge">BlockContext</code> in their implementation,
signaling to the underlying thread-pool that a blocking operation
is being executed, allowing the thread-pool to act on it. For
example it might decide to add more threads in the pool, like
Scala’s <code class="highlighter-rouge">ForkJoinPool</code> is doing.</li>
  <li>These calls require a very explicit timeout parameter, specified as
a <code class="highlighter-rouge">FiniteDuration</code>, triggering a <code class="highlighter-rouge">TimeoutException</code> in case that
specified timespan is exceeded without the source being ready.</li>
</ol>

<p>Therefore in order to block on a result, you have to first convert it
into a <code class="highlighter-rouge">Future</code> by means of <code class="highlighter-rouge">runToFuture</code> and then you can block on it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Await</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">).</span><span class="n">executeAsync</span>
<span class="k">val</span> <span class="n">future</span> <span class="k">=</span> <span class="n">task</span><span class="o">.</span><span class="n">runToFuture</span>

<span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">future</span><span class="o">,</span> <span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!
</span></code></pre></div></div>

<p><strong>NOTE:</strong> There is <a href="https://github.com/scala-js/scala-js/issues/186">no blocking</a>
on Scala.js by design.</p>

<h3 id="try-immediate-execution-coeval">Try Immediate Execution (Coeval)</h3>

<p>Monix is against blocking, we’ve established that. But clearly some
<code class="highlighter-rouge">Task</code> instances can be evaluated immediately on the current logical
thread, if allowed by the execution model. And for <em>optimization
purposes</em>, we might want to act immediately on their results, avoiding
dealing with callbacks.</p>

<p>To do that, we can convert a <code class="highlighter-rouge">Task</code> into a <code class="highlighter-rouge">Coeval</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">)</span>

<span class="k">val</span> <span class="n">tryingNow</span> <span class="k">=</span> <span class="n">task</span><span class="o">.</span><span class="n">coeval</span>
<span class="c1">// tryingNow: Coeval[Either[CancelableFuture[String],String]] = ???
</span>
<span class="n">tryingNow</span><span class="o">.</span><span class="n">value</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">future</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="c1">// No luck, this Task really wants async execution
</span>    <span class="n">future</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Async: $r"</span><span class="o">))</span>
  <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Got lucky: $result"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>NOTE:</strong> as it happens, by default the <code class="highlighter-rouge">eval</code> builder is
executing things on the current thread, unless an async boundary is
forced by the underlying loop. So this code will always print “<em>Got
Lucky</em>” ;-)</p>

<h2 id="simple-builders">Simple Builders</h2>

<p>If you can accept its possibly asynchronous nature, <code class="highlighter-rouge">Task</code> can replace
functions accepting zero arguments, Scala by-name params and <code class="highlighter-rouge">lazy
val</code>. And any Scala <code class="highlighter-rouge">Future</code> is convertible to <code class="highlighter-rouge">Task</code>.</p>

<h3 id="tasknow">Task.now</h3>

<p><code class="highlighter-rouge">Task.now</code>
lifts an already known value in the <code class="highlighter-rouge">Task</code> context,
the equivalent of <code class="highlighter-rouge">Future.successful</code> or of <code class="highlighter-rouge">Applicative.pure</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">now</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="c1">//=&gt; Effect
// task: monix.eval.Task[String] = Delay(Now(Hello!))
</span></code></pre></div></div>

<h3 id="taskeval-delay">Task.eval (delay)</h3>

<p><code class="highlighter-rouge">Task.eval</code>
is the equivalent of <code class="highlighter-rouge">Function0</code>, taking a function
that will always be evaluated on <code class="highlighter-rouge">runToFuture</code>, possibly on the same
thread (depending on the chosen
<a href="../execution/scheduler.html#execution-model">execution model</a>):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="c1">// task: monix.eval.Task[String] = Delay(Always(&lt;function0&gt;))
</span>
<span class="n">task</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect
//=&gt; Hello!
</span>
<span class="c1">// The evaluation (and thus all contained side effects)
// gets triggered on each runToFuture:
</span><span class="n">task</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect
//=&gt; Hello!
</span></code></pre></div></div>

<p>NOTE: for Scalaz converts, this function is also aliased as <code class="highlighter-rouge">Task.delay</code>.</p>

<h3 id="taskevalonce">Task.evalOnce</h3>

<p><code class="highlighter-rouge">Task.evalOnce</code>
is the equivalent of a <code class="highlighter-rouge">lazy val</code>, a type that cannot
be precisely expressed in Scala. The <code class="highlighter-rouge">evalOnce</code> builder does
memoization on the first run, such that the result of the evaluation
will be available for subsequent runs. It also has guaranteed
idempotency and thread-safety:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">evalOnce</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="c1">// task: monix.eval.Task[String] = EvalOnce(&lt;function0&gt;)
</span>
<span class="n">task</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect
//=&gt; Hello!
</span>
<span class="c1">// Result was memoized on the first run!
</span><span class="n">task</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!
</span></code></pre></div></div>

<p>NOTE: this operation is effectively <code class="highlighter-rouge">Task.eval(f).memoize</code>.</p>

<h3 id="taskdefer-suspend">Task.defer (suspend)</h3>

<p><code class="highlighter-rouge">Task.defer</code>
is about building a factory of tasks. For example this
will behave approximately like <code class="highlighter-rouge">Task.eval</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">defer</span> <span class="o">{</span>
  <span class="nc">Task</span><span class="o">.</span><span class="n">now</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// task: monix.eval.Task[String] = Suspend(&lt;function0&gt;)
</span>
<span class="n">task</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect
//=&gt; Hello!
</span>
<span class="n">task</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect
//=&gt; Hello!
</span></code></pre></div></div>

<p>NOTE: for Scalaz converts, this function is also aliased as <code class="highlighter-rouge">Task.suspend</code>.</p>

<h3 id="taskfromfuture">Task.fromFuture</h3>

<p><code class="highlighter-rouge">Task.fromFuture</code> can convert any Scala <code class="highlighter-rouge">Future</code> instance into a <code class="highlighter-rouge">Task</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.Future</span>

<span class="k">val</span> <span class="n">future</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">fromFuture</span><span class="o">(</span><span class="n">future</span><span class="o">)</span>
<span class="c1">//=&gt; Effect
</span>
<span class="n">task</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!
</span><span class="n">task</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!
</span></code></pre></div></div>

<p>Note that <code class="highlighter-rouge">fromFuture</code> takes a strict argument and that may not be
what you want. You might want a factory of <code class="highlighter-rouge">Future</code>. The design of
<code class="highlighter-rouge">Task</code> however is to have fine-grained control over the evaluation
model, so in case you want a factory, you need to combine it with
<code class="highlighter-rouge">Task.defer</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">defer</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">future</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
  <span class="nc">Task</span><span class="o">.</span><span class="n">fromFuture</span><span class="o">(</span><span class="n">future</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">//=&gt; task: monix.eval.Task[Int] = Suspend(&lt;function0&gt;)
</span>
<span class="n">task</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect
//=&gt; Hello!
</span><span class="n">task</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect
//=&gt; Hello!
</span></code></pre></div></div>

<h3 id="taskdeferfuture">Task.deferFuture</h3>

<p>A <code class="highlighter-rouge">Future</code> reference is like a strict value, meaning that when you receive one,
whatever process that’s supposed to complete it has probably started already.</p>

<p>Therefore it makes sense to defer the evaluation of futures when building tasks:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">defer</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">future</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
  <span class="nc">Task</span><span class="o">.</span><span class="n">fromFuture</span><span class="o">(</span><span class="n">future</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>As a shortcut, you can also use the <code class="highlighter-rouge">deferFuture</code> builder, which is equivalent
with the above:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">deferFuture</span> <span class="o">{</span>
  <span class="nc">Future</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="taskdeferfutureaction">Task.deferFutureAction</h3>

<p>Wraps calls that generate <code class="highlighter-rouge">Future</code> results into <code class="highlighter-rouge">Task</code>, provided a
callback with an injected <code class="highlighter-rouge">Scheduler</code> to act as the necessary
<code class="highlighter-rouge">ExecutionContext</code>.</p>

<p>This builder helps with wrapping <code class="highlighter-rouge">Future</code>-enabled APIs that need an
implicit <code class="highlighter-rouge">ExecutionContext</code> to work. Consider this example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.</span><span class="o">{</span><span class="nc">ExecutionContext</span><span class="o">,</span> <span class="nc">Future</span><span class="o">}</span>

<span class="k">def</span> <span class="n">sumFuture</span><span class="o">(</span><span class="n">list</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Future</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="n">sum</span><span class="o">)</span>
</code></pre></div></div>

<p>We’d like to wrap this function into one that returns a lazy <code class="highlighter-rouge">Task</code>
that evaluates this sum every time it is called, because that’s how
tasks work best. However in order to invoke this function an
<code class="highlighter-rouge">ExecutionContext</code> is needed:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sumTask</span><span class="o">(</span><span class="n">list</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Task</span><span class="o">.</span><span class="n">deferFuture</span><span class="o">(</span><span class="n">sumFuture</span><span class="o">(</span><span class="n">list</span><span class="o">))</span>
</code></pre></div></div>

<p>But this is not only superfluous, but against the best practices of
using <code class="highlighter-rouge">Task</code>. The difference is that <code class="highlighter-rouge">Task</code> takes a <code class="highlighter-rouge">Scheduler</code>
(inheriting from <code class="highlighter-rouge">ExecutionContext</code>) only when <code class="highlighter-rouge">runToFuture</code> gets called,
but we don’t need it just for building a <code class="highlighter-rouge">Task</code> reference.  With
<code class="highlighter-rouge">deferFutureAction</code> we get to have an injected <code class="highlighter-rouge">Scheduler</code> in the
passed callback:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sumTask</span><span class="o">(</span><span class="n">list</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Task</span><span class="o">.</span><span class="n">deferFutureAction</span> <span class="o">{</span> <span class="k">implicit</span> <span class="n">scheduler</span> <span class="k">=&gt;</span>
    <span class="n">sumFuture</span><span class="o">(</span><span class="n">list</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Voilà! No more implicit <code class="highlighter-rouge">ExecutionContext</code> passed around.</p>

<h3 id="taskexecuteasync-taskasyncboundary-taskexecuteon">Task.executeAsync, Task.asyncBoundary, Task.executeOn</h3>

<p><code class="highlighter-rouge">Task.executeAsync</code> ensures an asynchronous boundary, forcing the fork of a
(logical) thread on execution. Sometimes we are doing something really
wasteful and we want to guarantee that an asynchronous boundary
happens, given that by default
the <a href="../execution/scheduler.html#execution-model">execution model</a>
prefers to execute things on the current thread, at first.</p>

<p>So this guarantees that our task will get executed asynchronously:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">).</span><span class="n">executeAsync</span>
</code></pre></div></div>

<p>In fact that’s how <code class="highlighter-rouge">apply</code> is defined:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Task</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">fork</span><span class="o">(</span><span class="n">eval</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
  <span class="c1">//...
</span><span class="o">}</span>
</code></pre></div></div>

<p>ExecuteOn allows us to specify an alternative <code class="highlighter-rouge">Scheduler</code> to use.
You see, the run-loop of <code class="highlighter-rouge">Task</code> always has a <code class="highlighter-rouge">Scheduler</code> available, but
for certain operations you might want to divert the processing to an alternative
scheduler. For example you might want to execute blocking I/O operations
on an alternative thread-pool.</p>

<p>Lets assume we have 2 thread-pools:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The default scheduler
</span><span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>

<span class="c1">// Creating a special scheduler meant for I/O
</span><span class="k">import</span> <span class="nn">monix.execution.Scheduler</span>
<span class="k">lazy</span> <span class="k">val</span> <span class="n">io</span> <span class="k">=</span> <span class="nc">Scheduler</span><span class="o">.</span><span class="n">io</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"my-io"</span><span class="o">)</span>
</code></pre></div></div>

<p>Then we can manage what executes on which:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Override the default Scheduler by fork:
</span><span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Running on thread: ${Thread.currentThread.getName}"</span><span class="o">))</span>
<span class="k">val</span> <span class="n">forked</span> <span class="k">=</span> <span class="n">source</span><span class="o">.</span><span class="n">executeOn</span><span class="o">(</span><span class="n">io</span><span class="o">)</span>

<span class="n">source</span><span class="o">.</span><span class="n">runToFuture</span>
<span class="c1">//=&gt; Running on thread: ForkJoinPool-1-worker-1
</span><span class="n">forked</span><span class="o">.</span><span class="n">runToFuture</span>
<span class="c1">//=&gt; Running on thread: my-io-4
</span></code></pre></div></div>

<p>Note that, unless another asynchronous boundary is scheduled on the
default <code class="highlighter-rouge">Scheduler</code>, execution remains on the last scheduler (thread-pool)
used. Notice what happens in this combination:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">onFinish</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(</span>
  <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Ends on thread: ${Thread.currentThread.getName}"</span><span class="o">)</span>
<span class="o">)</span>

<span class="k">val</span> <span class="n">cancelable</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">source</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">forked</span><span class="o">)</span>
    <span class="o">.</span><span class="n">doOnFinish</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">onFinish</span><span class="o">)</span>
    <span class="o">.</span><span class="n">runToFuture</span>
<span class="o">}</span>

<span class="c1">//=&gt; Running on thread: ForkJoinPool-1-worker-7
//=&gt; Running on thread: my-io-1
//=&gt; Ends on thread: my-io-1
</span></code></pre></div></div>

<p>But if we insert another async boundary, then it switches back
to the default:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">asyncBoundary</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">executeAsync</span>
<span class="k">val</span> <span class="n">onFinish</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(</span>
  <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Ends on thread: ${Thread.currentThread.getName}"</span><span class="o">))</span>

<span class="k">val</span> <span class="n">cancelable</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">source</span> <span class="c1">// executes on global
</span>    <span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">forked</span><span class="o">)</span> <span class="c1">// executes on io
</span>    <span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">asyncBoundary</span><span class="o">)</span> <span class="c1">// switch back to global
</span>    <span class="o">.</span><span class="n">doOnFinish</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">onFinish</span><span class="o">)</span> <span class="c1">// executes on global
</span>    <span class="o">.</span><span class="n">runToFuture</span>
<span class="o">}</span>

<span class="c1">//=&gt; Running on thread: ForkJoinPool-1-worker-5
//=&gt; Running on thread: my-io-2
//=&gt; Ends on thread: ForkJoinPool-1-worker-5
</span></code></pre></div></div>

<p>But <code class="highlighter-rouge">Task</code> also provides a convenient operator for introducing an
asynchronous boundary without having to manually do this trick, called
<code class="highlighter-rouge">Task.asyncBoundary</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">source</span> <span class="c1">// executes on global
</span>    <span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">forked</span><span class="o">)</span> <span class="c1">// executes on io
</span>    <span class="o">.</span><span class="n">asyncBoundary</span> <span class="c1">// switch back to global
</span>    <span class="o">.</span><span class="n">doOnFinish</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">onFinish</span><span class="o">)</span> <span class="c1">// executes on global
</span>    <span class="o">.</span><span class="n">runToFuture</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that overriding of the scheduler can only happen once, as
<code class="highlighter-rouge">Task</code> instances are immutable, so the following does not work,
because for the <code class="highlighter-rouge">forked</code> instance the <code class="highlighter-rouge">Scheduler</code> was already
set in stone and we only have flexibility to override the
default if it hasn’t been overridden already:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Trying to execute on global
</span><span class="n">forked</span><span class="o">.</span><span class="n">executeOn</span><span class="o">(</span><span class="n">global</span><span class="o">).</span><span class="n">runToFuture</span>
<span class="c1">//=&gt; Running on thread: my-io-4
</span></code></pre></div></div>

<p><strong>General advice:</strong> unless you’re doing blocking I/O, keep using
the default thread-pool, with <code class="highlighter-rouge">global</code> being a good default.
For blocking I/O it is OK to have a second thread-pool,
but isolate those I/O operations and only override the scheduler
for actual I/O operations.</p>

<h3 id="taskraiseerror">Task.raiseError</h3>

<p><code class="highlighter-rouge">Task.raiseError</code> can lift errors in the monadic context of <code class="highlighter-rouge">Task</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="k">val</span> <span class="n">error</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">new</span> <span class="nc">TimeoutException</span><span class="o">)</span>
<span class="c1">// error: monix.eval.Task[Int] =
//   Delay(Error(java.util.concurrent.TimeoutException))
</span>
<span class="n">error</span><span class="o">.</span><span class="n">runAsync</span><span class="o">(</span><span class="n">result</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">result</span><span class="o">))</span>
<span class="c1">//=&gt; Left(java.util.concurrent.TimeoutException)
</span></code></pre></div></div>

<h3 id="tasknever">Task.never</h3>

<p><code class="highlighter-rouge">Task.never</code> returns a <code class="highlighter-rouge">Task</code> instance that never completes:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="c1">// A Task instance that never completes
</span><span class="k">val</span> <span class="n">never</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">never</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="k">val</span> <span class="n">timedOut</span> <span class="k">=</span> <span class="n">never</span><span class="o">.</span><span class="n">timeoutTo</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">,</span>
  <span class="nc">Task</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">TimeoutException</span><span class="o">))</span>

<span class="n">timedOut</span><span class="o">.</span><span class="n">runAsync</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">// After 3 seconds:
// =&gt; Left(java.util.concurrent.TimeoutException)
</span></code></pre></div></div>

<p>This instance is shared, so that can relieve some stress from the
garbage collector.</p>

<h3 id="taskunit">Task.unit</h3>

<p><code class="highlighter-rouge">Task.unit</code> is returning an already completed <code class="highlighter-rouge">Task[Unit]</code> instance,
provided as a utility, to spare you creating new instances with
<code class="highlighter-rouge">Task.now(())</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">unit</span>
<span class="c1">// task: monix.eval.Task[Unit] = Delay(Now(()))
</span></code></pre></div></div>

<p>This instance is shared, so that can relieve some stress from the
garbage collector.</p>

<h2 id="asynchronous-builders">Asynchronous Builders</h2>

<p>You can use any async API to build a <code class="highlighter-rouge">Task</code>. There’s an unsafe
version, for people knowing what they are doing and a safe version, that
handles some of the nitty-gritty automatically.</p>

<h3 id="taskcreate">Task.create</h3>

<p>Also known as <code class="highlighter-rouge">Task.async</code> (for Scalaz refugees), the <code class="highlighter-rouge">Task.create</code>
function allows for creating an asynchronous <code class="highlighter-rouge">Task</code> using a
callback-based API. For example, let’s create a utility that evaluates
expressions with a given delay:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Try</span>
<span class="k">import</span> <span class="nn">concurrent.duration._</span>

<span class="k">def</span> <span class="n">evalDelayed</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">delay</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="c1">// On execution, we have the scheduler and
</span>  <span class="c1">// the callback injected ;-)
</span>  <span class="nc">Task</span><span class="o">.</span><span class="n">create</span> <span class="o">{</span> <span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">callback</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">cancelable</span> <span class="k">=</span>
      <span class="n">scheduler</span><span class="o">.</span><span class="n">scheduleOnce</span><span class="o">(</span><span class="n">delay</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">callback</span><span class="o">(</span><span class="nc">Try</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
      <span class="o">}</span>

    <span class="c1">// We must return something that can
</span>    <span class="c1">// cancel the async computation
</span>    <span class="n">cancelable</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And here’s a possible implementation of
<a href="#taskfromfuture">Task.fromFuture</a>, in case you choose to implement it
yourself:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Cancelable</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Future</span>
<span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>

<span class="k">def</span> <span class="n">fromFuture</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Task</span><span class="o">.</span><span class="n">create</span> <span class="o">{</span> <span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">callback</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">f</span><span class="o">.</span><span class="n">onComplete</span><span class="o">({</span>
      <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">callback</span><span class="o">.</span><span class="n">onSuccess</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
      <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">callback</span><span class="o">.</span><span class="n">onError</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>
    <span class="o">})(</span><span class="n">scheduler</span><span class="o">)</span>

    <span class="c1">// Scala Futures are not cancelable, so
</span>    <span class="c1">// we shouldn't pretend that they are!
</span>    <span class="nc">Cancelable</span><span class="o">.</span><span class="n">empty</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Some notes:</p>

<ul>
  <li>Tasks created with this builder are guaranteed to execute
asynchronously (on another logical thread)</li>
  <li>The <a href="../execution/scheduler.html">Scheduler</a> gets injected and with
it we can schedule things for async execution, we can delay,
etc…</li>
  <li>But as said, this callback will already execute asynchronously, so
you don’t need to explicitly schedule things to run on the provided
<code class="highlighter-rouge">Scheduler</code>, unless you really need to do it.</li>
  <li><a href="(../execution/callback.html)">The Callback</a> gets injected on execution and that
callback has a contract. In particular you need to execute
<code class="highlighter-rouge">onSuccess</code> or <code class="highlighter-rouge">onError</code> or <code class="highlighter-rouge">apply</code> only once. The implementation
does a reasonably good job to protect against contract violations,
but if you do call it multiple times, then you’re doing it risking
undefined and nondeterministic behavior.</li>
  <li>It’s OK to return a <code class="highlighter-rouge">Cancelable.empty</code> in case the executed
process really can’t be canceled in time, but you should strive to
return a cancelable that does cancel your execution, if possible.</li>
</ul>

<h2 id="memoization">Memoization</h2>

<p>The
<a href="/api/3.0/monix/eval/Task.html#memoize:monix.eval.Task[A]">Task#memoize</a>
operator can take any <code class="highlighter-rouge">Task</code> and apply memoization on the first <code class="highlighter-rouge">runToFuture</code>,
such that:</p>

<ol>
  <li>you have guaranteed idempotency, calling <code class="highlighter-rouge">runToFuture</code> multiple times
will have the same effect as calling it once</li>
  <li>subsequent <code class="highlighter-rouge">runToFuture</code> calls will reuse the result computed by the
first <code class="highlighter-rouge">runToFuture</code></li>
</ol>

<p>So <code class="highlighter-rouge">memoize</code> effectively caches the result of the first <code class="highlighter-rouge">runToFuture</code>.
In fact we can say that:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Task</span><span class="o">.</span><span class="n">evalOnce</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">&lt;-&gt;</span> <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">memoize</span>
</code></pre></div></div>

<p>They are effectively the same.  And <code class="highlighter-rouge">memoize</code> works
with any task reference:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Has async execution, to do the .apply semantics
</span><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>

<span class="k">val</span> <span class="n">memoized</span> <span class="k">=</span> <span class="n">task</span><span class="o">.</span><span class="n">memoize</span>

<span class="n">memoized</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect
//=&gt; Hello!
</span>
<span class="n">memoized</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!
</span></code></pre></div></div>

<h3 id="memoize-only-on-success">Memoize Only on Success</h3>

<p>Sometimes you just want memoization, along with idempotency
guarantees, only for successful values. For failures you might want to
keep retrying until a successful value is available.</p>

<p>This is where the <code class="highlighter-rouge">memoizeOnSuccess</code> operator comes in handy:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">effect</span> <span class="k">=</span> <span class="mi">0</span>

<span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span> <span class="o">{</span>
  <span class="n">effect</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">effect</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="s">"dummy"</span><span class="o">)</span> <span class="k">else</span> <span class="n">effect</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">cached</span> <span class="k">=</span> <span class="n">source</span><span class="o">.</span><span class="n">memoizeOnSuccess</span>

<span class="k">val</span> <span class="n">f1</span> <span class="k">=</span> <span class="n">cached</span><span class="o">.</span><span class="n">runToFuture</span> <span class="c1">// yields RuntimeException
</span><span class="k">val</span> <span class="n">f2</span> <span class="k">=</span> <span class="n">cached</span><span class="o">.</span><span class="n">runToFuture</span> <span class="c1">// yields RuntimeException
</span><span class="k">val</span> <span class="n">f3</span> <span class="k">=</span> <span class="n">cached</span><span class="o">.</span><span class="n">runToFuture</span> <span class="c1">// yields 3
</span><span class="k">val</span> <span class="n">f4</span> <span class="k">=</span> <span class="n">cached</span><span class="o">.</span><span class="n">runToFuture</span> <span class="c1">// yields 3
</span></code></pre></div></div>

<h3 id="memoize-versus-runtofuture">Memoize versus runToFuture</h3>

<p>You can say that when we do this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="k">val</span> <span class="n">future</span> <span class="k">=</span> <span class="n">task</span><span class="o">.</span><span class="n">runToFuture</span>
</code></pre></div></div>

<p>That <code class="highlighter-rouge">future</code> instance is also going to be a memoized value of the
first <code class="highlighter-rouge">runToFuture</code> execution, which can be reused for other <code class="highlighter-rouge">onComplete</code>
subscribers.</p>

<p>The difference is the same as the difference between <code class="highlighter-rouge">Task</code> and
<code class="highlighter-rouge">Future</code>. The <code class="highlighter-rouge">memoize</code> operation is lazy, evaluation only being
triggered on the first <code class="highlighter-rouge">runToFuture</code>, whereas the result of <code class="highlighter-rouge">runToFuture</code> is
eager.</p>

<h2 id="operations">Operations</h2>

<h3 id="flatmap-and-tail-recursive-loops">FlatMap and Tail-Recursive Loops</h3>

<p>So let’s start with a stupid example that calculates the N-th number in
the Fibonacci sequence:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.annotation.tailrec</span>

<span class="nd">@tailrec</span>
<span class="k">def</span> <span class="n">fib</span><span class="o">(</span><span class="n">cycles</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="o">{</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">cycles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
   <span class="n">fib</span><span class="o">(</span><span class="n">cycles</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>
 <span class="k">else</span>
   <span class="n">b</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We need this to be tail-recursive, hence the use of the
<a href="http://www.scala-lang.org/api/current/index.html#scala.annotation.tailrec">@tailrec</a>
annotation from Scala’s standard library. And if we’d describe it with
<code class="highlighter-rouge">Task</code>, one possible implementation would be:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">fib</span><span class="o">(</span><span class="n">cycles</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">BigInt</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">cycles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
   <span class="nc">Task</span><span class="o">.</span><span class="n">defer</span><span class="o">(</span><span class="n">fib</span><span class="o">(</span><span class="n">cycles</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">))</span>
 <span class="k">else</span>
   <span class="nc">Task</span><span class="o">.</span><span class="n">now</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And now there are already differences. This is lazy, as the N-th
Fibonacci number won’t get calculated until we <code class="highlighter-rouge">runToFuture</code>. The
<code class="highlighter-rouge">@tailrec</code> annotation is also not needed, as this is stack (and heap)
safe.</p>

<p><code class="highlighter-rouge">Task</code> has <code class="highlighter-rouge">flatMap</code>, which is the monadic <code class="highlighter-rouge">bind</code> operation, that for
things like <code class="highlighter-rouge">Task</code> and <code class="highlighter-rouge">Future</code> is the operation that describes
recursivity or that forces ordering (e.g. execute this, then that,
then that). And we can use it to describe recursive calls:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">fib</span><span class="o">(</span><span class="n">cycles</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">BigInt</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(</span><span class="n">cycles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span>
      <span class="n">fib</span><span class="o">(</span><span class="n">cycles</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">)</span>
    <span class="k">case</span> <span class="kc">false</span> <span class="k">=&gt;</span>
      <span class="nc">Task</span><span class="o">.</span><span class="n">now</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Again, this is stack safe and uses a constant amount of memory, so no
<code class="highlighter-rouge">@tailrec</code> annotation is needed or wanted. And it has lazy behavior,
as nothing will get triggered until <code class="highlighter-rouge">runToFuture</code> happens.</p>

<p>But we can also have <strong>mutually tail-recursive calls</strong>, w00t!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Mutual Tail Recursion, ftw!!!
</span><span class="o">{</span>
  <span class="k">def</span> <span class="n">odd</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span>
      <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">.</span><span class="n">now</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>
      <span class="k">case</span> <span class="kc">false</span> <span class="k">=&gt;</span> <span class="n">even</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="k">def</span> <span class="n">even</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span>
      <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">.</span><span class="n">now</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
      <span class="k">case</span> <span class="kc">false</span> <span class="k">=&gt;</span> <span class="n">odd</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="n">even</span><span class="o">(</span><span class="mi">1000000</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Again, this is stack safe and uses a constant amount of memory.  And
best of all, because of the
<a href="../execution/scheduler.html#execution-model">execution model</a>, by
default these loops won’t block the current thread forever, preferring to
execute things in batches.</p>

<h3 id="parallelism-catsparallel">Parallelism (cats.Parallel)</h3>

<p>When using <code class="highlighter-rouge">flatMap</code>, we often end up with this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">locationTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(???)</span>
<span class="k">val</span> <span class="n">phoneTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(???)</span>
<span class="k">val</span> <span class="n">addressTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(???)</span>

<span class="c1">// Ordered operations based on flatMap ...
</span><span class="k">val</span> <span class="n">aggregate</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">location</span> <span class="k">&lt;-</span> <span class="n">locationTask</span>
  <span class="n">phone</span> <span class="k">&lt;-</span> <span class="n">phoneTask</span>
  <span class="n">address</span> <span class="k">&lt;-</span> <span class="n">addressTask</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">{</span>
  <span class="s">"Gotcha!"</span>
<span class="o">}</span>
</code></pre></div></div>

<p>For one the problem here is that these operations are executed in
order. This also happens with Scala’s standard <code class="highlighter-rouge">Future</code>, being
sometimes an unwanted effect, but because <code class="highlighter-rouge">Task</code> is lazily evaluated,
this effect is even more pronounced with <code class="highlighter-rouge">Task</code>.</p>

<p>But <code class="highlighter-rouge">Task</code> also has a
<a href="https://typelevel.org/cats/typeclasses/parallel.html">cats.Parallel</a>
implementation, being able to trigger evaluation of multiple
tasks in parallel and hence it has utilities, such
as <code class="highlighter-rouge">parZip2</code>, <code class="highlighter-rouge">parZip3</code>, up until <code class="highlighter-rouge">parZip6</code> (at the moment of writing). 
The example above could be written as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">locationTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(???)</span>
<span class="k">val</span> <span class="n">phoneTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(???)</span>
<span class="k">val</span> <span class="n">addressTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(???)</span>

<span class="c1">// Potentially executed in parallel
</span><span class="k">val</span> <span class="n">aggregate</span> <span class="k">=</span>
  <span class="nc">Task</span><span class="o">.</span><span class="n">parZip3</span><span class="o">(</span><span class="n">locationTask</span><span class="o">,</span> <span class="n">phoneTask</span><span class="o">,</span> <span class="n">addressTask</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">location</span><span class="o">,</span> <span class="n">phone</span><span class="o">,</span> <span class="n">address</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"Gotcha!"</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>In order to avoid boxing into tuples, you can also use <code class="highlighter-rouge">parMap2</code>,
<code class="highlighter-rouge">parMap3</code> … <code class="highlighter-rouge">parMap6</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Task</span><span class="o">.</span><span class="n">parMap3</span><span class="o">(</span><span class="n">locationTask</span><span class="o">,</span> <span class="n">phoneTask</span><span class="o">,</span> <span class="n">addressTask</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">(</span><span class="n">location</span><span class="o">,</span> <span class="n">phone</span><span class="o">,</span> <span class="n">address</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"Gotcha!"</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And you can use Cats’ syntax for <code class="highlighter-rouge">parMapN</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.syntax.all._</span>

<span class="o">(</span><span class="n">locationTask</span><span class="o">,</span> <span class="n">phoneTask</span><span class="o">,</span> <span class="n">addressTask</span><span class="o">).</span><span class="n">parMapN</span> <span class="o">{</span>
  <span class="o">(</span><span class="n">location</span><span class="o">,</span> <span class="n">phone</span><span class="o">,</span> <span class="n">address</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"Gotcha!"</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Also see the documentation for
<a href="https://typelevel.org/cats/typeclasses/parallel.html">cats.Parallel</a>.</p>

<h3 id="gather-results-from-a-seq-of-tasks">Gather results from a Seq of Tasks</h3>

<p><code class="highlighter-rouge">Task.sequence</code>, takes a <code class="highlighter-rouge">Seq[Task[A]]</code> and returns a <code class="highlighter-rouge">Task[Seq[A]]</code>,
thus transforming any sequence of tasks into a task with a sequence of
results and with ordered effects and results. This means that the
tasks WILL NOT execute in parallel.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">ta</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect1"</span><span class="o">);</span> <span class="mi">1</span> <span class="o">}</span>
<span class="k">val</span> <span class="n">tb</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect2"</span><span class="o">);</span> <span class="mi">2</span> <span class="o">}</span>

<span class="k">val</span> <span class="n">list</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Task</span><span class="o">.</span><span class="n">sequence</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">))</span>

<span class="c1">// We always get this ordering:
</span><span class="n">list</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect1
//=&gt; Effect2
//=&gt; List(1, 2)
</span></code></pre></div></div>

<p>The results are ordered in the order of the initial sequence, so that
means in the example above we are guaranteed in the result to first
get the result of <code class="highlighter-rouge">ta</code> (the first task) and then the result of <code class="highlighter-rouge">tb</code>
(the second task). The execution itself is also ordered, so <code class="highlighter-rouge">ta</code>
executes and completes before <code class="highlighter-rouge">tb</code>.</p>

<p><code class="highlighter-rouge">Task.gather</code>, similar to <code class="highlighter-rouge">Parallel.parSequence</code>, is the nondeterministic
version of <code class="highlighter-rouge">Task.sequence</code>.  It also takes a <code class="highlighter-rouge">Seq[Task[A]]</code> and
returns a <code class="highlighter-rouge">Task[Seq[A]]</code>, thus transforming any sequence of tasks into
a task with a sequence of ordered results. But the effects are not
ordered, meaning that there’s potential for parallel execution:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="n">ta</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect1"</span><span class="o">);</span> <span class="mi">1</span> <span class="o">}</span>
    <span class="o">.</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">tb</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect2"</span><span class="o">);</span> <span class="mi">2</span> <span class="o">}</span>
    <span class="o">.</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">list</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">gather</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">))</span>

<span class="n">list</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect1
//=&gt; Effect2
//=&gt; List(1, 2)
</span>
<span class="n">list</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect2
//=&gt; Effect1
//=&gt; List(1, 2)
</span></code></pre></div></div>

<p><code class="highlighter-rouge">Task.gatherUnordered</code> is like <code class="highlighter-rouge">gather</code>, except that you don’t get
ordering for results or effects. The result is thus highly nondeterministic,
but yields better performance than <code class="highlighter-rouge">gather</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="n">ta</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect1"</span><span class="o">);</span> <span class="mi">1</span> <span class="o">}</span>
    <span class="o">.</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">tb</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect2"</span><span class="o">);</span> <span class="mi">2</span> <span class="o">}</span>
    <span class="o">.</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">list</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Task</span><span class="o">.</span><span class="n">gatherUnordered</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">))</span>

<span class="n">list</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect2
//=&gt; Effect1
//=&gt; Seq(2,1)
</span>
<span class="n">list</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect1
//=&gt; Effect2
//=&gt; Seq(1,2)
</span></code></pre></div></div>

<p><code class="highlighter-rouge">Task.traverse</code>, takes a <code class="highlighter-rouge">Seq[A]</code>, <code class="highlighter-rouge">f: A =&gt; Task[B]</code> and returns a <code class="highlighter-rouge">Task[Seq[B]]</code>.
This is similar to <code class="highlighter-rouge">Task.sequence</code> but it uses <code class="highlighter-rouge">f</code> to generate each <code class="highlighter-rouge">Task</code>.</p>

<p>All <code class="highlighter-rouge">Task.sequence</code> semantics hold meaning the effects are ordered and the tasks
WIL NOT execute in parallel.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">task</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect"</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span> <span class="n">i</span> <span class="o">}</span>

<span class="k">val</span> <span class="n">list</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Task</span><span class="o">.</span><span class="n">traverse</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">))(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">task</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>

<span class="c1">// We always get this ordering:
</span><span class="n">list</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect1
//=&gt; Effect2
//=&gt; List(1, 2)
</span></code></pre></div></div>

<p><code class="highlighter-rouge">Task.wander</code>, similar to <code class="highlighter-rouge">Parallel.parTraverse</code>, is the nondeterministic
version of <code class="highlighter-rouge">Task.traverse</code>.  It also takes a <code class="highlighter-rouge">Seq[A]</code>, <code class="highlighter-rouge">f: A =&gt; Task[B]</code> and
returns a <code class="highlighter-rouge">Task[Seq[B]]</code>. It applies <code class="highlighter-rouge">f</code> to each element in the sequence transforming it
into <code class="highlighter-rouge">Task</code> and then collecting results. The order in the output sequence is preserved but 
the effects are not ordered, meaning that there’s potential for parallel execution:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">def</span> <span class="n">task</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> 
  <span class="nc">Task</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Effect"</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span> <span class="n">i</span> <span class="o">}.</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="n">list</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">wander</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">))(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">task</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>

<span class="n">list</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect1
//=&gt; Effect2
//=&gt; List(1, 2)
</span>
<span class="n">list</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect2
//=&gt; Effect1
//=&gt; List(1, 2)
</span></code></pre></div></div>

<p>Similar to <code class="highlighter-rouge">gather</code> there is also unordered version called <code class="highlighter-rouge">wanderUnordered</code>.</p>

<p><strong>NOTE:</strong> If you have the possibility, prefer explicitly using <code class="highlighter-rouge">Task</code> operators instead of
those provided by Cats syntax. Their default implementations are derived from other
methods and are often much slower than optimized <code class="highlighter-rouge">Task</code> versions.</p>

<p>Refer to the table below to see corresponding methods:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Monix</th>
      <th style="text-align: center">Cats</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Task.sequence</td>
      <td style="text-align: center">Traverse[F].sequence</td>
    </tr>
    <tr>
      <td style="text-align: center">Task.traverse</td>
      <td style="text-align: center">Traverse[F].traverse</td>
    </tr>
    <tr>
      <td style="text-align: center">Task.gather</td>
      <td style="text-align: center">Parallel.parSequence</td>
    </tr>
    <tr>
      <td style="text-align: center">Task.wander</td>
      <td style="text-align: center">Parallel.parTraverse</td>
    </tr>
  </tbody>
</table>

<h3 id="race">Race</h3>

<p>The <code class="highlighter-rouge">racePair</code> operation will choose the winner between two
<code class="highlighter-rouge">Task</code> that will potentially run in parallel:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="n">ta</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="n">tb</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="n">race</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">racePair</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">).</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Left</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">fiber</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">fiber</span><span class="o">.</span><span class="n">cancel</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"A succeeded: $a"</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="k">case</span> <span class="nc">Right</span><span class="o">((</span><span class="n">fiber</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">fiber</span><span class="o">.</span><span class="n">cancel</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"B succeeded: $b"</span><span class="o">))</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The result generated will be an <code class="highlighter-rouge">Either</code> of tuples, giving you the
opportunity to do something with the other task that lost the race.
You can cancel it, or you can use its result somehow, or you can
simply ignore it, your choice depending on use-case.</p>

<h3 id="race-many">Race Many</h3>

<p>The <code class="highlighter-rouge">raceMany</code> operation takes as input a list of tasks,
and upon execution will generate the result of the first task
that completes and wins the race:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="n">ta</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="n">tb</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="o">{</span>
  <span class="nc">Task</span><span class="o">.</span><span class="n">raceMany</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">))</span>
    <span class="o">.</span><span class="n">runToFuture</span>
    <span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Winner: $r"</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It is similar to Scala’s
<a href="http://www.scala-lang.org/api/current/index.html#scala.concurrent.Future$@firstCompletedOf[T](futures:TraversableOnce[scala.concurrent.Future[T]])(implicitexecutor:scala.concurrent.ExecutionContext):scala.concurrent.Future[T]">Future.firstCompletedOf</a>
operation, except that it operates on <code class="highlighter-rouge">Task</code> and upon execution it has
a better model, as when a task wins the race the other tasks get
immediately canceled.</p>

<h3 id="delay-execution">Delay Execution</h3>

<p><code class="highlighter-rouge">Task.delayExecution</code>, as the name says, delays the execution of a
given task by the given timespan.</p>

<p>In this example we are delaying the execution of the source by 3
seconds:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">"Side-effect!"</span><span class="o">)</span>
  <span class="s">"Hello, world!"</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">delayed</span> <span class="k">=</span> <span class="n">source</span><span class="o">.</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>
<span class="n">delayed</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div></div>

<p>Or, instead of a delay we might want to use another <code class="highlighter-rouge">Task</code> as the
signal for starting the execution, so the following example is
equivalent to the one above:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">trigger</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>

<span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">"Side-effect!"</span><span class="o">)</span>
  <span class="s">"Hello, world!"</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">delayed</span> <span class="k">=</span> <span class="n">source</span><span class="o">.</span><span class="n">delayExecutionWith</span><span class="o">(</span><span class="n">trigger</span><span class="o">)</span>
<span class="n">delayed</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="delay-signaling-of-the-result">Delay Signaling of the Result</h3>

<p><code class="highlighter-rouge">Task.delayResult</code> delays the signaling of the result, but not the
execution of the <code class="highlighter-rouge">Task</code>. Consider this example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">"Side-effect!"</span><span class="o">)</span>
  <span class="s">"Hello, world!"</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">delayed</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">source</span>
    <span class="o">.</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
    <span class="o">.</span><span class="n">delayResult</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">delayed</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div></div>

<p>Here, you’ll see the “side-effect happening after only 1 second, but
the signaling of the result will happen after another 5 seconds.</p>

<p>There’s also another variant called <code class="highlighter-rouge">delayResultBySelector</code>, where you
can have another task signal the right moment when to signal the
result downstream. This allows to customize the delay based on the
result signaled by the source:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">"Side-effect!"</span><span class="o">)</span>
  <span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">selector</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Task</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">delayExecution</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">seconds</span><span class="o">)</span>

<span class="k">val</span> <span class="n">delayed</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">source</span>
    <span class="o">.</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
    <span class="o">.</span><span class="n">delayResultBySelector</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">selector</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="o">}</span>

<span class="n">delayed</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span>
  <span class="n">println</span><span class="o">(</span>
    <span class="n">s</span><span class="s">"Result: $x "</span> <span class="o">+</span>
    <span class="n">s</span><span class="s">"(signaled after at least ${x+1} seconds)"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="restart-until-predicate-is-true">Restart Until Predicate is True</h3>

<p>The <code class="highlighter-rouge">Task</code> being a spec, we can restart it at will.
<code class="highlighter-rouge">Task.restartUntil(predicate)</code> does just that, executing the source
over and over again, until the given predicate is true:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">val</span> <span class="n">randomEven</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(</span><span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">())</span>
    <span class="o">.</span><span class="n">restartUntil</span><span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">randomEven</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; -2097793116
</span><span class="n">randomEven</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; 1246761488
</span><span class="n">randomEven</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; 1053678416
</span></code></pre></div></div>

<h3 id="clean-up-resources-on-finish">Clean-up Resources on Finish</h3>

<p><code class="highlighter-rouge">Task.doOnFinish</code> executes the supplied
<code class="highlighter-rouge">Option[Throwable] =&gt; Task[Unit]</code> function when the source finishes,
being meant for cleaning up resources or executing
some scheduled side-effect:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="k">val</span> <span class="n">withFinishCb</span> <span class="k">=</span> <span class="n">task</span><span class="o">.</span><span class="n">doOnFinish</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"Was success!"</span><span class="o">)</span>
    <span class="nc">Task</span><span class="o">.</span><span class="n">unit</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Had failure: $ex"</span><span class="o">)</span>
    <span class="nc">Task</span><span class="o">.</span><span class="n">unit</span>
<span class="o">}</span>

<span class="n">withFinishCb</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Was success!
//=&gt; 1
</span></code></pre></div></div>

<h3 id="convert-to-reactive-publisher">Convert to Reactive Publisher</h3>

<p>Did you know that Monix integrates with the
<a href="http://www.reactive-streams.org/">Reactive Streams</a>
specification?</p>

<p>Well, <code class="highlighter-rouge">Task</code> can be seen as an <code class="highlighter-rouge">org.reactivestreams.Publisher</code> that
emits exactly one event upon subscription and then stops. And we can
convert any <code class="highlighter-rouge">Task</code> to such a publisher directly:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">eval</span><span class="o">(</span><span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">())</span>

<span class="k">val</span> <span class="n">publisher</span><span class="k">:</span> <span class="kt">org.reactivestreams.Publisher</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">task</span><span class="o">.</span><span class="n">toReactivePublisher</span>
</code></pre></div></div>

<p>This is meant for interoperability purposes with other libraries, but
if you’re inclined to use it directly, it’s a little lower level,
but doable:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">org.reactivestreams._</span>

<span class="n">publisher</span><span class="o">.</span><span class="n">subscribe</span><span class="o">(</span><span class="k">new</span> <span class="nc">Subscriber</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">onSubscribe</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Subscription</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">s</span><span class="o">.</span><span class="n">request</span><span class="o">(</span><span class="nc">Long</span><span class="o">.</span><span class="nc">MaxValue</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">onNext</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"OnNext: $e"</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">onComplete</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"OnComplete"</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">onError</span><span class="o">(</span><span class="n">ex</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="nc">System</span><span class="o">.</span><span class="n">err</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"ERROR: $ex"</span><span class="o">)</span>
<span class="o">})</span>

<span class="c1">// Will print:
//=&gt; OnNext: -228329246
//=&gt; OnComplete
</span></code></pre></div></div>

<p>Awesome, isn’t it?</p>

<p>(◑‿◐)</p>

<h2 id="error-handling">Error Handling</h2>

<p><code class="highlighter-rouge">Task</code> takes error handling very seriously. You see, there’s this famous
<a href="https://en.wikipedia.org/wiki/If_a_tree_falls_in_a_forest">thought experiment</a>
regarding <em>observation</em>:</p>

<blockquote>
  <p>“<em>If a tree falls in a forest and no one is around to hear it, does
it make a sound?</em>”</p>
</blockquote>

<p>Now this applies very well to error handling, because if an error is
triggered by an asynchronous process and there’s nobody to hear it, no
handler to catch it and log it or recover from it, then it didn’t
happen. And what you’ll get is
<a href="https://en.wikipedia.org/wiki/Nondeterministic_algorithm">nondeterminism</a>
without any hints of the error involved.</p>

<p>This is why Monix will always attempt to catch and signal or at least
log any errors that happen. In case signaling is not possible for
whatever reason (like the callback was already called), then the
logging is done by means of the provided <code class="highlighter-rouge">Scheduler.reportFailure</code>,
which defaults to <code class="highlighter-rouge">System.err</code>, unless you provide something more
concrete, like going through SLF4J or whatever.</p>

<p>Even though Monix expects for the arguments given to its operators,
like <code class="highlighter-rouge">flatMap</code>, to be pure or at least protected from errors, it still
catches errors, signaling them on <code class="highlighter-rouge">runAsync</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">even</span> <span class="k">if</span> <span class="n">even</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">=&gt;</span>
    <span class="nc">Task</span><span class="o">.</span><span class="n">now</span><span class="o">(</span><span class="n">even</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">odd</span> <span class="k">=&gt;</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="n">odd</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">task</span><span class="o">.</span><span class="n">runAsync</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">//=&gt; Left(-924040280)
</span>
<span class="n">task</span><span class="o">.</span><span class="n">runAsync</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">//=&gt; Right(java.lang.IllegalStateException: 834919637)
</span></code></pre></div></div>

<p>In case an error happens in the callback provided to <code class="highlighter-rouge">runAsync</code>, then
Monix can no longer signal an <code class="highlighter-rouge">onError</code>, because it would be a
contract violation (see <a href="(../execution/callback.html)">Callback</a>). But it still
logs the error:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="c1">// Ensures asynchronous execution, just to show
// that the action doesn't happen on the
// current thread
</span><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="n">task</span><span class="o">.</span><span class="n">runAsync</span> <span class="o">{</span> <span class="n">r</span> <span class="k">=&gt;</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// After 1 second, this will log the whole stack trace:
//=&gt; java.lang.IllegalStateException: Right(2)
//=&gt;    ...
//=&gt;	at monix.eval.Task$$anon$3.onSuccess(Task.scala:78)
//=&gt;	at monix.eval.Callback$SafeCallback.onSuccess(Callback.scala:66)
//=&gt;	at monix.eval.Task$.trampoline$1(Task.scala:1248)
//=&gt;	at monix.eval.Task$.monix$eval$Task$$resume(Task.scala:1304)
//=&gt;	at monix.eval.Task$AsyncStateRunnable$$anon$20.onSuccess(Task.scala:1432)
//=&gt;    ....
</span></code></pre></div></div>

<p>Similarly, when using <code class="highlighter-rouge">Task.create</code>, Monix attempts to catch any
uncaught errors, but because we did not know what happened in the
provided callback, we cannot signal the error as it would be a
contract violation (see <a href="(../execution/callback.html)">Callback</a>), but Monix does
log the error:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">create</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span> <span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">callback</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="o">(</span><span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="s">"FTW!"</span><span class="o">))</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">future</span> <span class="k">=</span> <span class="n">task</span><span class="o">.</span><span class="n">runToFuture</span>

<span class="c1">// Logs the following to System.err:
//=&gt; java.lang.IllegalStateException: FTW!
//=&gt;    ...
//=&gt; 	at monix.eval.Task$$anonfun$create$1.apply(Task.scala:576)
//=&gt; 	at monix.eval.Task$$anonfun$create$1.apply(Task.scala:571)
//=&gt; 	at monix.eval.Task$AsyncStateRunnable.run(Task.scala:1429)
//=&gt;    ...
</span>
<span class="c1">// The Future NEVER COMPLETES, OOPS!
</span><span class="n">future</span><span class="o">.</span><span class="n">onComplete</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
</code></pre></div></div>

<p><strong>WARNING:</strong> In this case the consumer side never gets a completion
signal. The moral of the story is: even if Monix makes a best effort
to do the right thing, you should protect your freaking code against
unwanted exceptions, especially in <code class="highlighter-rouge">Task.create</code>!!!</p>

<h3 id="overriding-the-error-logging">Overriding the Error Logging</h3>

<p>The article on <a href="../execution/scheduler.html">Scheduler</a> has recipes
for building your own <code class="highlighter-rouge">Scheduler</code> instances, with your own logic. But
here’s a quick snippet for building such a <code class="highlighter-rouge">Scheduler</code> that could do
logging by means of a library, such as the standard
<a href="http://www.slf4j.org/">SLF4J</a>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Scheduler</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.</span><span class="o">{</span><span class="n">global</span> <span class="k">=&gt;</span> <span class="n">default</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">monix.execution.UncaughtExceptionReporter</span>
<span class="k">import</span> <span class="nn">org.slf4j.LoggerFactory</span>

<span class="k">val</span> <span class="n">reporter</span> <span class="k">=</span> <span class="nc">UncaughtExceptionReporter</span> <span class="o">{</span> <span class="n">ex</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">logger</span> <span class="k">=</span> <span class="nc">LoggerFactory</span><span class="o">.</span><span class="n">getLogger</span><span class="o">(</span><span class="s">"monix"</span><span class="o">)</span>
  <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="s">"Uncaught exception"</span><span class="o">,</span> <span class="n">ex</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">global</span><span class="k">:</span> <span class="kt">Scheduler</span> <span class="o">=</span>
  <span class="nc">Scheduler</span><span class="o">(</span><span class="n">default</span><span class="o">,</span> <span class="n">reporter</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="trigger-a-timeout">Trigger a Timeout</h3>

<p>In case a <code class="highlighter-rouge">Task</code> is too slow to execute, we can cancel it and trigger
a <code class="highlighter-rouge">TimeoutException</code> using <code class="highlighter-rouge">Task.timeout</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="k">val</span> <span class="n">source</span> <span class="k">=</span>
  <span class="nc">Task</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">).</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span>

<span class="c1">// Triggers error if the source does not
// complete in 3 seconds after runAsync
</span><span class="k">val</span> <span class="n">timedOut</span> <span class="k">=</span> <span class="n">source</span><span class="o">.</span><span class="n">timeout</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>

<span class="n">timedOut</span><span class="o">.</span><span class="n">runAsync</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">//=&gt; Failure(TimeoutException)
</span></code></pre></div></div>

<p>On timeout the source gets canceled (if it’s a source that supports
cancelation). And instead of an error, we can timeout to a <code class="highlighter-rouge">fallback</code>
task. The following example is equivalent to the above one:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="k">val</span> <span class="n">source</span> <span class="k">=</span>
  <span class="nc">Task</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">).</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span>

<span class="k">val</span> <span class="n">timedOut</span> <span class="k">=</span> <span class="n">source</span><span class="o">.</span><span class="n">timeoutTo</span><span class="o">(</span>
  <span class="mf">3.</span><span class="n">seconds</span><span class="o">,</span>
  <span class="nc">Task</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">TimeoutException</span><span class="o">)</span>
<span class="o">)</span>

<span class="n">timedOut</span><span class="o">.</span><span class="n">runAsync</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">//=&gt; Left(TimeoutException)
</span></code></pre></div></div>

<h3 id="recovering-from-error">Recovering from Error</h3>

<p><code class="highlighter-rouge">Task.onErrorHandleWith</code> is an operation that takes a function mapping
possible exceptions to a desired fallback outcome, so we could do
this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">)</span>
    <span class="o">.</span><span class="n">delayExecution</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span>
    <span class="o">.</span><span class="n">timeout</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">recovered</span> <span class="k">=</span> <span class="n">source</span><span class="o">.</span><span class="n">onErrorHandleWith</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">TimeoutException</span> <span class="o">=&gt;</span>
    <span class="c1">// Oh, we know about timeouts, recover it
</span>    <span class="nc">Task</span><span class="o">.</span><span class="n">now</span><span class="o">(</span><span class="s">"Recovered!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span>
    <span class="c1">// We have no idea what happened, raise error!
</span>    <span class="nc">Task</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="n">other</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">recovered</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Recovered!
</span></code></pre></div></div>

<p>There’s also <code class="highlighter-rouge">Task.onErrorRecoverWith</code> that takes a partial function
instead, so we can omit the “other” branch:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">recovered</span> <span class="k">=</span> <span class="n">source</span><span class="o">.</span><span class="n">onErrorRecoverWith</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">TimeoutException</span> <span class="o">=&gt;</span>
    <span class="c1">// Oh, we know about timeouts, recover it
</span>    <span class="nc">Task</span><span class="o">.</span><span class="n">now</span><span class="o">(</span><span class="s">"Recovered!"</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">recovered</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Recovered!
</span></code></pre></div></div>

<p><code class="highlighter-rouge">Task.onErrorHandleWith</code> and <code class="highlighter-rouge">Task.onErrorRecoverWith</code> are the
equivalent of <code class="highlighter-rouge">flatMap</code>, only for errors. In case we know or can
evaluate a fallback result eagerly, we could use the shortcut
operation <code class="highlighter-rouge">Task.onErrorHandle</code> like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">recovered</span> <span class="k">=</span> <span class="n">source</span><span class="o">.</span><span class="n">onErrorHandle</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">TimeoutException</span> <span class="o">=&gt;</span>
    <span class="c1">// Oh, we know about timeouts, recover it
</span>    <span class="s">"Recovered!"</span>
  <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span>
    <span class="k">throw</span> <span class="n">other</span> <span class="c1">// Rethrowing
</span><span class="o">}</span>
</code></pre></div></div>

<p>Or the partial function version with <code class="highlighter-rouge">onErrorRecover</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">recovered</span> <span class="k">=</span> <span class="n">source</span><span class="o">.</span><span class="n">onErrorRecover</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">TimeoutException</span> <span class="o">=&gt;</span>
    <span class="c1">// Oh, we know about timeouts, recover it
</span>    <span class="s">"Recovered!"</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="restart-on-error">Restart On Error</h3>

<p>The <code class="highlighter-rouge">Task</code> type, being just a specification, it can usually restart
whatever process is supposed to deliver the final result and we can
restart the source on error, for how many times are needed:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">even</span> <span class="k">if</span> <span class="n">even</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">=&gt;</span>
    <span class="nc">Task</span><span class="o">.</span><span class="n">now</span><span class="o">(</span><span class="n">even</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span>
    <span class="nc">Task</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="n">other</span><span class="o">.</span><span class="n">toString</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">// Will retry 4 times for a random even number,
// or fail if the maxRetries is reached!
</span><span class="k">val</span> <span class="n">randomEven</span> <span class="k">=</span> <span class="n">source</span><span class="o">.</span><span class="n">onErrorRestart</span><span class="o">(</span><span class="n">maxRetries</span> <span class="k">=</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>We can also restart with a given predicate:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">even</span> <span class="k">if</span> <span class="n">even</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">=&gt;</span>
    <span class="nc">Task</span><span class="o">.</span><span class="n">now</span><span class="o">(</span><span class="n">even</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span>
    <span class="nc">Task</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="n">other</span><span class="o">.</span><span class="n">toString</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">// Will keep retrying for as long as the source fails
// with an IllegalStateException
</span><span class="k">val</span> <span class="n">randomEven</span> <span class="k">=</span> <span class="n">source</span><span class="o">.</span><span class="n">onErrorRestartIf</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">IllegalStateException</span> <span class="o">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Or we could implement our own retry with exponential backoff, because
it’s cool doing so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">retryBackoff</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">source</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span>
  <span class="n">maxRetries</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">firstDelay</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="n">source</span><span class="o">.</span><span class="n">onErrorHandleWith</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">Exception</span> <span class="o">=&gt;</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">maxRetries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="c1">// Recursive call, it's OK as Monix is stack-safe
</span>        <span class="n">retryBackoff</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">maxRetries</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">firstDelay</span><span class="o">*</span><span class="mi">2</span><span class="o">)</span>
          <span class="o">.</span><span class="n">delayExecution</span><span class="o">(</span><span class="n">firstDelay</span><span class="o">)</span>
      <span class="k">else</span>
        <span class="nc">Task</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="expose-errors">Expose Errors</h3>

<p>The <code class="highlighter-rouge">Task</code> monadic context is hiding errors that happen, much like
Scala’s <code class="highlighter-rouge">Try</code> or <code class="highlighter-rouge">Future</code>. But sometimes we want to expose those
errors such that we can recover more efficiently:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Try</span><span class="o">,</span> <span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>

<span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">)</span>
<span class="k">val</span> <span class="n">materialized</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">source</span><span class="o">.</span><span class="n">materialize</span>

<span class="c1">// Now we can flatMap over both success and failure:
</span><span class="k">val</span> <span class="n">recovered</span> <span class="k">=</span> <span class="n">materialized</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">.</span><span class="n">now</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">.</span><span class="n">now</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">recovered</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; 0
</span></code></pre></div></div>

<p>There’s also the reverse of materialize, which is <code class="highlighter-rouge">Task.dematerialize</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Try</span>

<span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">)</span>

<span class="c1">// Exposing errors
</span><span class="k">val</span> <span class="n">materialized</span> <span class="k">=</span> <span class="n">source</span><span class="o">.</span><span class="n">materialize</span>
<span class="c1">// materialize: Task[Try[Int]] = ???
</span>
<span class="c1">// Hiding errors again
</span><span class="k">val</span> <span class="n">dematerialized</span> <span class="k">=</span> <span class="n">materialized</span><span class="o">.</span><span class="n">dematerialize</span>
<span class="c1">// dematerialized: Task[Int] = ???
</span></code></pre></div></div>

<p>We can also convert any <code class="highlighter-rouge">Task</code> into a <code class="highlighter-rouge">Task[Throwable]</code> that will
expose any errors that happen and will also terminate with an
<code class="highlighter-rouge">NoSuchElementException</code> in case the source completes with success:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">.</span><span class="n">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">)</span>

<span class="k">val</span> <span class="n">throwable</span> <span class="k">=</span> <span class="n">source</span><span class="o">.</span><span class="n">failed</span>
<span class="c1">// throwable: Task[Throwable] = ???
</span>
<span class="n">throwable</span><span class="o">.</span><span class="n">runToFuture</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; java.lang.IllegalStateException
</span></code></pre></div></div>


  <div id="version3x">
    You are viewing the documentation for the latest Monix 3.x series.<br/>
    If you're looking for the older 2.x
    <a href="/docs/2x/">click here</a>!
  </div>

  <div class="buttons">
    <a href="/docs/3x/">Contents</a> •
    <a href="https://github.com/monix/monix.io/edit/master/_tut/docs/3x/eval/task.md">
      Edit Page</a> •
    
    <a href="https://gitter.im/monix/monix">
      Join Chat</a> •
    <a href="/social.html">
      Follow</a>
  </div>
</div>

      </article>    
    </div>

    <script>
        ((window.gitter = {}).chat = {}).options = {
          room: 'monix/monix'
        };
    </script>
    <script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>
  </body>
</html>
