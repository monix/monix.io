<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Monix 3.0.0 - monix.eval.Coeval.Always</title><meta content="Monix 3.0.0 - monix.eval.Coeval.Always" name="description"/><meta content="Monix 3.0.0 monix.eval.Coeval.Always" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../lib/jquery.js"></script><script type="text/javascript" src="../../lib/index.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript" src="../../lib/scheduler.js"></script><script type="text/javascript" src="../../lib/template.js"></script><script type="text/javascript" src="../../lib/tools.tooltip.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../';</script></head><body><div id="search"><span id="doc-title">Monix<span id="doc-version">3.0.0</span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="index.html#_root_" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">root</span></a></span><p class="shortcomment cmt"><img src="https://monix.io/public/images/monix-logo.png" align="right" width="200" /></p><div class="fullcomment"><div class="comment cmt"><p><img src="https://monix.io/public/images/monix-logo.png" align="right" width="200" /></p><p>This is the API documentation for the <a href="https://monix.io" target="_blank">Monix</a> library.</p><h4>Package Overview</h4><p><b><a href="../execution/index.html" name="monix.execution" id="monix.execution" class="extype">monix.execution</a></b> exposes lower level primitives for dealing
with asynchronous execution:</p><ul><li><a href="../execution/atomic/index.html" name="monix.execution.atomic" id="monix.execution.atomic" class="extype">monix.execution.atomic</a> exposes the <code>Atomic</code> types, as alternative
   to <code>java.util.concurrent.atomic</code></li><li><a href="../execution/cancelables/index.html" name="monix.execution.cancelables" id="monix.execution.cancelables" class="extype">monix.execution.cancelables</a> contains several
   useful <a href="../execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a> implementations</li><li><a href="../execution/schedulers/index.html" name="monix.execution.schedulers" id="monix.execution.schedulers" class="extype">monix.execution.schedulers</a> contains several
   useful <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> implementations</li><li><a href="../execution/rstreams/index.html" name="monix.execution.rstreams" id="monix.execution.rstreams" class="extype">monix.execution.rstreams</a> contains helpers for dealing
   with the <a href="http://www.reactive-streams.org" target="_blank">Reactive Streams</a> specification</li><li><a href="../execution/misc/index.html" name="monix.execution.misc" id="monix.execution.misc" class="extype">monix.execution.misc</a> provides miscellaneous primitives
   useful for dealing with concurrency</li><li><a href="../execution/exceptions/index.html" name="monix.execution.exceptions" id="monix.execution.exceptions" class="extype">monix.execution.exceptions</a> groups some exceptions thrown by
   the implementation</li></ul><p><b><a href="../catnap/index.html" name="monix.catnap" id="monix.catnap" class="extype">monix.catnap</a></b> exposes pure abstractions built on top of
the <a href="https://typelevel.org/cats-effect/" target="_blank">Cats-Effect</a> type classes:</p><ul><li><a href="../catnap/cancelables/index.html" name="monix.catnap.cancelables" id="monix.catnap.cancelables" class="extype">monix.catnap.cancelables</a> exposes pure counterparts to the
   cancelable data types described in <a href="../execution/cancelables/index.html" name="monix.execution.cancelables" id="monix.execution.cancelables" class="extype">monix.execution.cancelables</a></li></ul><p><b><a href="index.html" name="monix.eval" id="monix.eval" class="extype">monix.eval</a></b> is for dealing with evaluation of results, thus exposing
<a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> and <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>.</p><p><b><a href="../reactive/index.html" name="monix.reactive" id="monix.reactive" class="extype">monix.reactive</a></b> exposes the <code>Observable</code> pattern:</p><ul><li><a href="../reactive/observables/index.html" name="monix.reactive.observables" id="monix.reactive.observables" class="extype">monix.reactive.observables</a> groups reusable <code>Observable</code> implementations</li><li><a href="../reactive/observers/index.html" name="monix.reactive.observers" id="monix.reactive.observers" class="extype">monix.reactive.observers</a> groups reusable <a href="../reactive/Observer.html" name="monix.reactive.Observer" id="monix.reactive.Observer" class="extype">Observer</a>
   implementations</li><li><a href="../reactive/subjects/index.html" name="monix.reactive.subjects" id="monix.reactive.subjects" class="extype">monix.reactive.subjects</a> exposes <a href="../reactive/subjects/Subject.html" name="monix.reactive.subjects.Subject" id="monix.reactive.subjects.Subject" class="extype">Subject</a>
   and <a href="../reactive/subjects/ConcurrentSubject.html" name="monix.reactive.subjects.ConcurrentSubject" id="monix.reactive.subjects.ConcurrentSubject" class="extype">ConcurrentSubject</a>,
   which are implementations of hot observables that function both as input and output</li></ul><p><b><a href="../tail/index.html" name="monix.tail" id="monix.tail" class="extype">monix.tail</a></b> exposes <a href="../tail/Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a> for purely functional pull based streaming:</p><ul><li><a href="../tail/batches/index.html" name="monix.tail.batches" id="monix.tail.batches" class="extype">monix.tail.batches</a> describes <code>Batch</code> and <code>BatchCursor</code>, the
   alternatives to Scala's <code>Iterable</code> and <code>Iterator</code> respectively that
   we are using within Iterant's encoding</li></ul><p>You can control evaluation with type you choose - be it <a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>, <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>, <a href="https://typelevel.org/cats-effect/api/cats/effect/IO.html" target="_blank">cats.effect.IO</a>
or your own as long as you provide correct <a href="https://typelevel.org/cats-effect/typeclasses/" target="_blank">cats-effect</a> or <a href="https://typelevel.org/cats/typeclasses.html" target="_blank">cats</a> typeclass instance.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.monix" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="monix"></a><a id="monix:monix"></a> <span class="permalink"><a href="index.html#monix" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">monix</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="monix.eval" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eval"></a><a id="eval:eval"></a> <span class="permalink"><a href="../monix/index.html#eval" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title=""><span class="name">eval</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="monix" id="monix" class="extype">monix</a></dd></dl></div></li><li class="indented3 " name="monix.eval.Coeval" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Coeval"></a><a id="Coeval:Coeval"></a> <span class="permalink"><a href="../../monix/eval/index.html#Coeval" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Coeval$.html" title="Coeval builders."><span class="name">Coeval</span></a><span class="result"> extends <span name="monix.eval.CoevalInstancesLevel0" class="extype">CoevalInstancesLevel0</span> with <span name="java.io.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt"><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> builders.</p><div class="fullcomment"><div class="comment cmt"><p><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> builders.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="monix.eval" id="monix.eval" class="extype">eval</a></dd></dl></div></li><li class="current-entities indented3"><span class="separator"></span> <a href="" title="Constructs a lazy Coeval instance." class="class"></a><a href="" title="Constructs a lazy Coeval instance.">Always</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Coeval$$DeprecatedExtensions.html" title="Deprecated operations, described as extension methods." class="class"></a><a href="Coeval$$DeprecatedExtensions.html" title="Deprecated operations, described as extension methods.">DeprecatedExtensions</a></li><li class="current-entities indented3"><a href="Coeval$$Eager$.html" title="" class="object"></a> <a href="Coeval$$Eager.html" title="The Eager type represents a strict, already evaluated result of a Coeval that either resulted in success, wrapped in a Now, or in an error, wrapped in an Error." class="class"></a><a href="Coeval$$Eager.html" title="The Eager type represents a strict, already evaluated result of a Coeval that either resulted in success, wrapped in a Now, or in an error, wrapped in an Error.">Eager</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Coeval$$Error.html" title="Constructs an eager Coeval instance for a result that represents an error." class="class"></a><a href="Coeval$$Error.html" title="Constructs an eager Coeval instance for a result that represents an error.">Error</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Coeval$$Now.html" title="Constructs an eager Coeval instance from a strict value that's already known." class="class"></a><a href="Coeval$$Now.html" title="Constructs an eager Coeval instance from a strict value that's already known.">Now</a></li></ul></div></div><div id="content"><body class="class type"><div id="definition"><div class="big-circle class">c</div><p id="owner"><a href="../index.html" name="monix" id="monix" class="extype">monix</a>.<a href="index.html" name="monix.eval" id="monix.eval" class="extype">eval</a>.<a href="Coeval$.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></p><h1>Always<span class="permalink"><a href="../../monix/eval/Coeval$$Always.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier">final </span> <span class="kind">case class</span></span> <span class="symbol"><span class="name">Always</span><span class="tparams">[<span name="A">+A</span>]</span><span class="params">(<span name="f">f: () =&gt; <span name="monix.eval.Coeval.Always.A" class="extype">A</span></span>)</span><span class="result"> extends <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.Always.A" class="extype">A</span>] with <a href="https://www.scala-lang.org/api/2.13.0/scala/Product.html#scala.Product" name="scala.Product" id="scala.Product" class="extype">Product</a> with <span name="scala.Serializable" class="extype">Serializable</span></span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Constructs a lazy <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> instance.</p><p>This type can be used for "lazy" values. In some sense it is
equivalent to using a Function0 value.
</p></div><dl class="attributes block"><dt>Source</dt><dd><a href="https://github.com/monix/monix/tree/v3.0.0/monix-eval/shared/src/main/scala/monix/eval/Coeval.scala" target="_blank">Coeval.scala</a></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="https://www.scala-lang.org/api/2.13.0/scala/Product.html#scala.Product" name="scala.Product" id="scala.Product" class="extype">Product</a>, <a href="https://www.scala-lang.org/api/2.13.0/scala/Equals.html#scala.Equals" name="scala.Equals" id="scala.Equals" class="extype">Equals</a>, <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.Always.A" class="extype">A</span>], <span name="java.io.Serializable" class="extype">Serializable</span>, () =&gt; <span name="monix.eval.Coeval.Always.A" class="extype">A</span>, <a href="https://www.scala-lang.org/api/2.13.0/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>, <a href="https://www.scala-lang.org/api/2.13.0/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="monix.eval.Coeval.Always"><span>Always</span></li><li class="in" name="scala.Product"><span>Product</span></li><li class="in" name="scala.Equals"><span>Equals</span></li><li class="in" name="monix.eval.Coeval"><span>Coeval</span></li><li class="in" name="java.io.Serializable"><span>Serializable</span></li><li class="in" name="scala.Function0"><span>Function0</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="constructors" class="members"><h3>Instance Constructors</h3><ol><li class="indented0 " name="monix.eval.Coeval.Always#&lt;init&gt;" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="&lt;init&gt;(f:()=&gt;A):monix.eval.Coeval.Always[A]"></a><a id="&lt;init&gt;:Always[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#&lt;init&gt;(f:()=&gt;A):monix.eval.Coeval.Always[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">new</span></span> <span class="symbol"><span class="name">Always</span><span class="params">(<span name="f">f: () =&gt; <span name="monix.eval.Coeval.Always.A" class="extype">A</span></span>)</span></span></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.0/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.0/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##():Int"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html###():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.0/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.0/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.0/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#&gt;&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="&gt;&gt;[B](that:=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]"></a><a id="&gt;&gt;[B](=&gt;Coeval[B]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#&gt;&gt;[B](that:=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $greater$greater">&gt;&gt;</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="that">that: =&gt; <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.&gt;&gt;.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.&gt;&gt;.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Runs this underlying computation first and then, when successful, the given one.</p><div class="fullcomment"><div class="comment cmt"><p>Runs this underlying computation first and then, when successful, the given one.
Returns the result of the given underlying computation.</p><p>Example:</p><pre><span class="kw">val</span> combined = Coeval{println(<span class="lit">"first"</span>); <span class="lit">"first"</span>} &gt;&gt; Coeval{println(<span class="lit">"second"</span>); <span class="lit">"second"</span>}
<span class="cmt">// Prints "first" and then "second"</span>
<span class="cmt">// Result value will be "second"</span></pre></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval.Always#apply" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="apply():A"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#apply():A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">apply</span><span class="params">()</span><span class="result">: <span name="monix.eval.Coeval.Always.A" class="extype">A</span></span></span><p class="shortcomment cmt">Evaluates the underlying computation and returns the result.</p><div class="fullcomment"><div class="comment cmt"><p>Evaluates the underlying computation and returns the result.</p><p>NOTE: this can throw exceptions.</p><pre><span class="cmt">// For didactic purposes, don't do shared vars at home :-)</span>
<span class="kw">var</span> i = <span class="num">0</span>
<span class="kw">val</span> fa = Coeval { i += <span class="num">1</span>; i }

fa() <span class="cmt">// =&gt; 1</span>
fa() <span class="cmt">// =&gt; 2</span>
fa() <span class="cmt">// =&gt; 3</span></pre><p><b>UNSAFE</b> — this operation can trigger the
        execution of side effects, which break referential
        transparency and is thus not a pure function.</p><p>        In FP code use with care, suspended in another <code>Coeval</code>
        or <a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>, or at the edge of the FP
        program.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="" name="monix.eval.Coeval.Always" id="monix.eval.Coeval.Always" class="extype">Always</a> → <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> → Function0</dd></dl></div></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#attempt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="attempt:monix.eval.Coeval[Either[Throwable,A]]"></a><a id="attempt:Coeval[Either[Throwable,A]]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#attempt:monix.eval.Coeval[Either[Throwable,A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">attempt</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="scala.Either" class="extype">Either</span>[<span name="scala.Throwable" class="extype">Throwable</span>, <span name="monix.eval.Coeval.Always.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Creates a new <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> that will expose any triggered error
from the source.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> that will expose any triggered error
from the source.</p><pre><span class="kw">val</span> fa: Coeval[<span class="std">Int</span>] =
  Coeval.raiseError[<span class="std">Int</span>](<span class="kw">new</span> RuntimeException(<span class="lit">"dummy"</span>))

<span class="kw">val</span> fe: Coeval[Either[Throwable, <span class="std">Int</span>]] =
  fa.attempt

fe.map {
  <span class="kw">case</span> Left(_) <span class="kw">=&gt;</span> <span class="std">Int</span>.MaxValue
  <span class="kw">case</span> Right(v) <span class="kw">=&gt;</span> v
}</pre><p>By exposing errors by lifting the <code>Coeval</code>'s result into an
<code>Either</code> value, we can handle those errors in <code>flatMap</code>
transformations.</p><p>Also see <a href="Coeval.html#materialize:monix.eval.Coeval[scala.util.Try[A]]" name="monix.eval.Coeval#materialize" id="monix.eval.Coeval#materialize" class="extmbr">materialize</a> for working with Scala's
<a href="https://www.scala-lang.org/api/2.13.0/scala/util/Try.html" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a> or <a href="Coeval.html#redeemWith[B](recover:Throwable=&gt;monix.eval.Coeval[B],bind:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#redeemWith" id="monix.eval.Coeval#redeemWith" class="extmbr">redeemWith</a> for an alternative.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#bracket" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bracket[B](use:A=&gt;monix.eval.Coeval[B])(release:A=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]"></a><a id="bracket[B]((A)=&gt;Coeval[B])((A)=&gt;Coeval[Unit]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#bracket[B](use:A=&gt;monix.eval.Coeval[B])(release:A=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bracket</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="use">use: (<span name="monix.eval.Coeval.Always.A" class="extype">A</span>) =&gt; <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.bracket.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="release">release: (<span name="monix.eval.Coeval.Always.A" class="extype">A</span>) =&gt; <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<a href="https://www.scala-lang.org/api/2.13.0/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.bracket.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a task that treats the source as the acquisition of a resource,
which is then exploited by the <code>use</code> function and then <code>released</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a task that treats the source as the acquisition of a resource,
which is then exploited by the <code>use</code> function and then <code>released</code>.</p><p>The <code>bracket</code> operation is the equivalent of the
<code>try {} finally {}</code> statements from mainstream languages, installing
the necessary exception handler to release the resource in the event of
an exception being raised during the computation. If an exception is raised,
then <code>bracket</code> will re-raise the exception <i>after</i> performing the <code>release</code>.</p><p>Example:</p><pre><span class="kw">import</span> java.io._

<span class="kw">def</span> readFile(file: File): Coeval[<span class="std">String</span>] = {
  <span class="cmt">// Opening a file handle for reading text</span>
  <span class="kw">val</span> acquire = Coeval.eval(<span class="kw">new</span> BufferedReader(
    <span class="kw">new</span> InputStreamReader(<span class="kw">new</span> FileInputStream(file), <span class="lit">"utf-8"</span>)
  ))

  acquire.bracket { in <span class="kw">=&gt;</span>
    <span class="cmt">// Usage part</span>
    Coeval.eval {
      <span class="cmt">// Yes, ugly Java, non-FP loop;</span>
      <span class="cmt">// side-effects are suspended though</span>
      <span class="kw">var</span> line: <span class="std">String</span> = <span class="kw">null</span>
      <span class="kw">val</span> buff = <span class="kw">new</span> StringBuilder()
      <span class="kw">do</span> {
        line = in.readLine()
        <span class="kw">if</span> (line != <span class="kw">null</span>) buff.append(line)
      } <span class="kw">while</span> (line != <span class="kw">null</span>)
      buff.toString()
    }
  } { in <span class="kw">=&gt;</span>
    <span class="cmt">// The release part</span>
    Coeval.eval(in.close())
  }
}</pre><p><b>NOTE on error handling</b>: one big
        difference versus <code>try {} finally {}</code> is that, in case
        both the <code>release</code> function and the <code>use</code> function throws,
        the error raised by <code>use</code> gets signaled and the error
        raised by <code>release</code> gets reported with <code>System.err</code> for
        <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> or with
        <a href="../execution/Scheduler.html#reportFailure(t:Throwable):Unit" name="monix.execution.Scheduler#reportFailure" id="monix.execution.Scheduler#reportFailure" class="extmbr">Scheduler.reportFailure</a>
        for <a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>.</p><p>        For example:</p><pre>Coeval(<span class="lit">"resource"</span>).bracket { _ <span class="kw">=&gt;</span>
  <span class="cmt">// use</span>
  Coeval.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"Foo"</span>))
} { _ <span class="kw">=&gt;</span>
  <span class="cmt">// release</span>
  Coeval.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"Bar"</span>))
}</pre><p>        In this case the error signaled downstream is <code>"Foo"</code>,
        while the <code>"Bar"</code> error gets reported. This is consistent
        with the behavior of Haskell's <code>bracket</code> operation and NOT
        with <code>try {} finally {}</code> from Scala, Java or JavaScript.</p></div><dl class="paramcmts block"><dt class="param">use</dt><dd class="cmt"><p>is a function that evaluates the resource yielded by the source,
       yielding a result that will get generated by the task returned
       by this <code>bracket</code> function</p></dd><dt class="param">release</dt><dd class="cmt"><p>is a function that gets called after <code>use</code> terminates,
       either normally or in error, receiving as input the resource that
       needs to be released</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Coeval.html#bracketCase[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracketCase" id="monix.eval.Coeval#bracketCase" class="extmbr">bracketCase</a> and <a href="Coeval.html#bracketE[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,Either[Throwable,B])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracketE" id="monix.eval.Coeval#bracketE" class="extmbr">bracketE</a></p></span></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#bracketCase" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bracketCase[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]"></a><a id="bracketCase[B]((A)=&gt;Coeval[B])((A,ExitCase[Throwable])=&gt;Coeval[Unit]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#bracketCase[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bracketCase</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="use">use: (<span name="monix.eval.Coeval.Always.A" class="extype">A</span>) =&gt; <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.bracketCase.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="release">release: (<span name="monix.eval.Coeval.Always.A" class="extype">A</span>, <span name="cats.effect.ExitCase" class="extype">ExitCase</span>[<span name="scala.Throwable" class="extype">Throwable</span>]) =&gt; <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<a href="https://www.scala-lang.org/api/2.13.0/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.bracketCase.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a new task that treats the source task as the
acquisition of a resource, which is then exploited by the <code>use</code>
function and then <code>released</code>, with the possibility of
distinguishing between successful completion and failure, such
that an appropriate release of resources can be executed.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new task that treats the source task as the
acquisition of a resource, which is then exploited by the <code>use</code>
function and then <code>released</code>, with the possibility of
distinguishing between successful completion and failure, such
that an appropriate release of resources can be executed.</p><p>The <code>bracketCase</code> operation is the equivalent of
<code>try {} catch {} finally {}</code> statements from mainstream languages
when used for the acquisition and release of resources.</p><p>The <code>bracketCase</code> operation installs the necessary exception handler
to release the resource in the event of an exception being raised
during the computation.</p><p>In comparison with the simpler <a href="Coeval.html#bracket[B](use:A=&gt;monix.eval.Coeval[B])(release:A=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracket" id="monix.eval.Coeval#bracket" class="extmbr">bracket</a> version, this one
allows the caller to differentiate between normal termination and
termination in error via an <code>ExitCase</code> parameter.
</p></div><dl class="paramcmts block"><dt class="param">use</dt><dd class="cmt"><p>is a function that evaluates the resource yielded by
       the source, yielding a result that will get generated by
       this function on evaluation</p></dd><dt class="param">release</dt><dd class="cmt"><p>is a function that gets called after <code>use</code>
       terminates, either normally or in error, receiving as
       input the resource that needs that needs release, along
       with the result of <code>use</code></p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Coeval.html#bracket[B](use:A=&gt;monix.eval.Coeval[B])(release:A=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracket" id="monix.eval.Coeval#bracket" class="extmbr">bracket</a> and <a href="Coeval.html#bracketE[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,Either[Throwable,B])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracketE" id="monix.eval.Coeval#bracketE" class="extmbr">bracketE</a></p></span></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#bracketE" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bracketE[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,Either[Throwable,B])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]"></a><a id="bracketE[B]((A)=&gt;Coeval[B])((A,Either[Throwable,B])=&gt;Coeval[Unit]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#bracketE[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,Either[Throwable,B])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bracketE</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="use">use: (<span name="monix.eval.Coeval.Always.A" class="extype">A</span>) =&gt; <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.bracketE.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="release">release: (<span name="monix.eval.Coeval.Always.A" class="extype">A</span>, <span name="scala.Either" class="extype">Either</span>[<span name="scala.Throwable" class="extype">Throwable</span>, <span name="monix.eval.Coeval.bracketE.B" class="extype">B</span>]) =&gt; <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<a href="https://www.scala-lang.org/api/2.13.0/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.bracketE.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a task that treats the source task as the acquisition of a resource,
which is then exploited by the <code>use</code> function and then <code>released</code>, with
the possibility of distinguishing between successful termination and
error,  such that an appropriate release of resources can be executed.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a task that treats the source task as the acquisition of a resource,
which is then exploited by the <code>use</code> function and then <code>released</code>, with
the possibility of distinguishing between successful termination and
error,  such that an appropriate release of resources can be executed.</p><p>The <code>bracket</code> operation is the equivalent of the
<code>try {} finally {}</code> statements from mainstream languages, installing
the necessary exception handler to release the resource in the event of
an exception being raised during the computation. If an exception is raised,
then <code>bracket</code> will re-raise the exception <i>after</i> performing the <code>release</code>.</p><p>The <code>release</code> function receives as input:</p><ul><li><code>Left(error)</code> in case <code>use</code> terminated with an error</li><li><code>Right(b)</code> in case of success</li></ul><p><b>NOTE on error handling</b>: one big
        difference versus <code>try {} finally {}</code> is that, in case
        both the <code>release</code> function and the <code>use</code> function throws,
        the error raised by <code>use</code> gets signaled and the error
        raised by <code>release</code> gets reported with <code>System.err</code> for
        <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> or with
        <a href="../execution/Scheduler.html#reportFailure(t:Throwable):Unit" name="monix.execution.Scheduler#reportFailure" id="monix.execution.Scheduler#reportFailure" class="extmbr">Scheduler.reportFailure</a>
        for <a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>.</p><p>        For example:</p><pre>Coeval(<span class="lit">"resource"</span>).bracket { _ <span class="kw">=&gt;</span>
  <span class="cmt">// use</span>
  Coeval.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"Foo"</span>))
} { _ <span class="kw">=&gt;</span>
  <span class="cmt">// release</span>
  Coeval.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"Bar"</span>))
}</pre><p>        In this case the error signaled downstream is <code>"Foo"</code>,
        while the <code>"Bar"</code> error gets reported. This is consistent
        with the behavior of Haskell's <code>bracket</code> operation and NOT
        with <code>try {} finally {}</code> from Scala, Java or JavaScript.</p></div><dl class="paramcmts block"><dt class="param">use</dt><dd class="cmt"><p>is a function that evaluates the resource yielded by the source,
       yielding a result that will get generated by this function on
       evaluation</p></dd><dt class="param">release</dt><dd class="cmt"><p>is a function that gets called after <code>use</code> terminates,
       either normally or in error, receiving as input the resource that
       needs that needs release, along with the result of <code>use</code></p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Coeval.html#bracket[B](use:A=&gt;monix.eval.Coeval[B])(release:A=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracket" id="monix.eval.Coeval#bracket" class="extmbr">bracket</a> and <a href="Coeval.html#bracketCase[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracketCase" id="monix.eval.Coeval#bracketCase" class="extmbr">bracketCase</a></p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object"></a><a id="clone():AnyRef"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.0/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<a href="../../java/lang/index.html" name="java.lang" id="java.lang" class="extype">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#dematerialize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dematerialize[B](implicitev:A&lt;:&lt;scala.util.Try[B]):monix.eval.Coeval[B]"></a><a id="dematerialize[B](&lt;:&lt;[A,Try[B]]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#dematerialize[B](implicitev:A&lt;:&lt;scala.util.Try[B]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">dematerialize</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.0/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.eval.Coeval.Always.A" class="extype">A</span>, <a href="https://www.scala-lang.org/api/2.13.0/scala/util/Try.html#scala.util.Try" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a>[<span name="monix.eval.Coeval.dematerialize.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.dematerialize.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Dematerializes the source's result from a <code>Try</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Dematerializes the source's result from a <code>Try</code>.</p><p>This equivalence always holds:</p><p><code>fa.materialize.dematerialize &lt;-&gt; fa</code>
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#doOnFinish" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnFinish(f:Option[Throwable]=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[A]"></a><a id="doOnFinish((Option[Throwable])=&gt;Coeval[Unit]):Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#doOnFinish(f:Option[Throwable]=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnFinish</span><span class="params">(<span name="f">f: (<a href="https://www.scala-lang.org/api/2.13.0/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scala.Throwable" class="extype">Throwable</span>]) =&gt; <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<a href="https://www.scala-lang.org/api/2.13.0/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.Always.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns a new <code>Coeval</code> in which <code>f</code> is scheduled to be run on completion.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new <code>Coeval</code> in which <code>f</code> is scheduled to be run on completion.
This would typically be used to release any resources acquired by this
<code>Coeval</code>.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.0/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.0/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval.Always#f" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="f:()=&gt;A"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#f:()=&gt;A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">f</span><span class="result">: () =&gt; <span name="monix.eval.Coeval.Always.A" class="extype">A</span></span></span></li><li class="indented0 " name="monix.eval.Coeval#failed" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="failed:monix.eval.Coeval[Throwable]"></a><a id="failed:Coeval[Throwable]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#failed:monix.eval.Coeval[Throwable]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">failed</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="scala.Throwable" class="extype">Throwable</span>]</span></span><p class="shortcomment cmt">Returns a failed projection of this coeval.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a failed projection of this coeval.</p><p>The failed projection is a <code>Coeval</code> holding a value of type <code>Throwable</code>,
emitting the error yielded by the source, in case the source fails,
otherwise if the source succeeds the result will fail with a
<code>NoSuchElementException</code>.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">finalize</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.0/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<a href="../../java/lang/index.html" name="java.lang" id="java.lang" class="extype">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#flatMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatMap[B](f:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]"></a><a id="flatMap[B]((A)=&gt;Coeval[B]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#flatMap[B](f:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.eval.Coeval.Always.A" class="extype">A</span>) =&gt; <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.flatMap.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.flatMap.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new <code>Coeval</code> by applying a function to the successful result
of the source, and returns a new instance equivalent
to the result of the function.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new <code>Coeval</code> by applying a function to the successful result
of the source, and returns a new instance equivalent
to the result of the function.</p><p>The application of <code>flatMap</code> is always lazy and because of the
implementation it is memory safe and thus it can be used in
recursive loops.</p><p>Sample:</p><pre><span class="kw">import</span> scala.util.Random

<span class="kw">def</span> randomEven: Coeval[<span class="std">Int</span>] =
  Coeval(Random.nextInt()).flatMap { x <span class="kw">=&gt;</span>
    <span class="kw">if</span> (x &lt; <span class="num">0</span> || x % <span class="num">2</span> == <span class="num">1</span>)
      randomEven <span class="cmt">// retry</span>
    <span class="kw">else</span>
      Coeval.now(x)
  }</pre></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#flatten" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatten[B](implicitev:A&lt;:&lt;monix.eval.Coeval[B]):monix.eval.Coeval[B]"></a><a id="flatten[B](&lt;:&lt;[A,Coeval[B]]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#flatten[B](implicitev:A&lt;:&lt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatten</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.0/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.eval.Coeval.Always.A" class="extype">A</span>, <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.flatten.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.flatten.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Given a source Coeval that emits another Coeval, this function
flattens the result, returning a Coeval equivalent to the emitted
Coeval by the source.</p><div class="fullcomment"><div class="comment cmt"><p>Given a source Coeval that emits another Coeval, this function
flattens the result, returning a Coeval equivalent to the emitted
Coeval by the source.</p><p>This equivalence with <a href="Coeval.html#flatMap[B](f:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#flatMap" id="monix.eval.Coeval#flatMap" class="extmbr">flatMap</a> always holds:</p><p><code>fa.flatten &lt;-&gt; fa.flatMap(x =&gt; x)</code>
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#foreach" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foreach(f:A=&gt;Unit):Unit"></a><a id="foreach((A)=&gt;Unit):Unit"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#foreach(f:A=&gt;Unit):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foreach</span><span class="params">(<span name="f">f: (<span name="monix.eval.Coeval.Always.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.0/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.0/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><p class="shortcomment cmt">Triggers the evaluation of the source, executing
the given function for the generated element.</p><div class="fullcomment"><div class="comment cmt"><p>Triggers the evaluation of the source, executing
the given function for the generated element.</p><p>The application of this function has strict
behavior, as the coeval is immediately executed.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#foreachL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foreachL(f:A=&gt;Unit):monix.eval.Coeval[Unit]"></a><a id="foreachL((A)=&gt;Unit):Coeval[Unit]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#foreachL(f:A=&gt;Unit):monix.eval.Coeval[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foreachL</span><span class="params">(<span name="f">f: (<span name="monix.eval.Coeval.Always.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.0/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<a href="https://www.scala-lang.org/api/2.13.0/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Returns a new task that upon evaluation will execute
the given function for the generated element,
transforming the source into a <code>Coeval[Unit]</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new task that upon evaluation will execute
the given function for the generated element,
transforming the source into a <code>Coeval[Unit]</code>.</p><p>Similar in spirit with normal <a href="Coeval.html#foreach(f:A=&gt;Unit):Unit" name="monix.eval.Coeval#foreach" id="monix.eval.Coeval#foreach" class="extmbr">foreach</a>, but lazy,
as obviously nothing gets executed at this point.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]"></a><a id="getClass():Class[_&lt;:AnyRef]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <span name="java.lang.Class" class="extype">Class</span>[_ &lt;: <a href="https://www.scala-lang.org/api/2.13.0/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#guarantee" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="guarantee(finalizer:monix.eval.Coeval[Unit]):monix.eval.Coeval[A]"></a><a id="guarantee(Coeval[Unit]):Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#guarantee(finalizer:monix.eval.Coeval[Unit]):monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">guarantee</span><span class="params">(<span name="finalizer">finalizer: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<a href="https://www.scala-lang.org/api/2.13.0/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.Always.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Executes the given <code>finalizer</code> when the source is finished,
either in success or in error, or if canceled.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the given <code>finalizer</code> when the source is finished,
either in success or in error, or if canceled.</p><p>This variant of <a href="Coeval.html#guaranteeCase(finalizer:cats.effect.ExitCase[Throwable]=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[A]" name="monix.eval.Coeval#guaranteeCase" id="monix.eval.Coeval#guaranteeCase" class="extmbr">guaranteeCase</a> evaluates the given <code>finalizer</code>
regardless of how the source gets terminated:</p><ul><li>normal completion</li><li>completion in error</li><li>cancellation</li></ul><p>As best practice, it's not a good idea to release resources
via <code>guaranteeCase</code> in polymorphic code. Prefer <a href="Coeval.html#bracket[B](use:A=&gt;monix.eval.Coeval[B])(release:A=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracket" id="monix.eval.Coeval#bracket" class="extmbr">bracket</a>
for the acquisition and release of resources.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Coeval.html#guaranteeCase(finalizer:cats.effect.ExitCase[Throwable]=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[A]" name="monix.eval.Coeval#guaranteeCase" id="monix.eval.Coeval#guaranteeCase" class="extmbr">guaranteeCase</a> for the version that can discriminate
     between termination conditions</p></span><span class="cmt"><p><a href="Coeval.html#bracket[B](use:A=&gt;monix.eval.Coeval[B])(release:A=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracket" id="monix.eval.Coeval#bracket" class="extmbr">bracket</a> for the more general operation</p></span></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#guaranteeCase" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="guaranteeCase(finalizer:cats.effect.ExitCase[Throwable]=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[A]"></a><a id="guaranteeCase((ExitCase[Throwable])=&gt;Coeval[Unit]):Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#guaranteeCase(finalizer:cats.effect.ExitCase[Throwable]=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">guaranteeCase</span><span class="params">(<span name="finalizer">finalizer: (<span name="cats.effect.ExitCase" class="extype">ExitCase</span>[<span name="scala.Throwable" class="extype">Throwable</span>]) =&gt; <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<a href="https://www.scala-lang.org/api/2.13.0/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.Always.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Executes the given <code>finalizer</code> when the source is finished,
either in success or in error, or if canceled, allowing
for differentiating between exit conditions.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the given <code>finalizer</code> when the source is finished,
either in success or in error, or if canceled, allowing
for differentiating between exit conditions.</p><p>This variant of <a href="Coeval.html#guarantee(finalizer:monix.eval.Coeval[Unit]):monix.eval.Coeval[A]" name="monix.eval.Coeval#guarantee" id="monix.eval.Coeval#guarantee" class="extmbr">guarantee</a> injects an ExitCase in
the provided function, allowing one to make a difference
between:</p><ul><li>normal completion</li><li>completion in error</li><li>cancellation</li></ul><p>As best practice, it's not a good idea to release resources
via <code>guaranteeCase</code> in polymorphic code. Prefer <a href="Coeval.html#bracketCase[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracketCase" id="monix.eval.Coeval#bracketCase" class="extmbr">bracketCase</a>
for the acquisition and release of resources.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Coeval.html#guarantee(finalizer:monix.eval.Coeval[Unit]):monix.eval.Coeval[A]" name="monix.eval.Coeval#guarantee" id="monix.eval.Coeval#guarantee" class="extmbr">guarantee</a> for the simpler version</p></span><span class="cmt"><p><a href="Coeval.html#bracketCase[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracketCase" id="monix.eval.Coeval#bracketCase" class="extmbr">bracketCase</a> for the more general operation</p></span></dd></dl></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.0/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#map" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="map[B](f:A=&gt;B):monix.eval.Coeval[B]"></a><a id="map[B]((A)=&gt;B):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#map[B](f:A=&gt;B):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">map</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.eval.Coeval.Always.A" class="extype">A</span>) =&gt; <span name="monix.eval.Coeval.map.B" class="extype">B</span></span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.map.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a new <code>Coeval</code> that applies the mapping function to
the element emitted by the source.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new <code>Coeval</code> that applies the mapping function to
the element emitted by the source.</p><p>Can be used for specifying a (lazy) transformation to the result
of the source.</p><p>This equivalence with <a href="Coeval.html#flatMap[B](f:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#flatMap" id="monix.eval.Coeval#flatMap" class="extmbr">flatMap</a> always holds:</p><p><code>fa.map(f) &lt;-&gt; fa.flatMap(x =&gt; Coeval.pure(f(x)))</code>
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#materialize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="materialize:monix.eval.Coeval[scala.util.Try[A]]"></a><a id="materialize:Coeval[Try[A]]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#materialize:monix.eval.Coeval[scala.util.Try[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">materialize</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<a href="https://www.scala-lang.org/api/2.13.0/scala/util/Try.html#scala.util.Try" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a>[<span name="monix.eval.Coeval.Always.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Creates a new <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> that will expose any triggered error from
the source.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> that will expose any triggered error from
the source.</p><p>Also see <a href="Coeval.html#attempt:monix.eval.Coeval[Either[Throwable,A]]" name="monix.eval.Coeval#attempt" id="monix.eval.Coeval#attempt" class="extmbr">attempt</a> for working with Scala's
<a href="https://www.scala-lang.org/api/2.13.0/scala/index.html#Either[+A,+B]=scala.util.Either[A,B]" name="scala" id="scala" class="extype">Either</a> or <a href="Coeval.html#redeemWith[B](recover:Throwable=&gt;monix.eval.Coeval[B],bind:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#redeemWith" id="monix.eval.Coeval#redeemWith" class="extmbr">redeemWith</a> for an alternative.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#memoize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="memoize:monix.eval.Coeval[A]"></a><a id="memoize:Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#memoize:monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">memoize</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.Always.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Memoizes (caches) the result of the source and reuses it on
subsequent invocations of <code>value</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Memoizes (caches) the result of the source and reuses it on
subsequent invocations of <code>value</code>.</p><p>The resulting coeval will be idempotent, meaning that
evaluating the resulting coeval multiple times will have the
same effect as evaluating it once.</p><p><b>UNSAFE</b> — this operation allocates a shared,
        mutable reference, which can break in certain cases
        referential transparency, even if this operation guarantees
        idempotency (i.e. referential transparency implies idempotency,
        but idempotency does not imply referential transparency).</p><p>        The allocation of a mutable reference is known to be a
        side effect, thus breaking referential transparency,
        even if calling this method does not trigger the evaluation
        of side effects suspended by the source.</p><p>        Use with care. Sometimes it's easier to just keep a shared,
        memoized reference to some connection, but keep in mind
        it might be better to pass such a reference around as
        a parameter.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd><dt>See also</dt><dd><span class="cmt"><p><a href="Coeval.html#memoizeOnSuccess:monix.eval.Coeval[A]" name="monix.eval.Coeval#memoizeOnSuccess" id="monix.eval.Coeval#memoizeOnSuccess" class="extmbr">memoizeOnSuccess</a> for a version that only caches
    successful results</p></span></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#memoizeOnSuccess" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="memoizeOnSuccess:monix.eval.Coeval[A]"></a><a id="memoizeOnSuccess:Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#memoizeOnSuccess:monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">memoizeOnSuccess</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.Always.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Memoizes (cache) the successful result of the source
and reuses it on subsequent invocations of <code>value</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Memoizes (cache) the successful result of the source
and reuses it on subsequent invocations of <code>value</code>.
Thrown exceptions are not cached.</p><p>The resulting coeval will be idempotent, but only if the
result is successful.</p><p><b>UNSAFE</b> — this operation allocates a shared,
        mutable reference, which can break in certain cases
        referential transparency, even if this operation guarantees
        idempotency (i.e. referential transparency implies idempotency,
        but idempotency does not imply referential transparency).</p><p>        The allocation of a mutable reference is known to be a
        side effect, thus breaking referential transparency,
        even if calling this method does not trigger the evaluation
        of side effects suspended by the source.</p><p>        Use with care. Sometimes it's easier to just keep a shared,
        memoized reference to some connection, but keep in mind
        it might be better to pass such a reference around as
        a parameter.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd><dt>See also</dt><dd><span class="cmt"><p><a href="Coeval.html#memoize:monix.eval.Coeval[A]" name="monix.eval.Coeval#memoize" id="monix.eval.Coeval#memoize" class="extmbr">memoize</a> for a version that caches both successful
    results and failures</p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.0/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.0/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.0/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.0/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#onErrorFallbackTo" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorFallbackTo[B&gt;:A](that:monix.eval.Coeval[B]):monix.eval.Coeval[B]"></a><a id="onErrorFallbackTo[B&gt;:A](Coeval[B]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#onErrorFallbackTo[B&gt;:A](that:monix.eval.Coeval[B]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorFallbackTo</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.eval.Coeval.Always.A" class="extype">A</span></span>]</span><span class="params">(<span name="that">that: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorFallbackTo.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorFallbackTo.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new coeval that in case of error will fallback to the
given backup coeval.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new coeval that in case of error will fallback to the
given backup coeval.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#onErrorHandle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorHandle[U&gt;:A](f:Throwable=&gt;U):monix.eval.Coeval[U]"></a><a id="onErrorHandle[U&gt;:A]((Throwable)=&gt;U):Coeval[U]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#onErrorHandle[U&gt;:A](f:Throwable=&gt;U):monix.eval.Coeval[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorHandle</span><span class="tparams">[<span name="U">U &gt;: <span name="monix.eval.Coeval.Always.A" class="extype">A</span></span>]</span><span class="params">(<span name="f">f: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <span name="monix.eval.Coeval.onErrorHandle.U" class="extype">U</span></span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorHandle.U" class="extype">U</span>]</span></span><p class="shortcomment cmt">Creates a new coeval that will handle any matching throwable that
this coeval might emit.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new coeval that will handle any matching throwable that
this coeval might emit.</p><p>See <a href="Coeval.html#onErrorRecover[U&gt;:A](pf:PartialFunction[Throwable,U]):monix.eval.Coeval[U]" name="monix.eval.Coeval#onErrorRecover" id="monix.eval.Coeval#onErrorRecover" class="extmbr">onErrorRecover</a> for the version that takes a partial function.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#onErrorHandleWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorHandleWith[B&gt;:A](f:Throwable=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]"></a><a id="onErrorHandleWith[B&gt;:A]((Throwable)=&gt;Coeval[B]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#onErrorHandleWith[B&gt;:A](f:Throwable=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorHandleWith</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.eval.Coeval.Always.A" class="extype">A</span></span>]</span><span class="params">(<span name="f">f: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorHandleWith.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorHandleWith.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new coeval that will handle any matching throwable that
this coeval might emit by executing another coeval.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new coeval that will handle any matching throwable that
this coeval might emit by executing another coeval.</p><p>See <a href="Coeval.html#onErrorRecoverWith[B&gt;:A](pf:PartialFunction[Throwable,monix.eval.Coeval[B]]):monix.eval.Coeval[B]" name="monix.eval.Coeval#onErrorRecoverWith" id="monix.eval.Coeval#onErrorRecoverWith" class="extmbr">onErrorRecoverWith</a> for the version that takes a partial function.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#onErrorRecover" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRecover[U&gt;:A](pf:PartialFunction[Throwable,U]):monix.eval.Coeval[U]"></a><a id="onErrorRecover[U&gt;:A](PartialFunction[Throwable,U]):Coeval[U]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#onErrorRecover[U&gt;:A](pf:PartialFunction[Throwable,U]):monix.eval.Coeval[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRecover</span><span class="tparams">[<span name="U">U &gt;: <span name="monix.eval.Coeval.Always.A" class="extype">A</span></span>]</span><span class="params">(<span name="pf">pf: <a href="https://www.scala-lang.org/api/2.13.0/scala/PartialFunction.html#scala.PartialFunction" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<span name="scala.Throwable" class="extype">Throwable</span>, <span name="monix.eval.Coeval.onErrorRecover.U" class="extype">U</span>]</span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorRecover.U" class="extype">U</span>]</span></span><p class="shortcomment cmt">Creates a new coeval that on error will try to map the error
to another value using the provided partial function.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new coeval that on error will try to map the error
to another value using the provided partial function.</p><p>See <a href="Coeval.html#onErrorHandle[U&gt;:A](f:Throwable=&gt;U):monix.eval.Coeval[U]" name="monix.eval.Coeval#onErrorHandle" id="monix.eval.Coeval#onErrorHandle" class="extmbr">onErrorHandle</a> for the version that takes a total function.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#onErrorRecoverWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRecoverWith[B&gt;:A](pf:PartialFunction[Throwable,monix.eval.Coeval[B]]):monix.eval.Coeval[B]"></a><a id="onErrorRecoverWith[B&gt;:A](PartialFunction[Throwable,Coeval[B]]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#onErrorRecoverWith[B&gt;:A](pf:PartialFunction[Throwable,monix.eval.Coeval[B]]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRecoverWith</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.eval.Coeval.Always.A" class="extype">A</span></span>]</span><span class="params">(<span name="pf">pf: <a href="https://www.scala-lang.org/api/2.13.0/scala/PartialFunction.html#scala.PartialFunction" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<span name="scala.Throwable" class="extype">Throwable</span>, <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorRecoverWith.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorRecoverWith.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new coeval that will try recovering from an error by
matching it with another coeval using the given partial function.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new coeval that will try recovering from an error by
matching it with another coeval using the given partial function.</p><p>See <a href="Coeval.html#onErrorHandleWith[B&gt;:A](f:Throwable=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#onErrorHandleWith" id="monix.eval.Coeval#onErrorHandleWith" class="extmbr">onErrorHandleWith</a> for the version that takes a total function.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#onErrorRestart" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRestart(maxRetries:Long):monix.eval.Coeval[A]"></a><a id="onErrorRestart(Long):Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#onErrorRestart(maxRetries:Long):monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRestart</span><span class="params">(<span name="maxRetries">maxRetries: <a href="https://www.scala-lang.org/api/2.13.0/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.Always.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new coeval that in case of error will retry executing the
source again and again, until it succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new coeval that in case of error will retry executing the
source again and again, until it succeeds.</p><p>In case of continuous failure the total number of executions
will be <code>maxRetries + 1</code>.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#onErrorRestartIf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRestartIf(p:Throwable=&gt;Boolean):monix.eval.Coeval[A]"></a><a id="onErrorRestartIf((Throwable)=&gt;Boolean):Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#onErrorRestartIf(p:Throwable=&gt;Boolean):monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRestartIf</span><span class="params">(<span name="p">p: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.0/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.Always.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new coeval that in case of error will retry executing the
source again and again, until it succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new coeval that in case of error will retry executing the
source again and again, until it succeeds.</p><p>In case of continuous failure the total number of executions
will be <code>maxRetries + 1</code>.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#onErrorRestartLoop" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRestartLoop[S,B&gt;:A](initial:S)(f:(Throwable,S,S=&gt;monix.eval.Coeval[B])=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]"></a><a id="onErrorRestartLoop[S,B&gt;:A](S)((Throwable,S,(S)=&gt;Coeval[B])=&gt;Coeval[B]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#onErrorRestartLoop[S,B&gt;:A](initial:S)(f:(Throwable,S,S=&gt;monix.eval.Coeval[B])=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRestartLoop</span><span class="tparams">[<span name="S">S</span>, <span name="B">B &gt;: <span name="monix.eval.Coeval.Always.A" class="extype">A</span></span>]</span><span class="params">(<span name="initial">initial: <span name="monix.eval.Coeval.onErrorRestartLoop.S" class="extype">S</span></span>)</span><span class="params">(<span name="f">f: (<span name="scala.Throwable" class="extype">Throwable</span>, <span name="monix.eval.Coeval.onErrorRestartLoop.S" class="extype">S</span>, (<span name="monix.eval.Coeval.onErrorRestartLoop.S" class="extype">S</span>) =&gt; <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorRestartLoop.B" class="extype">B</span>]) =&gt; <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorRestartLoop.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorRestartLoop.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">On error restarts the source with a customizable restart loop.</p><div class="fullcomment"><div class="comment cmt"><p>On error restarts the source with a customizable restart loop.</p><p>This operation keeps an internal <code>state</code>, with a start value, an internal
state that gets evolved and based on which the next step gets decided,
e.g. should it restart, or should it give up and rethrow the current error.</p><p>Example that implements a simple retry policy that retries for a maximum
of 10 times before giving up:</p><pre><span class="kw">import</span> scala.util.Random

<span class="kw">val</span> fa = Coeval {
  <span class="kw">if</span> (Random.nextInt(<span class="num">20</span>) &gt; <span class="num">10</span>)
    <span class="kw">throw</span> <span class="kw">new</span> RuntimeException(<span class="lit">"boo"</span>)
  <span class="kw">else</span> <span class="num">78</span>
}

fa.onErrorRestartLoop(<span class="num">10</span>) { (err, maxRetries, retry) <span class="kw">=&gt;</span>
  <span class="kw">if</span> (maxRetries &gt; <span class="num">0</span>)
    <span class="cmt">// Do next retry please</span>
    retry(maxRetries - <span class="num">1</span>)
  <span class="kw">else</span>
    <span class="cmt">// No retries left, rethrow the error</span>
    Coeval.raiseError(err)
}</pre><p>The given function injects the following parameters:</p><ol class="decimal"><li><code>error</code> reference that was thrown
 2. the current <code>state</code>, based on which a decision for the retry is made
 3. <code>retry: S =&gt; Task[B]</code> function that schedules the next retry
</li></ol></div><dl class="paramcmts block"><dt class="param">initial</dt><dd class="cmt"><p>is the initial state used to determine the next on error
       retry cycle</p></dd><dt class="param">f</dt><dd class="cmt"><p>is a function that injects the current error, state, a
       function that can signal a retry is to be made and returns
       the next coeval</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="scala.Product#productElementNames" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="productElementNames:Iterator[String]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#productElementNames:Iterator[String]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">productElementNames</span><span class="result">: <span name="scala.Iterator" class="extype">Iterator</span>[<span name="scala.Predef.String" class="extype">String</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Product</dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#redeem" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="redeem[B](recover:Throwable=&gt;B,map:A=&gt;B):monix.eval.Coeval[B]"></a><a id="redeem[B]((Throwable)=&gt;B,(A)=&gt;B):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#redeem[B](recover:Throwable=&gt;B,map:A=&gt;B):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">redeem</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="recover">recover: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <span name="monix.eval.Coeval.redeem.B" class="extype">B</span></span>, <span name="map">map: (<span name="monix.eval.Coeval.Always.A" class="extype">A</span>) =&gt; <span name="monix.eval.Coeval.redeem.B" class="extype">B</span></span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.redeem.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a new value that transforms the result of the source,
given the <code>recover</code> or <code>map</code> functions, which get executed depending
on whether the result is successful or if it ends in error.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new value that transforms the result of the source,
given the <code>recover</code> or <code>map</code> functions, which get executed depending
on whether the result is successful or if it ends in error.</p><p>This is an optimization on usage of <a href="Coeval.html#attempt:monix.eval.Coeval[Either[Throwable,A]]" name="monix.eval.Coeval#attempt" id="monix.eval.Coeval#attempt" class="extmbr">attempt</a> and <a href="Coeval.html#map[B](f:A=&gt;B):monix.eval.Coeval[B]" name="monix.eval.Coeval#map" id="monix.eval.Coeval#map" class="extmbr">map</a>,
this equivalence being true:</p><p><code>coeval.redeem(recover, map) &lt;-&gt; coeval.attempt.map(_.fold(recover, map))</code></p><p>Usage of <code>redeem</code> subsumes <a href="Coeval.html#onErrorHandle[U&gt;:A](f:Throwable=&gt;U):monix.eval.Coeval[U]" name="monix.eval.Coeval#onErrorHandle" id="monix.eval.Coeval#onErrorHandle" class="extmbr">onErrorHandle</a> because:</p><p><code>coeval.redeem(fe, id) &lt;-&gt; coeval.onErrorHandle(fe)</code>
</p></div><dl class="paramcmts block"><dt class="param">recover</dt><dd class="cmt"><p>is a function used for error recover in case the
       source ends in error</p></dd><dt class="param">map</dt><dd class="cmt"><p>is a function used for mapping the result of the source
       in case it ends in success</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#redeemWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="redeemWith[B](recover:Throwable=&gt;monix.eval.Coeval[B],bind:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]"></a><a id="redeemWith[B]((Throwable)=&gt;Coeval[B],(A)=&gt;Coeval[B]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#redeemWith[B](recover:Throwable=&gt;monix.eval.Coeval[B],bind:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">redeemWith</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="recover">recover: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.redeemWith.B" class="extype">B</span>]</span>, <span name="bind">bind: (<span name="monix.eval.Coeval.Always.A" class="extype">A</span>) =&gt; <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.redeemWith.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.redeemWith.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a new value that transforms the result of the source,
given the <code>recover</code> or <code>bind</code> functions, which get executed depending
on whether the result is successful or if it ends in error.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new value that transforms the result of the source,
given the <code>recover</code> or <code>bind</code> functions, which get executed depending
on whether the result is successful or if it ends in error.</p><p>This is an optimization on usage of <a href="Coeval.html#attempt:monix.eval.Coeval[Either[Throwable,A]]" name="monix.eval.Coeval#attempt" id="monix.eval.Coeval#attempt" class="extmbr">attempt</a> and <a href="Coeval.html#flatMap[B](f:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#flatMap" id="monix.eval.Coeval#flatMap" class="extmbr">flatMap</a>,
this equivalence being available:</p><p><code>coeval.redeemWith(recover, bind) &lt;-&gt; coeval.attempt.flatMap(_.fold(recover, bind))</code></p><p>Usage of <code>redeemWith</code> subsumes <a href="Coeval.html#onErrorHandleWith[B&gt;:A](f:Throwable=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#onErrorHandleWith" id="monix.eval.Coeval#onErrorHandleWith" class="extmbr">onErrorHandleWith</a> because:</p><p><code>coeval.redeemWith(fe, F.pure) &lt;-&gt; coeval.onErrorHandleWith(fe)</code></p><p>Usage of <code>redeemWith</code> also subsumes <a href="Coeval.html#flatMap[B](f:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#flatMap" id="monix.eval.Coeval#flatMap" class="extmbr">flatMap</a> because:</p><p><code>coeval.redeemWith(Coeval.raiseError, fs) &lt;-&gt; coeval.flatMap(fs)</code>
</p></div><dl class="paramcmts block"><dt class="param">recover</dt><dd class="cmt"><p>is the function that gets called to recover the source
       in case of error</p></dd><dt class="param">bind</dt><dd class="cmt"><p>is the function that gets to transform the source
       in case of success</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#restartUntil" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="restartUntil(p:A=&gt;Boolean):monix.eval.Coeval[A]"></a><a id="restartUntil((A)=&gt;Boolean):Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#restartUntil(p:A=&gt;Boolean):monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">restartUntil</span><span class="params">(<span name="p">p: (<span name="monix.eval.Coeval.Always.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.0/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.Always.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Given a predicate function, keep retrying the
coeval until the function returns true.</p><div class="fullcomment"><div class="comment cmt"><p>Given a predicate function, keep retrying the
coeval until the function returns true.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval.Always#run" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="run():monix.eval.Coeval.Eager[A]"></a><a id="run():Eager[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#run():monix.eval.Coeval.Eager[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">run</span><span class="params">()</span><span class="result">: <a href="Coeval$$Eager.html" name="monix.eval.Coeval.Eager" id="monix.eval.Coeval.Eager" class="extype">Eager</a>[<span name="monix.eval.Coeval.Always.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Evaluates the underlying computation, reducing this <code>Coeval</code>
to a <a href="Coeval$$Eager.html" name="monix.eval.Coeval.Eager" id="monix.eval.Coeval.Eager" class="extype">Coeval.Eager</a> value, with successful results being
signaled with <a href="Coeval$$Now.html" name="monix.eval.Coeval.Now" id="monix.eval.Coeval.Now" class="extype">Coeval.Now</a> and failures with <a href="Coeval$$Error.html" name="monix.eval.Coeval.Error" id="monix.eval.Coeval.Error" class="extype">Coeval.Error</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Evaluates the underlying computation, reducing this <code>Coeval</code>
to a <a href="Coeval$$Eager.html" name="monix.eval.Coeval.Eager" id="monix.eval.Coeval.Eager" class="extype">Coeval.Eager</a> value, with successful results being
signaled with <a href="Coeval$$Now.html" name="monix.eval.Coeval.Now" id="monix.eval.Coeval.Now" class="extype">Coeval.Now</a> and failures with <a href="Coeval$$Error.html" name="monix.eval.Coeval.Error" id="monix.eval.Coeval.Error" class="extype">Coeval.Error</a>.</p><pre><span class="kw">val</span> fa = Coeval.eval(<span class="num">10</span> * <span class="num">2</span>)

fa.run <span class="kw">match</span> {
  <span class="kw">case</span> Coeval.Now(value) <span class="kw">=&gt;</span>
    println(<span class="lit">"Success: "</span> + value)
  <span class="kw">case</span> Coeval.Error(e) <span class="kw">=&gt;</span>
    e.printStackTrace()
}</pre><p>See <a href="#runAttempt():Either[Throwable,A]" name="monix.eval.Coeval.Always#runAttempt" id="monix.eval.Coeval.Always#runAttempt" class="extmbr">runAttempt</a> for working with <a href="https://www.scala-lang.org/api/2.13.0/scala/index.html#Either[+A,+B]=scala.util.Either[A,B]" name="scala" id="scala" class="extype">Either</a>
values and <a href="#runTry():scala.util.Try[A]" name="monix.eval.Coeval.Always#runTry" id="monix.eval.Coeval.Always#runTry" class="extmbr">runTry</a> for working with <a href="https://www.scala-lang.org/api/2.13.0/scala/util/Try.html" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a>
values. See <a href="#apply():A" name="monix.eval.Coeval.Always#apply" id="monix.eval.Coeval.Always#apply" class="extmbr">apply</a> for a partial function (that may throw
exceptions in case of failure).</p><p><b>UNSAFE</b> — this operation can trigger the
        execution of side effects, which break referential
        transparency and is thus not a pure function.</p><p>        In FP code use with care, suspended in another <code>Coeval</code>
        or <a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>, or at the edge of the FP
        program.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="" name="monix.eval.Coeval.Always" id="monix.eval.Coeval.Always" class="extype">Always</a> → <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval.Always#runAttempt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runAttempt():Either[Throwable,A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#runAttempt():Either[Throwable,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runAttempt</span><span class="params">()</span><span class="result">: <span name="scala.Either" class="extype">Either</span>[<span name="scala.Throwable" class="extype">Throwable</span>, <span name="monix.eval.Coeval.Always.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Evaluates the underlying computation and returns the result or
any triggered errors as a Scala <code>Either</code>, where <code>Right(_)</code> is
for successful values and <code>Left(_)</code> is for thrown errors.</p><div class="fullcomment"><div class="comment cmt"><p>Evaluates the underlying computation and returns the result or
any triggered errors as a Scala <code>Either</code>, where <code>Right(_)</code> is
for successful values and <code>Left(_)</code> is for thrown errors.</p><pre><span class="kw">val</span> fa = Coeval(<span class="num">10</span> * <span class="num">2</span>)

fa.runAttempt <span class="kw">match</span> {
  <span class="kw">case</span> Right(value) <span class="kw">=&gt;</span>
    println(<span class="lit">"Success: "</span> + value)
  <span class="kw">case</span> Left(e) <span class="kw">=&gt;</span>
    e.printStackTrace()
}</pre><p>See <a href="#run():monix.eval.Coeval.Eager[A]" name="monix.eval.Coeval.Always#run" id="monix.eval.Coeval.Always#run" class="extmbr">run</a> for working with <a href="Coeval$$Eager.html" name="monix.eval.Coeval.Eager" id="monix.eval.Coeval.Eager" class="extype">Coeval.Eager</a> values and
<a href="#runTry():scala.util.Try[A]" name="monix.eval.Coeval.Always#runTry" id="monix.eval.Coeval.Always#runTry" class="extmbr">runTry</a> for working with <a href="https://www.scala-lang.org/api/2.13.0/scala/util/Try.html" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a> values.
See <a href="#apply():A" name="monix.eval.Coeval.Always#apply" id="monix.eval.Coeval.Always#apply" class="extmbr">apply</a> for a partial function (that may throw exceptions
in case of failure).</p><p><b>UNSAFE</b> — this operation can trigger the
        execution of side effects, which break referential
        transparency and is thus not a pure function.</p><p>        In FP code use with care, suspended in another <code>Coeval</code>
        or <a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>, or at the edge of the FP
        program.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="" name="monix.eval.Coeval.Always" id="monix.eval.Coeval.Always" class="extype">Always</a> → <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval.Always#runTry" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runTry():scala.util.Try[A]"></a><a id="runTry():Try[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#runTry():scala.util.Try[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runTry</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.0/scala/util/Try.html#scala.util.Try" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a>[<span name="monix.eval.Coeval.Always.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Evaluates the underlying computation and returns the
result or any triggered errors as a <code>scala.util.Try</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Evaluates the underlying computation and returns the
result or any triggered errors as a <code>scala.util.Try</code>.</p><pre><span class="kw">import</span> scala.util._

<span class="kw">val</span> fa = Coeval(<span class="num">10</span> * <span class="num">2</span>)

fa.runTry <span class="kw">match</span> {
  <span class="kw">case</span> Success(value) <span class="kw">=&gt;</span>
    println(<span class="lit">"Success: "</span> + value)
  <span class="kw">case</span> Failure(e) <span class="kw">=&gt;</span>
    e.printStackTrace()
}</pre><p>See <a href="#run():monix.eval.Coeval.Eager[A]" name="monix.eval.Coeval.Always#run" id="monix.eval.Coeval.Always#run" class="extmbr">run</a> for working with <a href="Coeval$$Eager.html" name="monix.eval.Coeval.Eager" id="monix.eval.Coeval.Eager" class="extype">Coeval.Eager</a> values and
<a href="#runAttempt():Either[Throwable,A]" name="monix.eval.Coeval.Always#runAttempt" id="monix.eval.Coeval.Always#runAttempt" class="extmbr">runAttempt</a> for working with <a href="https://www.scala-lang.org/api/2.13.0/scala/index.html#Either[+A,+B]=scala.util.Either[A,B]" name="scala" id="scala" class="extype">Either</a> values.
See <a href="#apply():A" name="monix.eval.Coeval.Always#apply" id="monix.eval.Coeval.Always#apply" class="extmbr">apply</a> for a partial function (that may throw exceptions
in case of failure).</p><p><b>UNSAFE</b> — this operation can trigger the
        execution of side effects, which break referential
        transparency and is thus not a pure function.</p><p>        In FP code use with care, suspended in another <code>Coeval</code>
        or <a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>, or at the edge of the FP
        program.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="" name="monix.eval.Coeval.Always" id="monix.eval.Coeval.Always" class="extype">Always</a> → <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](=&gt;T0):T0"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#to" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="to[F[_]](implicitF:monix.eval.CoevalLift[F]):F[A@scala.annotation.unchecked.uncheckedVariance]"></a><a id="to[F[_]](CoevalLift[F]):F[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#to[F[_]](implicitF:monix.eval.CoevalLift[F]):F[A@scala.annotation.unchecked.uncheckedVariance]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">to</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="CoevalLift.html" name="monix.eval.CoevalLift" id="monix.eval.CoevalLift" class="extype">CoevalLift</a>[<span name="monix.eval.Coeval.to.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.eval.Coeval.to.F" class="extype">F</span>[<span name="monix.eval.Coeval.Always.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Converts the source <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> into any <code>F[_]</code> that implements
<code>cats.effect.Sync</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Converts the source <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> into any <code>F[_]</code> that implements
<code>cats.effect.Sync</code>.</p><p>For example it can work with <code>cats.effect.IO</code>:</p><pre><span class="kw">import</span> cats._
<span class="kw">import</span> cats.effect._

<span class="kw">val</span> source = Coeval { <span class="num">1</span> + <span class="num">1</span> }

<span class="kw">val</span> asIO: IO[<span class="std">Int</span>]     = source.to[IO]
<span class="kw">val</span> asEval: Eval[<span class="std">Int</span>] = source.to[Eval]
<span class="kw">val</span> asTask: Task[<span class="std">Int</span>] = source.to[Task]</pre></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> → Function0 → AnyRef → Any</dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#toSync" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toSync[F[_]](implicitF:cats.effect.Sync[F]):F[A@scala.annotation.unchecked.uncheckedVariance]"></a><a id="toSync[F[_]](Sync[F]):F[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#toSync[F[_]](implicitF:cats.effect.Sync[F]):F[A@scala.annotation.unchecked.uncheckedVariance]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toSync</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.eval.Coeval.toSync.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.eval.Coeval.toSync.F" class="extype">F</span>[<span name="monix.eval.Coeval.Always.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Converts the source to any value that implements <code>cats.effect.Sync</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Converts the source to any value that implements <code>cats.effect.Sync</code>.</p><p>Prefer to use <a href="Coeval.html#to[F[_]](implicitF:monix.eval.CoevalLift[F]):F[A@scala.annotation.unchecked.uncheckedVariance]" name="monix.eval.Coeval#to" id="monix.eval.Coeval#to" class="extmbr">to</a>, this method is provided in order to force
the usage of <code>cats.effect.Sync</code> instances (instead of <a href="CoevalLift.html" name="monix.eval.CoevalLift" id="monix.eval.CoevalLift" class="extype">CoevalLift</a>).
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#value" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="value():A"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#value():A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">value</span><span class="params">()</span><span class="result">: <span name="monix.eval.Coeval.Always.A" class="extype">A</span></span></span><p class="shortcomment cmt">Evaluates the underlying computation and returns the result.</p><div class="fullcomment"><div class="comment cmt"><p>Evaluates the underlying computation and returns the result.</p><p>NOTE: this can throw exceptions.</p><p>Alias for <a href="Coeval.html#apply():A" name="monix.eval.Coeval#apply" id="monix.eval.Coeval#apply" class="extmbr">apply</a>.</p><p><b>UNSAFE</b> — this operation can trigger the
        execution of side effects, which break referential
        transparency and is thus not a pure function.</p><p>        In FP code use with care, suspended in another <code>Coeval</code>
        or <a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>, or at the edge of the FP
        program.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#void" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="void:monix.eval.Coeval[Unit]"></a><a id="void:Coeval[Unit]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#void:monix.eval.Coeval[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">void</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<a href="https://www.scala-lang.org/api/2.13.0/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Returns this coeval mapped to unit
</p><div class="fullcomment"><div class="comment cmt"><p>Returns this coeval mapped to unit
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.0/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.0/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="arg1">arg1: <a href="https://www.scala-lang.org/api/2.13.0/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.0/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.0/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.0/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#zip" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zip[B](that:monix.eval.Coeval[B]):monix.eval.Coeval[(A,B)]"></a><a id="zip[B](Coeval[B]):Coeval[(A,B)]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#zip[B](that:monix.eval.Coeval[B]):monix.eval.Coeval[(A,B)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zip</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="that">that: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.zip.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[(<span name="monix.eval.Coeval.Always.A" class="extype">A</span>, <span name="monix.eval.Coeval.zip.B" class="extype">B</span>)]</span></span><p class="shortcomment cmt">Zips the values of <code>this</code> and <code>that</code> coeval, and creates a new coeval
that will emit the tuple of their results.</p><div class="fullcomment"><div class="comment cmt"><p>Zips the values of <code>this</code> and <code>that</code> coeval, and creates a new coeval
that will emit the tuple of their results.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#zipMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zipMap[B,C](that:monix.eval.Coeval[B])(f:(A,B)=&gt;C):monix.eval.Coeval[C]"></a><a id="zipMap[B,C](Coeval[B])((A,B)=&gt;C):Coeval[C]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#zipMap[B,C](that:monix.eval.Coeval[B])(f:(A,B)=&gt;C):monix.eval.Coeval[C]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zipMap</span><span class="tparams">[<span name="B">B</span>, <span name="C">C</span>]</span><span class="params">(<span name="that">that: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.zipMap.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.eval.Coeval.Always.A" class="extype">A</span>, <span name="monix.eval.Coeval.zipMap.B" class="extype">B</span>) =&gt; <span name="monix.eval.Coeval.zipMap.C" class="extype">C</span></span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.zipMap.C" class="extype">C</span>]</span></span><p class="shortcomment cmt">Zips the values of <code>this</code> and <code>that</code> and applies the given
mapping function on their results.</p><div class="fullcomment"><div class="comment cmt"><p>Zips the values of <code>this</code> and <code>that</code> and applies the given
mapping function on their results.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd></dl></div></li></ol></div><div class="values members"><h3>Deprecated Value Members</h3><ol><li class="indented0 " name="monix.eval.Coeval#transform" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="transform[R](fa:A=&gt;R,fe:Throwable=&gt;R):monix.eval.Coeval[R]"></a><a id="transform[R]((A)=&gt;R,(Throwable)=&gt;R):Coeval[R]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#transform[R](fa:A=&gt;R,fe:Throwable=&gt;R):monix.eval.Coeval[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: (Since version 3.0.0-RC2) Please use Coeval.redeem">transform</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="fa">fa: (<span name="monix.eval.Coeval.Always.A" class="extype">A</span>) =&gt; <span name="monix.eval.Coeval.transform.R" class="extype">R</span></span>, <span name="fe">fe: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <span name="monix.eval.Coeval.transform.R" class="extype">R</span></span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.transform.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Deprecated — use <a href="Coeval.html#redeem[B](recover:Throwable=&gt;B,map:A=&gt;B):monix.eval.Coeval[B]" name="monix.eval.Coeval#redeem" id="monix.eval.Coeval#redeem" class="extmbr">redeem</a> instead.</p><div class="fullcomment"><div class="comment cmt"><p>Deprecated — use <a href="Coeval.html#redeem[B](recover:Throwable=&gt;B,map:A=&gt;B):monix.eval.Coeval[B]" name="monix.eval.Coeval#redeem" id="monix.eval.Coeval#redeem" class="extmbr">redeem</a> instead.</p><p><a href="Coeval.html#redeem[B](recover:Throwable=&gt;B,map:A=&gt;B):monix.eval.Coeval[B]" name="monix.eval.Coeval#redeem" id="monix.eval.Coeval#redeem" class="extmbr">Coeval.redeem</a> is the same operation, but with a different name and the
function parameters in an inverted order, to make it consistent with <code>fold</code>
on <code>Either</code> and others (i.e. the function for error recovery is at the left).
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 3.0.0-RC2)</i> Please use <code>Coeval.redeem</code></p></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#transformWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="transformWith[R](fa:A=&gt;monix.eval.Coeval[R],fe:Throwable=&gt;monix.eval.Coeval[R]):monix.eval.Coeval[R]"></a><a id="transformWith[R]((A)=&gt;Coeval[R],(Throwable)=&gt;Coeval[R]):Coeval[R]"></a> <span class="permalink"><a href="../../monix/eval/Coeval$$Always.html#transformWith[R](fa:A=&gt;monix.eval.Coeval[R],fe:Throwable=&gt;monix.eval.Coeval[R]):monix.eval.Coeval[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: (Since version 3.0.0-RC2) Please use Coeval.redeemWith">transformWith</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="fa">fa: (<span name="monix.eval.Coeval.Always.A" class="extype">A</span>) =&gt; <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.transformWith.R" class="extype">R</span>]</span>, <span name="fe">fe: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.transformWith.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.transformWith.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Deprecated — use <a href="Coeval.html#redeemWith[B](recover:Throwable=&gt;monix.eval.Coeval[B],bind:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#redeemWith" id="monix.eval.Coeval#redeemWith" class="extmbr">redeemWith</a> instead.</p><div class="fullcomment"><div class="comment cmt"><p>Deprecated — use <a href="Coeval.html#redeemWith[B](recover:Throwable=&gt;monix.eval.Coeval[B],bind:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#redeemWith" id="monix.eval.Coeval#redeemWith" class="extmbr">redeemWith</a> instead.</p><p><a href="Coeval.html#redeemWith[B](recover:Throwable=&gt;monix.eval.Coeval[B],bind:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#redeemWith" id="monix.eval.Coeval#redeemWith" class="extmbr">Coeval.redeemWith</a> is the same operation, but with a different name and the
function parameters in an inverted order, to make it consistent with <code>fold</code>
on <code>Either</code> and others (i.e. the function for error recovery is at the left).
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a></dd><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 3.0.0-RC2)</i> Please use <code>Coeval.redeemWith</code></p></dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="scala.Product" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.0/scala/Product.html#scala.Product" name="scala.Product" id="scala.Product" class="extype">Product</a></h3></div><div name="scala.Equals" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.0/scala/Equals.html#scala.Equals" name="scala.Equals" id="scala.Equals" class="extype">Equals</a></h3></div><div name="monix.eval.Coeval" class="parent"><h3>Inherited from <a href="Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.Always.A" class="extype">A</span>]</h3></div><div name="java.io.Serializable" class="parent"><h3>Inherited from <span name="java.io.Serializable" class="extype">Serializable</span></h3></div><div name="scala.Function0" class="parent"><h3>Inherited from () =&gt; <span name="monix.eval.Coeval.Always.A" class="extype">A</span></h3></div><div name="scala.AnyRef" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.0/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.0/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
