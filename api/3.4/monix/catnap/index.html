<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Monix 3.4.0 - monix.catnap</title><meta content="Monix 3.4.0 - monix.catnap" name="description"/><meta content="Monix 3.4.0 monix.catnap" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../lib/jquery.min.js"></script><script type="text/javascript" src="../../lib/index.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript" src="../../lib/scheduler.js"></script><script type="text/javascript" src="../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../';</script></head><body><div id="search"><span id="doc-title">Monix<span id="doc-version">3.4.0</span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">root</span></a></span><p class="shortcomment cmt"><img src="https://monix.io/public/images/monix-logo.png" align="right" width="200" /></p><div class="fullcomment"><div class="comment cmt"><p><img src="https://monix.io/public/images/monix-logo.png" align="right" width="200" /></p><p>This is the API documentation for the <a href="https://monix.io" target="_blank">Monix</a> library.</p><h4>Package Overview</h4><p><b><a href="../execution/index.html" name="monix.execution" id="monix.execution" class="extype">monix.execution</a></b> exposes lower level primitives for dealing
with asynchronous execution:</p><ul><li><a href="../execution/atomic/index.html" name="monix.execution.atomic" id="monix.execution.atomic" class="extype">monix.execution.atomic</a> exposes the <code>Atomic</code> types, as alternative
   to <code>java.util.concurrent.atomic</code></li><li><a href="../execution/cancelables/index.html" name="monix.execution.cancelables" id="monix.execution.cancelables" class="extype">monix.execution.cancelables</a> contains several
   useful <a href="../execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a> implementations</li><li><a href="../execution/schedulers/index.html" name="monix.execution.schedulers" id="monix.execution.schedulers" class="extype">monix.execution.schedulers</a> contains several
   useful <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> implementations</li><li><a href="../execution/rstreams/index.html" name="monix.execution.rstreams" id="monix.execution.rstreams" class="extype">monix.execution.rstreams</a> contains helpers for dealing
   with the <a href="http://www.reactive-streams.org" target="_blank">Reactive Streams</a> specification</li><li><a href="../execution/misc/index.html" name="monix.execution.misc" id="monix.execution.misc" class="extype">monix.execution.misc</a> provides miscellaneous primitives
   useful for dealing with concurrency</li><li><a href="../execution/exceptions/index.html" name="monix.execution.exceptions" id="monix.execution.exceptions" class="extype">monix.execution.exceptions</a> groups some exceptions thrown by
   the implementation</li></ul><p><b><a href="" name="monix.catnap" id="monix.catnap" class="extype">monix.catnap</a></b> exposes pure abstractions built on top of
the <a href="https://typelevel.org/cats-effect/" target="_blank">Cats-Effect</a> type classes:</p><ul><li><a href="cancelables/index.html" name="monix.catnap.cancelables" id="monix.catnap.cancelables" class="extype">monix.catnap.cancelables</a> exposes pure counterparts to the
   cancelable data types described in <a href="../execution/cancelables/index.html" name="monix.execution.cancelables" id="monix.execution.cancelables" class="extype">monix.execution.cancelables</a></li></ul><p><b><a href="../eval/index.html" name="monix.eval" id="monix.eval" class="extype">monix.eval</a></b> is for dealing with evaluation of results, thus exposing
<a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> and <a href="../eval/Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>.</p><p><b><a href="../reactive/index.html" name="monix.reactive" id="monix.reactive" class="extype">monix.reactive</a></b> exposes the <code>Observable</code> pattern:</p><ul><li><a href="../reactive/observables/index.html" name="monix.reactive.observables" id="monix.reactive.observables" class="extype">monix.reactive.observables</a> groups reusable <code>Observable</code> implementations</li><li><a href="../reactive/observers/index.html" name="monix.reactive.observers" id="monix.reactive.observers" class="extype">monix.reactive.observers</a> groups reusable <a href="../reactive/Observer.html" name="monix.reactive.Observer" id="monix.reactive.Observer" class="extype">Observer</a>
   implementations</li><li><a href="../reactive/subjects/index.html" name="monix.reactive.subjects" id="monix.reactive.subjects" class="extype">monix.reactive.subjects</a> exposes <a href="../reactive/subjects/Subject.html" name="monix.reactive.subjects.Subject" id="monix.reactive.subjects.Subject" class="extype">Subject</a>
   and <a href="../reactive/subjects/ConcurrentSubject.html" name="monix.reactive.subjects.ConcurrentSubject" id="monix.reactive.subjects.ConcurrentSubject" class="extype">ConcurrentSubject</a>,
   which are implementations of hot observables that function both as input and output</li></ul><p><b><a href="../tail/index.html" name="monix.tail" id="monix.tail" class="extype">monix.tail</a></b> exposes <a href="../tail/Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a> for purely functional pull based streaming:</p><ul><li><a href="../tail/batches/index.html" name="monix.tail.batches" id="monix.tail.batches" class="extype">monix.tail.batches</a> describes <code>Batch</code> and <code>BatchCursor</code>, the
   alternatives to Scala's <code>Iterable</code> and <code>Iterator</code> respectively that
   we are using within Iterant's encoding</li></ul><p>You can control evaluation with type you choose - be it <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>, <a href="../eval/Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>, <a href="https://typelevel.org/cats-effect/api/cats/effect/IO.html" target="_blank">cats.effect.IO</a>
or your own as long as you provide correct <a href="https://typelevel.org/cats-effect/typeclasses/" target="_blank">cats-effect</a> or <a href="https://typelevel.org/cats/typeclasses.html" target="_blank">cats</a> typeclass instance.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.monix" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="monix"></a><a id="monix:monix"></a> <span class="permalink"><a href="../../monix/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">monix</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 current" name="monix.catnap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="catnap"></a><a id="catnap:catnap"></a> <span class="permalink"><a href="../../monix/catnap/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">catnap</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="monix" id="monix" class="extype">monix</a></dd></dl></div></li><li class="indented3 " name="monix.catnap.cancelables" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="cancelables"></a><a id="cancelables:cancelables"></a> <span class="permalink"><a href="../../monix/catnap/cancelables/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="cancelables/index.html" title=""><span class="name">cancelables</span></a></span></li><li class="current-entities indented2"><a href="CancelableF$.html" title="" class="object"></a> <a href="CancelableF.html" title="Represents a pure data structure that describes an effectful, idempotent action that can be used to cancel async computations, or to release resources." class="trait"></a><a href="CancelableF.html" title="Represents a pure data structure that describes an effectful, idempotent action that can be used to cancel async computations, or to release resources.">CancelableF</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="ChannelF.html" title="Channel is a communication channel that can be consumed via consume." class="trait"></a><a href="ChannelF.html" title="Channel is a communication channel that can be consumed via consume.">ChannelF</a></li><li class="current-entities indented2"><a href="CircuitBreaker$.html" title="" class="object"></a> <a href="CircuitBreaker.html" title="The CircuitBreaker is used to provide stability and prevent cascading failures in distributed systems." class="class"></a><a href="CircuitBreaker.html" title="The CircuitBreaker is used to provide stability and prevent cascading failures in distributed systems.">CircuitBreaker</a></li><li class="current-entities indented2"><a href="ConcurrentChannel$.html" title="" class="object"></a> <a href="ConcurrentChannel.html" title="ConcurrentChannel can be used to model complex producer-consumer communication channels." class="class"></a><a href="ConcurrentChannel.html" title="ConcurrentChannel can be used to model complex producer-consumer communication channels.">ConcurrentChannel</a></li><li class="current-entities indented2"><a href="ConcurrentQueue$.html" title="" class="object"></a> <a href="ConcurrentQueue.html" title="A high-performance, back-pressured, generic concurrent queue implementation." class="class"></a><a href="ConcurrentQueue.html" title="A high-performance, back-pressured, generic concurrent queue implementation.">ConcurrentQueue</a></li><li class="current-entities indented2"><a href="ConsumerF$.html" title="" class="object"></a> <a href="ConsumerF.html" title="A simple interface that models the consumer side of a producer-consumer communication channel." class="trait"></a><a href="ConsumerF.html" title="A simple interface that models the consumer side of a producer-consumer communication channel.">ConsumerF</a></li><li class="current-entities indented2"><a href="FutureLift$.html" title="" class="object"></a> <a href="FutureLift.html" title="A type class for conversions from scala.concurrent.Future or other Future-like data type (e.g." class="trait"></a><a href="FutureLift.html" title="A type class for conversions from scala.concurrent.Future or other Future-like data type (e.g.">FutureLift</a></li><li class="current-entities indented2"><a href="MVar$.html" title="" class="object"></a> <a href="MVar.html" title="A mutable location, that is either empty or contains a value of type A." class="class"></a><a href="MVar.html" title="A mutable location, that is either empty or contains a value of type A.">MVar</a></li><li class="current-entities indented2"><a href="OrElse$.html" title="" class="object"></a> <a href="OrElse.html" title="A type class for prioritized implicit search." class="trait"></a><a href="OrElse.html" title="A type class for prioritized implicit search.">OrElse</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="ProducerF.html" title="A simple interface that models the producer side of a producer-consumer communication channel." class="trait"></a><a href="ProducerF.html" title="A simple interface that models the producer side of a producer-consumer communication channel.">ProducerF</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="SchedulerEffect$.html" title="" class="object"></a><a href="SchedulerEffect$.html" title="">SchedulerEffect</a></li><li class="current-entities indented2"><a href="Semaphore$.html" title="" class="object"></a> <a href="Semaphore.html" title="The Semaphore is an asynchronous semaphore implementation that limits the parallelism on task execution." class="class"></a><a href="Semaphore.html" title="The Semaphore is an asynchronous semaphore implementation that limits the parallelism on task execution.">Semaphore</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="syntax$.html" title="" class="object"></a><a href="syntax$.html" title="">syntax</a></li><li class="indented2 " name="monix.eval" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eval"></a><a id="eval:eval"></a> <span class="permalink"><a href="../../monix/eval/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../eval/index.html" title=""><span class="name">eval</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="monix" id="monix" class="extype">monix</a></dd></dl></div></li><li class="indented2 " name="monix.execution" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="execution"></a><a id="execution:execution"></a> <span class="permalink"><a href="../../monix/execution/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../execution/index.html" title=""><span class="name">execution</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="monix" id="monix" class="extype">monix</a></dd></dl></div></li><li class="indented2 " name="monix.reactive" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="reactive"></a><a id="reactive:reactive"></a> <span class="permalink"><a href="../../monix/reactive/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../reactive/index.html" title=""><span class="name">reactive</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="monix" id="monix" class="extype">monix</a></dd></dl></div></li><li class="indented2 " name="monix.tail" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="tail"></a><a id="tail:tail"></a> <span class="permalink"><a href="../../monix/tail/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../tail/index.html" title=""><span class="name">tail</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="monix" id="monix" class="extype">monix</a></dd></dl></div></li></ul></div></div><div id="content"><body class="package value"><div id="definition"><div class="big-circle package">p</div><p id="owner"><a href="../index.html" name="monix" id="monix" class="extype">monix</a></p><h1>catnap<span class="permalink"><a href="../../monix/catnap/index.html" title="Permalink"><i class="material-icons"></i></a></span></h1></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">catnap</span></span></h4><div id="comment" class="fullcommenttop"></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="packages" class="package members"><h3>Package Members</h3><ol><li class="indented0 " name="monix.catnap.cancelables" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="cancelables"></a><a id="cancelables:cancelables"></a> <span class="permalink"><a href="../../monix/catnap/cancelables/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="cancelables/index.html" title=""><span class="name">cancelables</span></a></span></li></ol></div><div id="types" class="types members"><h3>Type Members</h3><ol><li class="indented0 " name="monix.catnap.CancelableF" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="CancelableF[F[_]]extendsAnyRef"></a><a id="CancelableF[F[_]]:CancelableF[F]"></a> <span class="permalink"><a href="../../monix/catnap/CancelableF.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="CancelableF.html" title="Represents a pure data structure that describes an effectful, idempotent action that can be used to cancel async computations, or to release resources."><span class="name">CancelableF</span></a><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="result"> extends <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span><p class="shortcomment cmt">Represents a pure data structure that describes an effectful,
idempotent action that can be used to cancel async computations,
or to release resources.</p><div class="fullcomment"><div class="comment cmt"><p>Represents a pure data structure that describes an effectful,
idempotent action that can be used to cancel async computations,
or to release resources.</p><p>This is the pure, higher-kinded equivalent of
<a href="../execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">monix.execution.Cancelable</a> and can be used in combination
with data types meant for managing effects, like
<code>Task</code>, <code>Coeval</code> or <code>cats.effect.IO</code>.</p><p>Note: the <code>F</code> suffix comes from this data type being abstracted
over <code>F[_]</code>.
</p></div></div></li><li class="indented0 " name="monix.catnap.ChannelF" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="ChannelF[F[_],E,A]extendsSerializable"></a><a id="ChannelF[F[_],E,A]:ChannelF[F,E,A]"></a> <span class="permalink"><a href="../../monix/catnap/ChannelF.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="ChannelF.html" title="Channel is a communication channel that can be consumed via consume."><span class="name">ChannelF</span></a><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="E">E</span>, <span name="A">A</span>]</span><span class="result"> extends <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt"><code>Channel</code> is a communication channel that can be consumed via
<a href="ChannelF.html#consume:cats.effect.Resource[F,monix.catnap.ConsumerF[F,E,A]]" name="monix.catnap.ChannelF#consume" id="monix.catnap.ChannelF#consume" class="extmbr">consume</a>.</p><div class="fullcomment"><div class="comment cmt"><p><code>Channel</code> is a communication channel that can be consumed via
<a href="ChannelF.html#consume:cats.effect.Resource[F,monix.catnap.ConsumerF[F,E,A]]" name="monix.catnap.ChannelF#consume" id="monix.catnap.ChannelF#consume" class="extmbr">consume</a>.</p><p>Examples:</p><ul><li><a href="ConcurrentChannel.html" name="monix.catnap.ConcurrentChannel" id="monix.catnap.ConcurrentChannel" class="extype">monix.catnap.ConcurrentChannel</a></li><li><a href="../tail/Iterant.html#toChannel(implicitF:cats.effect.Concurrent[F],implicitcs:cats.effect.ContextShift[F]):monix.tail.Iterant.Channel[F,A]" name="monix.tail.Iterant#toChannel" id="monix.tail.Iterant#toChannel" class="extmbr">monix.tail.Iterant.toChannel</a>
</li></ul></div></div></li><li class="indented0 " name="monix.catnap.CircuitBreaker" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="CircuitBreaker[F[_]]extendsAnyRef"></a><a id="CircuitBreaker[F[_]]:CircuitBreaker[F]"></a> <span class="permalink"><a href="../../monix/catnap/CircuitBreaker.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="CircuitBreaker.html" title="The CircuitBreaker is used to provide stability and prevent cascading failures in distributed systems."><span class="name">CircuitBreaker</span></a><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="result"> extends <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span><p class="shortcomment cmt">The <code>CircuitBreaker</code> is used to provide stability and prevent
cascading failures in distributed systems.</p><div class="fullcomment"><div class="comment cmt"><p>The <code>CircuitBreaker</code> is used to provide stability and prevent
cascading failures in distributed systems.</p><h3>Purpose</h3><p>As an example, we have a web application interacting with a remote
third party web service. Let's say the third party has oversold
their capacity and their database melts down under load. Assume
that the database fails in such a way that it takes a very long
time to hand back an error to the third party web service. This in
turn makes calls fail after a long period of time.  Back to our
web application, the users have noticed that their form
submissions take much longer seeming to hang. Well the users do
what they know to do which is use the refresh button, adding more
requests to their already running requests.  This eventually
causes the failure of the web application due to resource
exhaustion. This will affect all users, even those who are not
using functionality dependent on this third party web service.</p><p>Introducing circuit breakers on the web service call would cause
the requests to begin to fail-fast, letting the user know that
something is wrong and that they need not refresh their
request. This also confines the failure behavior to only those
users that are using functionality dependent on the third party,
other users are no longer affected as there is no resource
exhaustion. Circuit breakers can also allow savvy developers to
mark portions of the site that use the functionality unavailable,
or perhaps show some cached content as appropriate while the
breaker is open.</p><h3>How It Works</h3><p>The circuit breaker models a concurrent state machine that
can be in any of these 3 states:</p><ol class="decimal"><li><a href="CircuitBreaker$$Closed.html" name="monix.catnap.CircuitBreaker.Closed" id="monix.catnap.CircuitBreaker.Closed" class="extype">Closed</a>: During normal
    operations or when the <code>CircuitBreaker</code> starts<ul><li>Exceptions increment the <code>failures</code> counter</li><li>Successes reset the failure count to zero</li><li>When the <code>failures</code> counter reaches the <code>maxFailures</code> count,
     the breaker is tripped into <code>Open</code> state</li></ul></li><li><a href="CircuitBreaker$$Open.html" name="monix.catnap.CircuitBreaker.Open" id="monix.catnap.CircuitBreaker.Open" class="extype">Open</a>: The circuit breaker
    rejects all tasks with an
    <a href="../execution/exceptions/ExecutionRejectedException.html" name="monix.execution.exceptions.ExecutionRejectedException" id="monix.execution.exceptions.ExecutionRejectedException" class="extype">ExecutionRejectedException</a><ul><li>all tasks fail fast with <code>ExecutionRejectedException</code></li><li>after the configured <code>resetTimeout</code>, the circuit breaker
     enters a <a href="CircuitBreaker$$HalfOpen.html" name="monix.catnap.CircuitBreaker.HalfOpen" id="monix.catnap.CircuitBreaker.HalfOpen" class="extype">HalfOpen</a> state,
     allowing one task to go through for testing the connection</li></ul></li><li><a href="CircuitBreaker$$HalfOpen.html" name="monix.catnap.CircuitBreaker.HalfOpen" id="monix.catnap.CircuitBreaker.HalfOpen" class="extype">HalfOpen</a>: The circuit breaker
    has already allowed a task to go through, as a reset attempt,
    in order to test the connection<ul><li>The first task when <code>Open</code> has expired is allowed through
     without failing fast, just before the circuit breaker is
     evolved into the <code>HalfOpen</code> state</li><li>All tasks attempted in <code>HalfOpen</code> fail-fast with an exception
     just as in <a href="CircuitBreaker$$Open.html" name="monix.catnap.CircuitBreaker.Open" id="monix.catnap.CircuitBreaker.Open" class="extype">Open</a> state</li><li>If that task attempt succeeds, the breaker is reset back to
     the <code>Closed</code> state, with the <code>resetTimeout</code> and the
     <code>failures</code> count also reset to initial values</li><li>If the first call fails, the breaker is tripped again into
     the <code>Open</code> state (the <code>resetTimeout</code> is multiplied by the
     exponential backoff factor)</li></ul></li></ol><h3>Usage</h3><pre><span class="kw">import</span> monix.catnap._
<span class="kw">import</span> scala.concurrent.duration._

<span class="cmt">// Using cats.effect.IO for this sample, but you can use any effect</span>
<span class="cmt">// type that integrates with Cats-Effect, including monix.eval.Task:</span>
<span class="kw">import</span> cats.effect.{Clock, IO}
<span class="kw">implicit</span> <span class="kw">val</span> clock: Clock[IO] = Clock.create[IO]

<span class="cmt">// Using the "unsafe" builder for didactic purposes, but prefer</span>
<span class="cmt">// the safe "apply" builder:</span>
<span class="kw">val</span> circuitBreaker = CircuitBreaker[IO].unsafe(
  maxFailures = <span class="num">5</span>,
  resetTimeout = <span class="num">10.</span>seconds
)

<span class="cmt">//...</span>
<span class="kw">val</span> problematic = IO {
  <span class="kw">val</span> nr = util.Random.nextInt()
  <span class="kw">if</span> (nr % <span class="num">2</span> == <span class="num">0</span>) nr <span class="kw">else</span>
    <span class="kw">throw</span> <span class="kw">new</span> RuntimeException(<span class="lit">"dummy"</span>)
}

<span class="kw">val</span> task = circuitBreaker.protect(problematic)</pre><p>When attempting to close the circuit breaker and resume normal
operations, we can also apply an exponential backoff for repeated
failed attempts, like so:</p><pre><span class="kw">val</span> exponential = CircuitBreaker[IO].of(
  maxFailures = <span class="num">5</span>,
  resetTimeout = <span class="num">10.</span>seconds,
  exponentialBackoffFactor = <span class="num">2</span>,
  maxResetTimeout = <span class="num">10.</span>minutes
)</pre><p>In this sample we attempt to reconnect after 10 seconds, then after
20, 40 and so on, a delay that keeps increasing up to a configurable
maximum of 10 minutes.</p><h4>Sync versus Async</h4><p>The <code>CircuitBreaker</code> works with both
<a href="https://typelevel.org/cats-effect/typeclasses/sync.html" target="_blank">Sync</a> and
<a href="https://typelevel.org/cats-effect/typeclasses/async.html" target="_blank">Async</a>
type class instances.</p><p>If the <code>F[_]</code> type used implements <code>Async</code>, then the <code>CircuitBreaker</code>
gains the ability to wait for it to be closed, via
<a href="CircuitBreaker.html#awaitClose(implicitF:monix.catnap.OrElse[cats.effect.Concurrent[F],cats.effect.Async[F]]):F[Unit]" name="monix.catnap.CircuitBreaker#awaitClose" id="monix.catnap.CircuitBreaker#awaitClose" class="extmbr">awaitClose</a>.</p><h4>Retrying Tasks</h4><p>Generally it's best if tasks are retried with an exponential back-off
strategy for async tasks.</p><pre><span class="kw">import</span> cats.implicits._
<span class="kw">import</span> cats.effect._
<span class="kw">import</span> monix.execution.exceptions.ExecutionRejectedException

<span class="kw">def</span> protectWithRetry[F[_], A](task: F[A], cb: CircuitBreaker[F], delay: FiniteDuration)
  (<span class="kw">implicit</span> F: Async[F], timer: Timer[F]): F[A] = {

  cb.protect(task).recoverWith {
    <span class="kw">case</span> _: ExecutionRejectedException <span class="kw">=&gt;</span>
      <span class="cmt">// Sleep, then retry</span>
      timer.sleep(delay).flatMap(_ <span class="kw">=&gt;</span> protectWithRetry(task, cb, delay * <span class="num">2</span>))
  }
}</pre><p>But an alternative is to wait for the precise moment at which the
<code>CircuitBreaker</code> is closed again and you can do so via the
<a href="CircuitBreaker.html#awaitClose(implicitF:monix.catnap.OrElse[cats.effect.Concurrent[F],cats.effect.Async[F]]):F[Unit]" name="monix.catnap.CircuitBreaker#awaitClose" id="monix.catnap.CircuitBreaker#awaitClose" class="extmbr">awaitClose</a> method:</p><pre><span class="kw">def</span> protectWithRetry2[F[_], A](task: F[A], cb: CircuitBreaker[F])
  (<span class="kw">implicit</span> F: Async[F]): F[A] = {

  cb.protect(task).recoverWith {
    <span class="kw">case</span> _: ExecutionRejectedException <span class="kw">=&gt;</span>
      <span class="cmt">// Waiting for the CircuitBreaker to close, then retry</span>
      cb.awaitClose.flatMap(_ <span class="kw">=&gt;</span> protectWithRetry2(task, cb))
  }
}</pre><p>Be careful when doing this, plan carefully, because you might end up with the
"<a href="https://en.wikipedia.org/wiki/Thundering_herd_problem" target="_blank">thundering herd problem</a>".</p><h3>Credits</h3><p>This Monix data type was inspired by the availability of
<a href="http://doc.akka.io/docs/akka/current/common/circuitbreaker.html" target="_blank">Akka's Circuit Breaker</a>.
</p></div></div></li><li class="indented0 " name="monix.catnap.ConcurrentChannel" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ConcurrentChannel[F[_],E,A]extendsProducerF[F,E,A]withChannelF[F,E,A]"></a><a id="ConcurrentChannel[F[_],E,A]:ConcurrentChannel[F,E,A]"></a> <span class="permalink"><a href="../../monix/catnap/ConcurrentChannel.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="ConcurrentChannel.html" title="ConcurrentChannel can be used to model complex producer-consumer communication channels."><span class="name">ConcurrentChannel</span></a><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="E">E</span>, <span name="A">A</span>]</span><span class="result"> extends <a href="ProducerF.html" name="monix.catnap.ProducerF" id="monix.catnap.ProducerF" class="extype">ProducerF</a>[<span name="monix.catnap.ConcurrentChannel.F" class="extype">F</span>, <span name="monix.catnap.ConcurrentChannel.E" class="extype">E</span>, <span name="monix.catnap.ConcurrentChannel.A" class="extype">A</span>] with <a href="ChannelF.html" name="monix.catnap.ChannelF" id="monix.catnap.ChannelF" class="extype">ChannelF</a>[<span name="monix.catnap.ConcurrentChannel.F" class="extype">F</span>, <span name="monix.catnap.ConcurrentChannel.E" class="extype">E</span>, <span name="monix.catnap.ConcurrentChannel.A" class="extype">A</span>]</span></span><p class="shortcomment cmt"><code>ConcurrentChannel</code> can be used to model complex producer-consumer communication channels.</p><div class="fullcomment"><div class="comment cmt"><p><code>ConcurrentChannel</code> can be used to model complex producer-consumer communication channels.</p><p>It exposes these fundamental operations:</p><ul><li><a href="ConcurrentChannel.html#push(a:A):F[Boolean]" name="monix.catnap.ConcurrentChannel#push" id="monix.catnap.ConcurrentChannel#push" class="extmbr">push</a> for pushing single events to consumers (producer side)</li><li><a href="ConcurrentChannel.html#pushMany(seq:Iterable[A]):F[Boolean]" name="monix.catnap.ConcurrentChannel#pushMany" id="monix.catnap.ConcurrentChannel#pushMany" class="extmbr">pushMany</a> for pushing event sequences to consumers (producer side)</li><li><a href="ConcurrentChannel.html#halt(e:E):F[Unit]" name="monix.catnap.ConcurrentChannel#halt" id="monix.catnap.ConcurrentChannel#halt" class="extmbr">halt</a> for pushing the final completion event to all consumers (producer side)</li><li><a href="ConcurrentChannel.html#consume:cats.effect.Resource[F,monix.catnap.ConsumerF[F,E,A]]" name="monix.catnap.ConcurrentChannel#consume" id="monix.catnap.ConcurrentChannel#consume" class="extmbr">consume</a> for creating a <a href="ConsumerF.html" name="monix.catnap.ConsumerF" id="monix.catnap.ConsumerF" class="extype">ConsumerF</a> value that can consume the
   incoming events from the channel</li></ul><h4>Example</h4><pre><span class="kw">import</span> cats.implicits._
<span class="kw">import</span> cats.effect._
<span class="kw">import</span> monix.execution.Scheduler.global

<span class="cmt">// For being able to do IO.start</span>
<span class="kw">implicit</span> <span class="kw">val</span> cs: ContextShift[IO] = SchedulerEffect.contextShift[IO](global)(IO.ioEffect)
<span class="cmt">// We need a `Timer` for this to work</span>
<span class="kw">implicit</span> <span class="kw">val</span> timer: Timer[IO] = SchedulerEffect.timer[IO](global)

<span class="cmt">// Completion event</span>
<span class="kw">sealed</span> <span class="kw">trait</span> Complete
<span class="kw">object</span> Complete <span class="kw">extends</span> Complete

<span class="kw">def</span> logLines(consumer: ConsumerF[IO, Complete, <span class="std">String</span>], index: <span class="std">Int</span>): IO[<span class="std">Unit</span>] =
  consumer.pull.flatMap {
    <span class="kw">case</span> Right(message) <span class="kw">=&gt;</span>
      IO(println(<span class="lit">"Worker $$index: $$message"</span>))
        <span class="cmt">// continue loop</span>
        .flatMap(_ <span class="kw">=&gt;</span> logLines(consumer, index))
    <span class="kw">case</span> Left(Complete) <span class="kw">=&gt;</span>
      IO(println(<span class="lit">"Worker $$index is done!"</span>))
  }

<span class="kw">for</span> {
  channel <span class="kw">&lt;-</span> ConcurrentChannel[IO].of[Complete, <span class="std">String</span>]
  <span class="cmt">// Workers 1 & 2, sharing the load between them</span>
  task_1_2 = channel.consume.use { ref <span class="kw">=&gt;</span>
    (logLines(ref, <span class="num">1</span>), logLines(ref, <span class="num">2</span>)).parSequence_
  }
  consumers_1_2 <span class="kw">&lt;-</span> task_1_2.start <span class="cmt">// fiber</span>
  <span class="cmt">// Workers 3 & 4, receiving the same events as workers 1 & 2,</span>
  <span class="cmt">// but sharing the load between them</span>
  task_3_4 = channel.consume.use { ref <span class="kw">=&gt;</span>
    (logLines(ref, <span class="num">3</span>), logLines(ref, <span class="num">4</span>)).parSequence_
  }
  consumers_3_4 <span class="kw">&lt;-</span> task_3_4.start <span class="cmt">// fiber</span>
  <span class="cmt">// Pushing some samples</span>
  _ <span class="kw">&lt;-</span> channel.push(<span class="lit">"Hello, "</span>)
  _ <span class="kw">&lt;-</span> channel.push(<span class="lit">"World!"</span>)
  <span class="cmt">// Signal there are no more events</span>
  _ <span class="kw">&lt;-</span> channel.halt(Complete)
  <span class="cmt">// Await for the completion of the consumers</span>
  _ <span class="kw">&lt;-</span> consumers_1_2.join
  _ <span class="kw">&lt;-</span> consumers_3_4.join
} <span class="kw">yield</span> ()</pre><h4>Unicasting vs Broadcasting vs Multicasting</h4><p><i>Unicasting</i>: A communication channel between one producer and one
<a href="ConsumerF.html" name="monix.catnap.ConsumerF" id="monix.catnap.ConsumerF" class="extype">ConsumerF</a>. Multiple workers can share the load of processing
incoming events. For example in case we want to have 8 workers running in
parallel, you can create one <a href="ConsumerF.html" name="monix.catnap.ConsumerF" id="monix.catnap.ConsumerF" class="extype">ConsumerF</a>, via <a href="ConcurrentChannel.html#consume:cats.effect.Resource[F,monix.catnap.ConsumerF[F,E,A]]" name="monix.catnap.ConcurrentChannel#consume" id="monix.catnap.ConcurrentChannel#consume" class="extmbr">consume</a> and then use it
for multiple workers. Internally this setup uses a single queue and whatever
workers you have will share it.</p><p><i>Broadcasting:</i> the same events can be sent to multiple consumers,
thus duplicating the load, as a broadcasting setup can be created
by creating and consuming from multiple <a href="ConsumerF.html" name="monix.catnap.ConsumerF" id="monix.catnap.ConsumerF" class="extype">ConsumerF</a> via multiple calls
to <a href="ConcurrentChannel.html#consume:cats.effect.Resource[F,monix.catnap.ConsumerF[F,E,A]]" name="monix.catnap.ConcurrentChannel#consume" id="monix.catnap.ConcurrentChannel#consume" class="extmbr">consume</a>. Internally each <code>ConsumerF</code> gets its own queue and hence
messages are duplicated.</p><p><i>Multicasting:</i> multiple producers can push events at the same time,
provided the channel's type is configured as a
<a href="../execution/ChannelType$$MultiProducer$.html" name="monix.execution.ChannelType.MultiProducer" id="monix.execution.ChannelType.MultiProducer" class="extype">MultiProducer</a>.</p><h4>Back-Pressuring and the Polling Model</h4><p>When consumers get created via <a href="ConcurrentChannel.html#consume:cats.effect.Resource[F,monix.catnap.ConsumerF[F,E,A]]" name="monix.catnap.ConcurrentChannel#consume" id="monix.catnap.ConcurrentChannel#consume" class="extmbr">consume</a>, a buffer gets created and
assigned per consumer.</p><p>Depending on what the <a href="../execution/BufferCapacity.html" name="monix.execution.BufferCapacity" id="monix.execution.BufferCapacity" class="extype">BufferCapacity</a>
is configured to be, the initialized consumer can work with a maximum
buffer size, a size that could be rounded to a power of 2, so you can't
rely on it to be precise. See <a href="ConcurrentChannel.html#consumeWithConfig(config:monix.catnap.ConsumerF.Config):cats.effect.Resource[F,monix.catnap.ConsumerF[F,E,A]]" name="monix.catnap.ConcurrentChannel#consumeWithConfig" id="monix.catnap.ConcurrentChannel#consumeWithConfig" class="extmbr">consumeWithConfig</a> for customizing this
buffer on a per-consumer basis, or the
<a href="ConcurrentChannel$.html#withConfig[F[_],E,A](defaultConsumerConfig:monix.catnap.ConsumerF.Config,producerType:monix.execution.ChannelType.ProducerSide)(implicitF:cats.effect.Concurrent[F],implicitcs:cats.effect.ContextShift[F]):F[monix.catnap.ConcurrentChannel[F,E,A]]" name="monix.catnap.ConcurrentChannel#withConfig" id="monix.catnap.ConcurrentChannel#withConfig" class="extmbr">ConcurrentChannel.withConfig</a>
builder for setting the default used in <a href="ConcurrentChannel.html#consume:cats.effect.Resource[F,monix.catnap.ConsumerF[F,E,A]]" name="monix.catnap.ConcurrentChannel#consume" id="monix.catnap.ConcurrentChannel#consume" class="extmbr">consume</a>.</p><p>On <a href="ConcurrentChannel.html#push(a:A):F[Boolean]" name="monix.catnap.ConcurrentChannel#push" id="monix.catnap.ConcurrentChannel#push" class="extmbr">push</a>, when the queue is full, the implementation back-pressures
until the channel has room again in its internal buffer(s), the task being
completed when the value was pushed successfully. Similarly <a href="ConsumerF.html#pull:F[Either[E,A]]" name="monix.catnap.ConsumerF#pull" id="monix.catnap.ConsumerF#pull" class="extmbr">ConsumerF.pull</a>
(returned by <a href="ConcurrentChannel.html#consume:cats.effect.Resource[F,monix.catnap.ConsumerF[F,E,A]]" name="monix.catnap.ConcurrentChannel#consume" id="monix.catnap.ConcurrentChannel#consume" class="extmbr">consume</a>) awaits the channel to have items in it. This
works for both bounded and unbounded channels.</p><p>For both <code>push</code> and <code>pull</code>, in case awaiting a result happens, the
implementation does so asynchronously, without any threads being blocked.</p><h4>Multi-threading Scenario</h4><p>This channel supports the fine-tuning of the concurrency scenario via
<a href="../execution/ChannelType$$ProducerSide.html" name="monix.execution.ChannelType.ProducerSide" id="monix.execution.ChannelType.ProducerSide" class="extype">ChannelType.ProducerSide</a>
(see <a href="ConcurrentChannel$.html#withConfig[F[_],E,A](defaultConsumerConfig:monix.catnap.ConsumerF.Config,producerType:monix.execution.ChannelType.ProducerSide)(implicitF:cats.effect.Concurrent[F],implicitcs:cats.effect.ContextShift[F]):F[monix.catnap.ConcurrentChannel[F,E,A]]" name="monix.catnap.ConcurrentChannel#withConfig" id="monix.catnap.ConcurrentChannel#withConfig" class="extmbr">ConcurrentChannel.withConfig</a>)
and the
<a href="../execution/ChannelType$$ConsumerSide.html" name="monix.execution.ChannelType.ConsumerSide" id="monix.execution.ChannelType.ConsumerSide" class="extype">ChannelType.ConsumerSide</a>
that can be specified per consumer (see <a href="ConcurrentChannel.html#consumeWithConfig(config:monix.catnap.ConsumerF.Config):cats.effect.Resource[F,monix.catnap.ConsumerF[F,E,A]]" name="monix.catnap.ConcurrentChannel#consumeWithConfig" id="monix.catnap.ConcurrentChannel#consumeWithConfig" class="extmbr">consumeWithConfig</a>).</p><p>The default is set to
<a href="../execution/ChannelType$$MultiProducer$.html" name="monix.execution.ChannelType.MultiProducer" id="monix.execution.ChannelType.MultiProducer" class="extype">MultiProducer</a> and
<a href="../execution/ChannelType$$MultiConsumer$.html" name="monix.execution.ChannelType.MultiConsumer" id="monix.execution.ChannelType.MultiConsumer" class="extype">MultiConsumer</a>, which is always
the safe choice, however these can be customized for better performance.</p><p>These scenarios are available:</p><ul><li><a href="../execution/ChannelType$$MPMC$.html" name="monix.execution.ChannelType.MPMC" id="monix.execution.ChannelType.MPMC" class="extype">MPMC</a>:
    multi-producer, multi-consumer, when
    <a href="../execution/ChannelType$$MultiProducer$.html" name="monix.execution.ChannelType.MultiProducer" id="monix.execution.ChannelType.MultiProducer" class="extype">MultiProducer</a>
    is selected on the channel's creation and
    <a href="../execution/ChannelType$$MultiConsumer$.html" name="monix.execution.ChannelType.MultiConsumer" id="monix.execution.ChannelType.MultiConsumer" class="extype">MultiConsumer</a> is
    selected when <a href="ConcurrentChannel.html#consume:cats.effect.Resource[F,monix.catnap.ConsumerF[F,E,A]]" name="monix.catnap.ConcurrentChannel#consume" id="monix.catnap.ConcurrentChannel#consume" class="extmbr">consuming</a>; this is the safe scenario and
    should be used as the default, especially when in doubt</li><li><a href="../execution/ChannelType$$MPSC$.html" name="monix.execution.ChannelType.MPSC" id="monix.execution.ChannelType.MPSC" class="extype">MPSC</a>:
    multi-producer, single-consumer, when
    <a href="../execution/ChannelType$$MultiProducer$.html" name="monix.execution.ChannelType.MultiProducer" id="monix.execution.ChannelType.MultiProducer" class="extype">MultiProducer</a>
    is selected on the channel's creation and
    <a href="../execution/ChannelType$$SingleConsumer$.html" name="monix.execution.ChannelType.SingleConsumer" id="monix.execution.ChannelType.SingleConsumer" class="extype">SingleConsumer</a> is
    selected when <a href="ConcurrentChannel.html#consume:cats.effect.Resource[F,monix.catnap.ConsumerF[F,E,A]]" name="monix.catnap.ConcurrentChannel#consume" id="monix.catnap.ConcurrentChannel#consume" class="extmbr">consuming</a>; this scenario should be selected
    when there are multiple producers, but a single worker that consumes
    data sequentially (per <a href="ConsumerF.html" name="monix.catnap.ConsumerF" id="monix.catnap.ConsumerF" class="extype">ConsumerF</a>); note that this means a single
    worker per <a href="ConsumerF.html" name="monix.catnap.ConsumerF" id="monix.catnap.ConsumerF" class="extype">ConsumerF</a> instance, but you can still have multiple
    <a href="ConsumerF.html" name="monix.catnap.ConsumerF" id="monix.catnap.ConsumerF" class="extype">ConsumerF</a> instances created, , because each <a href="ConsumerF.html" name="monix.catnap.ConsumerF" id="monix.catnap.ConsumerF" class="extype">ConsumerF</a> gets its
    own buffer anyway</li><li><a href="../execution/ChannelType$$SPMC$.html" name="monix.execution.ChannelType.SPMC" id="monix.execution.ChannelType.SPMC" class="extype">SPMC</a>:
    single-producer, multi-consumer, when
    <a href="../execution/ChannelType$$SingleProducer$.html" name="monix.execution.ChannelType.SingleProducer" id="monix.execution.ChannelType.SingleProducer" class="extype">SingleProducer</a>
    is selected on the channel's creation and
    <a href="../execution/ChannelType$$MultiConsumer$.html" name="monix.execution.ChannelType.MultiConsumer" id="monix.execution.ChannelType.MultiConsumer" class="extype">MultiConsumer</a> is
    selected when <a href="ConcurrentChannel.html#consume:cats.effect.Resource[F,monix.catnap.ConsumerF[F,E,A]]" name="monix.catnap.ConcurrentChannel#consume" id="monix.catnap.ConcurrentChannel#consume" class="extmbr">consuming</a>; this scenario should be selected
    when there are multiple workers processing data in parallel
    (e.g. pulling from the same <a href="ConsumerF.html" name="monix.catnap.ConsumerF" id="monix.catnap.ConsumerF" class="extype">ConsumerF</a>), but a single producer that
    pushes data on the channel sequentially</li><li><a href="../execution/ChannelType$$SPSC$.html" name="monix.execution.ChannelType.SPSC" id="monix.execution.ChannelType.SPSC" class="extype">SPSC</a>:
    single-producer, single-consumer, when
    <a href="../execution/ChannelType$$SingleProducer$.html" name="monix.execution.ChannelType.SingleProducer" id="monix.execution.ChannelType.SingleProducer" class="extype">SingleProducer</a>
    is selected on the channel's creation and
    <a href="../execution/ChannelType$$SingleConsumer$.html" name="monix.execution.ChannelType.SingleConsumer" id="monix.execution.ChannelType.SingleConsumer" class="extype">SingleConsumer</a> is
    selected when <a href="ConcurrentChannel.html#consume:cats.effect.Resource[F,monix.catnap.ConsumerF[F,E,A]]" name="monix.catnap.ConcurrentChannel#consume" id="monix.catnap.ConcurrentChannel#consume" class="extmbr">consuming</a>; this scenario should be selected
    when there is a single producer that pushes data on the channel
    sequentially and a single worker per <a href="ConsumerF.html" name="monix.catnap.ConsumerF" id="monix.catnap.ConsumerF" class="extype">ConsumerF</a> instance that
    pulls data from the channel sequentially; note you can still have
    multiple <a href="ConsumerF.html" name="monix.catnap.ConsumerF" id="monix.catnap.ConsumerF" class="extype">ConsumerF</a> instances running in parallel, because
    each <a href="ConsumerF.html" name="monix.catnap.ConsumerF" id="monix.catnap.ConsumerF" class="extype">ConsumerF</a> gets its own buffer anyway</li></ul><p>The default is <code>MPMC</code>, because that's the safest scenario.</p><pre><span class="kw">import</span> cats.implicits._
<span class="kw">import</span> cats.effect.IO
<span class="kw">import</span> monix.execution.ChannelType.{SingleProducer, SingleConsumer}
<span class="kw">import</span> monix.execution.BufferCapacity.Bounded

<span class="kw">val</span> channel = ConcurrentChannel[IO].withConfig[<span class="std">Int</span>, <span class="std">Int</span>](
  producerType = SingleProducer
)

<span class="kw">val</span> consumerConfig = ConsumerF.Config(
  consumerType = <span class="std">Some</span>(SingleConsumer)
)

<span class="kw">for</span> {
  producer  <span class="kw">&lt;-</span> channel
  consumer1 =  producer.consumeWithConfig(consumerConfig)
  consumer2 =  producer.consumeWithConfig(consumerConfig)
  fiber1    <span class="kw">&lt;-</span> consumer1.use { ref <span class="kw">=&gt;</span> ref.pull }.start
  fiber2    <span class="kw">&lt;-</span> consumer2.use { ref <span class="kw">=&gt;</span> ref.pull }.start
  _         <span class="kw">&lt;-</span> producer.push(<span class="num">1</span>)
  value1    <span class="kw">&lt;-</span> fiber1.join
  value2    <span class="kw">&lt;-</span> fiber2.join
} <span class="kw">yield</span> {
  (value1, value2)
}</pre><p>Note that in this example, even if we used <code>SingleConsumer</code> as the type
passed in <a href="ConcurrentChannel.html#consumeWithConfig(config:monix.catnap.ConsumerF.Config):cats.effect.Resource[F,monix.catnap.ConsumerF[F,E,A]]" name="monix.catnap.ConcurrentChannel#consumeWithConfig" id="monix.catnap.ConcurrentChannel#consumeWithConfig" class="extmbr">consumeWithConfig</a>, we can still consume from two <a href="ConsumerF.html" name="monix.catnap.ConsumerF" id="monix.catnap.ConsumerF" class="extype">ConsumerF</a>
instances at the same time, because each one gets its own internal buffer.
But you cannot have multiple workers per <a href="ConsumerF.html" name="monix.catnap.ConsumerF" id="monix.catnap.ConsumerF" class="extype">ConsumerF</a> in this scenario,
because this would break the internal synchronization / visibility
guarantees.</p><p><b>WARNING</b>: default is <code>MPMC</code>, however any other scenario implies
a relaxation of the internal synchronization between threads.</p><p>This means that using the wrong scenario can lead to severe
concurrency bugs. If you're not sure what multi-threading scenario you
have, then just stick with the default <code>MPMC</code>.</p><h4>Credits</h4><p>Inspired by Haskell's
<a href="https://hackage.haskell.org/package/base/docs/Control-Concurrent-ConcurrentChannel.html" target="_blank">Control.Concurrent.ConcurrentChannel</a>,
but note that this isn't a straight port — e.g. the Monix implementation has a
cleaner, non-leaky interface, is back-pressured and allows for termination
(via <a href="ConcurrentChannel.html#halt(e:E):F[Unit]" name="monix.catnap.ConcurrentChannel#halt" id="monix.catnap.ConcurrentChannel#halt" class="extmbr">halt</a>), which changes its semantics significantly.
</p></div></div></li><li class="indented0 " name="monix.catnap.ConcurrentQueue" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ConcurrentQueue[F[_],A]extendsSerializable"></a><a id="ConcurrentQueue[F[_],A]:ConcurrentQueue[F,A]"></a> <span class="permalink"><a href="../../monix/catnap/ConcurrentQueue.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="ConcurrentQueue.html" title="A high-performance, back-pressured, generic concurrent queue implementation."><span class="name">ConcurrentQueue</span></a><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="A">A</span>]</span><span class="result"> extends <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">A high-performance, back-pressured, generic concurrent queue implementation.</p><div class="fullcomment"><div class="comment cmt"><p>A high-performance, back-pressured, generic concurrent queue implementation.</p><p>This is the pure and generic version of <a href="../execution/AsyncQueue.html" name="monix.execution.AsyncQueue" id="monix.execution.AsyncQueue" class="extype">monix.execution.AsyncQueue</a>.</p><h4>Example</h4><pre><span class="kw">import</span> cats.implicits._
<span class="kw">import</span> cats.effect._
<span class="kw">import</span> monix.execution.Scheduler.global

<span class="cmt">// For being able to do IO.start</span>
<span class="kw">implicit</span> <span class="kw">val</span> cs: ContextShift[IO] = SchedulerEffect.contextShift[IO](global)(IO.ioEffect)
<span class="cmt">// We need a `Timer` for this to work</span>
<span class="kw">implicit</span> <span class="kw">val</span> timer: Timer[IO] = SchedulerEffect.timer[IO](global)

<span class="kw">def</span> consumer(queue: ConcurrentQueue[IO, <span class="std">Int</span>], index: <span class="std">Int</span>): IO[<span class="std">Unit</span>] =
  queue.poll.flatMap { a <span class="kw">=&gt;</span>
    println(s<span class="lit">"Worker $$index: $$a"</span>)
    consumer(queue, index)
  }

<span class="kw">for</span> {
  queue     <span class="kw">&lt;-</span> ConcurrentQueue[IO].bounded[<span class="std">Int</span>](capacity = <span class="num">32</span>)
  consumer1 <span class="kw">&lt;-</span> consumer(queue, <span class="num">1</span>).start
  consumer2 <span class="kw">&lt;-</span> consumer(queue, <span class="num">1</span>).start
  <span class="cmt">// Pushing some samples</span>
  _         <span class="kw">&lt;-</span> queue.offer(<span class="num">1</span>)
  _         <span class="kw">&lt;-</span> queue.offer(<span class="num">2</span>)
  _         <span class="kw">&lt;-</span> queue.offer(<span class="num">3</span>)
  <span class="cmt">// Stopping the consumer loops</span>
  _         <span class="kw">&lt;-</span> consumer1.cancel
  _         <span class="kw">&lt;-</span> consumer2.cancel
} <span class="kw">yield</span> ()</pre><h4>Back-Pressuring and the Polling Model</h4><p>The initialized queue can be limited to a maximum buffer size, a size
that could be rounded to a power of 2, so you can't rely on it to be
precise. Such a bounded queue can be initialized via
<a href="ConcurrentQueue$.html#bounded[F[_],A](capacity:Int)(implicitF:cats.effect.Concurrent[F],implicitcs:cats.effect.ContextShift[F]):F[monix.catnap.ConcurrentQueue[F,A]]" name="monix.catnap.ConcurrentQueue#bounded" id="monix.catnap.ConcurrentQueue#bounded" class="extmbr">ConcurrentQueue.bounded</a>.
Also see <a href="../execution/BufferCapacity.html" name="monix.execution.BufferCapacity" id="monix.execution.BufferCapacity" class="extype">BufferCapacity</a>, the
configuration parameter that can be passed in the
<a href="ConcurrentQueue$.html#withConfig[F[_],A](capacity:monix.execution.BufferCapacity,channelType:monix.execution.ChannelType)(implicitF:cats.effect.Concurrent[F],implicitcs:cats.effect.ContextShift[F]):F[monix.catnap.ConcurrentQueue[F,A]]" name="monix.catnap.ConcurrentQueue#withConfig" id="monix.catnap.ConcurrentQueue#withConfig" class="extmbr">ConcurrentQueue.withConfig</a>
builder.</p><p>On <a href="ConcurrentQueue.html#offer(a:A):F[Unit]" name="monix.catnap.ConcurrentQueue#offer" id="monix.catnap.ConcurrentQueue#offer" class="extmbr">offer</a>, when the queue is full, the implementation back-pressures
until the queue has room again in its internal buffer, the task being
completed when the value was pushed successfully. Similarly <a href="ConcurrentQueue.html#poll:F[A]" name="monix.catnap.ConcurrentQueue#poll" id="monix.catnap.ConcurrentQueue#poll" class="extmbr">poll</a> awaits
the queue to have items in it. This works for both bounded and unbounded queues.</p><p>For both <code>offer</code> and <code>poll</code>, in case awaiting a result happens, the
implementation does so asynchronously, without any threads being blocked.</p><h4>Multi-threading Scenario</h4><p>This queue supports a <a href="../execution/ChannelType.html" name="monix.execution.ChannelType" id="monix.execution.ChannelType" class="extype">ChannelType</a>
configuration, for fine tuning depending on the needed multi-threading
scenario. And this can yield better performance:</p><ul><li><a href="../execution/ChannelType$$MPMC$.html" name="monix.execution.ChannelType.MPMC" id="monix.execution.ChannelType.MPMC" class="extype">MPMC</a>:
    multi-producer, multi-consumer</li><li><a href="../execution/ChannelType$$MPSC$.html" name="monix.execution.ChannelType.MPSC" id="monix.execution.ChannelType.MPSC" class="extype">MPSC</a>:
    multi-producer, single-consumer</li><li><a href="../execution/ChannelType$$SPMC$.html" name="monix.execution.ChannelType.SPMC" id="monix.execution.ChannelType.SPMC" class="extype">SPMC</a>:
    single-producer, multi-consumer</li><li><a href="../execution/ChannelType$$SPSC$.html" name="monix.execution.ChannelType.SPSC" id="monix.execution.ChannelType.SPSC" class="extype">SPSC</a>:
    single-producer, single-consumer</li></ul><p>The default is <code>MPMC</code>, because that's the safest scenario.</p><pre><span class="kw">import</span> monix.execution.ChannelType.MPSC
<span class="kw">import</span> monix.execution.BufferCapacity.Bounded

<span class="kw">val</span> queue = ConcurrentQueue[IO].withConfig[<span class="std">Int</span>](
  capacity = Bounded(<span class="num">128</span>),
  channelType = MPSC
)</pre><p><b>WARNING</b>: default is <code>MPMC</code>, however any other scenario implies
a relaxation of the internal synchronization between threads.</p><p>This means that using the wrong scenario can lead to severe
concurrency bugs. If you're not sure what multi-threading scenario you
have, then just stick with the default <code>MPMC</code>.
</p></div></div></li><li class="indented0 " name="monix.catnap.ConsumerF" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="ConsumerF[F[_],E,A]extendsSerializable"></a><a id="ConsumerF[F[_],E,A]:ConsumerF[F,E,A]"></a> <span class="permalink"><a href="../../monix/catnap/ConsumerF.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="ConsumerF.html" title="A simple interface that models the consumer side of a producer-consumer communication channel."><span class="name">ConsumerF</span></a><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="E">E</span>, <span name="A">A</span>]</span><span class="result"> extends <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">A simple interface that models the consumer side of a producer-consumer
communication channel.</p><div class="fullcomment"><div class="comment cmt"><p>A simple interface that models the consumer side of a producer-consumer
communication channel.</p><p>Currently exposed by <a href="ConcurrentChannel.html#consume:cats.effect.Resource[F,monix.catnap.ConsumerF[F,E,A]]" name="monix.catnap.ConcurrentChannel#consume" id="monix.catnap.ConcurrentChannel#consume" class="extmbr">ConcurrentChannel.consume</a>.
</p></div><dl class="paramcmts block"><dt class="tparam">F</dt><dd class="cmt"><p>is effect type used for processing tasks asynchronously</p></dd><dt class="tparam">E</dt><dd class="cmt"><p>is the type for the completion event</p></dd><dt class="tparam">A</dt><dd class="cmt"><p>is the type for the stream of events being consumed</p></dd></dl></div></li><li class="indented0 " name="monix.catnap.FutureLift" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="FutureLift[F[_],Future[_]]extends[γ$0$]F[Future[γ$0$]]~&gt;F"></a><a id="FutureLift[F[_],Future[_]]:FutureLift[F,Future]"></a> <span class="permalink"><a href="../../monix/catnap/FutureLift.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="FutureLift.html" title="A type class for conversions from scala.concurrent.Future or other Future-like data type (e.g."><span class="name">FutureLift</span></a><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="Future">Future<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="result"> extends <span name="cats.~&gt;" class="extype">~&gt;</span>[[γ$0$]<span name="monix.catnap.FutureLift.F" class="extype">F</span>[<span name="monix.catnap.FutureLift.Future" class="extype">Future</span>[<span name="monix.catnap.&lt;refinement&gt;.Λ$.&lt;local Λ$&gt;.γ$0$" class="extype">γ$0$</span>]], <span name="monix.catnap.FutureLift.F" class="extype">F</span>]</span></span><p class="shortcomment cmt">A type class for conversions from <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/Future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">scala.concurrent.Future</a> or
other Future-like data type (e.g.</p><div class="fullcomment"><div class="comment cmt"><p>A type class for conversions from <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/Future.html" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">scala.concurrent.Future</a> or
other Future-like data type (e.g. Java's <code>CompletableFuture</code>).</p><p>N.B. to use its syntax, you can import <a href="syntax$.html" name="monix.catnap.syntax" id="monix.catnap.syntax" class="extype">monix.catnap.syntax</a>:</p><pre><span class="kw">import</span> monix.catnap.syntax._
<span class="kw">import</span> scala.concurrent.Future
<span class="cmt">// Used here only for Future.apply as the ExecutionContext</span>
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global
<span class="cmt">// Can use any data type implementing Async or Concurrent</span>
<span class="kw">import</span> cats.effect.IO

<span class="kw">val</span> io = IO(Future(<span class="num">1</span> + <span class="num">1</span>)).futureLift</pre><p><code>IO</code> provides its own <code>IO.fromFuture</code> of course, however
<code>FutureLift</code> is generic and works with
<a href="../execution/CancelableFuture.html" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a> as well.</p><pre><span class="kw">import</span> monix.execution.{CancelableFuture, Scheduler, FutureUtils}
<span class="kw">import</span> scala.concurrent.Promise
<span class="kw">import</span> scala.concurrent.duration._
<span class="kw">import</span> scala.util.Try

<span class="kw">def</span> delayed[A](event: <span class="kw">=&gt;</span> A)(<span class="kw">implicit</span> s: Scheduler): CancelableFuture[A] = {
  <span class="kw">val</span> p = Promise[A]()
  <span class="kw">val</span> c = s.scheduleOnce(<span class="num">1.</span>second) { p.complete(Try(event)) }
  CancelableFuture(p.future, c)
}

<span class="cmt">// The result will be cancelable:</span>
<span class="kw">val</span> sum: IO[<span class="std">Int</span>] = IO(delayed(<span class="num">1</span> + <span class="num">1</span>)).futureLift</pre></div></div></li><li class="indented0 " name="monix.catnap.MVar" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="MVar[F[_],A]extendsMVar2[F,A]"></a><a id="MVar[F[_],A]:MVar[F,A]"></a> <span class="permalink"><a href="../../monix/catnap/MVar.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="MVar.html" title="A mutable location, that is either empty or contains a value of type A."><span class="name">MVar</span></a><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="A">A</span>]</span><span class="result"> extends <span name="cats.effect.concurrent.MVar2" class="extype">MVar2</span>[<span name="monix.catnap.MVar.F" class="extype">F</span>, <span name="monix.catnap.MVar.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">A mutable location, that is either empty or contains
a value of type <code>A</code>.</p><div class="fullcomment"><div class="comment cmt"><p>A mutable location, that is either empty or contains
a value of type <code>A</code>.</p><p>It has the following fundamental atomic operations:</p><ul><li><a href="MVar.html#put(a:A):F[Unit]" name="monix.catnap.MVar#put" id="monix.catnap.MVar#put" class="extmbr">put</a> which fills the var if empty, or blocks
   (asynchronously) until the var is empty again</li><li><a href="MVar.html#tryPut(a:A):F[Boolean]" name="monix.catnap.MVar#tryPut" id="monix.catnap.MVar#tryPut" class="extmbr">tryPut</a> which fills the var if empty. returns true if successful</li><li><a href="MVar.html#take:F[A]" name="monix.catnap.MVar#take" id="monix.catnap.MVar#take" class="extmbr">take</a> which empties the var if full, returning the contained
   value, or blocks (asynchronously) otherwise until there is
   a value to pull</li><li><a href="MVar.html#tryTake:F[Option[A]]" name="monix.catnap.MVar#tryTake" id="monix.catnap.MVar#tryTake" class="extmbr">tryTake</a> empties if full, returns None if empty.</li><li><a href="MVar.html#read:F[A]" name="monix.catnap.MVar#read" id="monix.catnap.MVar#read" class="extmbr">read</a> which reads the current value without touching it,
   assuming there is one, or otherwise it waits until a value
   is made available via <code>put</code></li><li><a href="MVar.html#tryRead:F[Option[A]]" name="monix.catnap.MVar#tryRead" id="monix.catnap.MVar#tryRead" class="extmbr">tryRead</a> returns <code>Some(a)</code> if full, without modifying the var,
   or else returns <code>None</code></li><li><a href="MVar.html#isEmpty:F[Boolean]" name="monix.catnap.MVar#isEmpty" id="monix.catnap.MVar#isEmpty" class="extmbr">isEmpty</a> returns true if currently empty</li></ul><p>The <code>MVar</code> is appropriate for building synchronization
primitives and performing simple inter-thread communications.
If it helps, it's similar with a <code>BlockingQueue(capacity = 1)</code>,
except that it is pure and that doesn't block any threads, all
waiting being done asynchronously.</p><p>Given its asynchronous, non-blocking nature, it can be used on
top of Javascript as well.</p><p>N.B. this is a reimplementation of the interface exposed in Cats-Effect, see:
<a href="https://typelevel.org/cats-effect/concurrency/mvar.html" target="_blank">cats.effect.concurrent.MVar</a></p><p>Inspired by
<a href="https://hackage.haskell.org/package/base/docs/Control-Concurrent-MVar.html" target="_blank">Control.Concurrent.MVar</a>
from Haskell.
</p></div></div></li><li class="indented0 " name="monix.catnap.OrElse" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="OrElse[+A,+B]extendsAnyRef"></a><a id="OrElse[+A,+B]:OrElse[A,B]"></a> <span class="permalink"><a href="../../monix/catnap/OrElse.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">sealed </span> <span class="kind">trait</span></span> <span class="symbol"><a href="OrElse.html" title="A type class for prioritized implicit search."><span class="name">OrElse</span></a><span class="tparams">[<span name="A">+A</span>, <span name="B">+B</span>]</span><span class="result"> extends <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span><p class="shortcomment cmt">A type class for prioritized implicit search.</p><div class="fullcomment"><div class="comment cmt"><p>A type class for prioritized implicit search.</p><p>Useful for specifying type class instance alternatives.
Examples:</p><ul><li><code>Async[F] OrElse Sync[F]</code></li><li><code>Concurrent[F] OrElse Async[F]</code></li></ul><p>Inspired by the implementations in Shapeless and Algebra.
</p></div></div></li><li class="indented0 " name="monix.catnap.ProducerF" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="ProducerF[F[_],E,A]extendsSerializable"></a><a id="ProducerF[F[_],E,A]:ProducerF[F,E,A]"></a> <span class="permalink"><a href="../../monix/catnap/ProducerF.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="ProducerF.html" title="A simple interface that models the producer side of a producer-consumer communication channel."><span class="name">ProducerF</span></a><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="E">E</span>, <span name="A">A</span>]</span><span class="result"> extends <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">A simple interface that models the producer side of a producer-consumer
communication channel.</p><div class="fullcomment"><div class="comment cmt"><p>A simple interface that models the producer side of a producer-consumer
communication channel.</p><p>In a producer-consumer communication channel we've got these concerns
to take care of:</p><ul><li>back-pressure, which is handled automatically via this interface</li><li>halting the channel with a final event and informing all current and
   future consumers about it, while stopping future producers from pushing
   more events</li></ul><p>The <code>ProducerF</code> interface takes care of these concerns via:</p><ul><li>the <code>F[Boolean]</code> result, which should return <code>true</code> for as long as
   the channel wasn't halted, so further events can be pushed; these
   tasks also block (asynchronously) when internal buffers are full,
   so back-pressure concerns are handled automatically</li><li><a href="ProducerF.html#halt(e:E):F[Unit]" name="monix.catnap.ProducerF#halt" id="monix.catnap.ProducerF#halt" class="extmbr">halt</a>, being able to close the channel
   with a final event that will be visible to all current and future
   consumers</li></ul><p>Currently implemented by <a href="ConcurrentChannel.html" name="monix.catnap.ConcurrentChannel" id="monix.catnap.ConcurrentChannel" class="extype">ConcurrentChannel</a>.
</p></div></div></li><li class="indented0 " name="monix.catnap.Semaphore" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Semaphore[F[_]]extendsSemaphore[F]"></a><a id="Semaphore[F[_]]:Semaphore[F]"></a> <span class="permalink"><a href="../../monix/catnap/Semaphore.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="Semaphore.html" title="The Semaphore is an asynchronous semaphore implementation that limits the parallelism on task execution."><span class="name">Semaphore</span></a><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="result"> extends <span name="cats.effect.concurrent.Semaphore" class="extype">cats.effect.concurrent.Semaphore</span>[<span name="monix.catnap.Semaphore.F" class="extype">F</span>]</span></span><p class="shortcomment cmt">The <code>Semaphore</code> is an asynchronous semaphore implementation that
limits the parallelism on task execution.</p><div class="fullcomment"><div class="comment cmt"><p>The <code>Semaphore</code> is an asynchronous semaphore implementation that
limits the parallelism on task execution.</p><p>The following example instantiates a semaphore with a
maximum parallelism of 10:</p><pre><span class="kw">import</span> cats.implicits._
<span class="kw">import</span> cats.effect.IO

<span class="cmt">// Needed for ContextShift[IO]</span>
<span class="kw">import</span> monix.execution.Scheduler
<span class="kw">implicit</span> <span class="kw">val</span> cs = IO.contextShift(Scheduler.global)

<span class="cmt">// Dummies for didactic purposes</span>
<span class="kw">case</span> <span class="kw">class</span> HttpRequest()
<span class="kw">case</span> <span class="kw">class</span> HttpResponse()
<span class="kw">def</span> makeRequest(r: HttpRequest): IO[HttpResponse] = IO(???)

<span class="kw">for</span> {
  semaphore <span class="kw">&lt;-</span> Semaphore[IO](provisioned = <span class="num">10</span>)
  tasks = <span class="kw">for</span> (_ <span class="kw">&lt;-</span> <span class="num">0</span> until <span class="num">1000</span>) <span class="kw">yield</span> {
    semaphore.withPermit(makeRequest(HttpRequest()))
  }
  <span class="cmt">// Execute in parallel; note that due to the `semaphore`</span>
  <span class="cmt">// no more than 10 tasks will be allowed to execute in parallel</span>
  _ <span class="kw">&lt;-</span> tasks.toList.parSequence
} <span class="kw">yield</span> ()</pre><h4>Credits</h4><p><code>Semaphore</code> is now implementing <code>cats.effect.Semaphore</code>, deprecating
the old Monix <code>TaskSemaphore</code>.</p><p>The changes to the interface and some implementation details are
inspired by the implementation in Cats-Effect, which was ported
from FS2.
</p></div></div></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="monix.catnap.CancelableF" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="CancelableF"></a><a id="CancelableF:CancelableF"></a> <span class="permalink"><a href="../../monix/catnap/CancelableF$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="CancelableF$.html" title=""><span class="name">CancelableF</span></a></span></li><li class="indented0 " name="monix.catnap.CircuitBreaker" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="CircuitBreaker"></a><a id="CircuitBreaker:CircuitBreaker"></a> <span class="permalink"><a href="../../monix/catnap/CircuitBreaker$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="CircuitBreaker$.html" title=""><span class="name">CircuitBreaker</span></a><span class="result"> extends <span name="monix.catnap.CircuitBreakerDocs" class="extype">CircuitBreakerDocs</span></span></span></li><li class="indented0 " name="monix.catnap.ConcurrentChannel" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="ConcurrentChannel"></a><a id="ConcurrentChannel:ConcurrentChannel"></a> <span class="permalink"><a href="../../monix/catnap/ConcurrentChannel$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="ConcurrentChannel$.html" title=""><span class="name">ConcurrentChannel</span></a><span class="result"> extends <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></span></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="monix.catnap.ConcurrentQueue" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="ConcurrentQueue"></a><a id="ConcurrentQueue:ConcurrentQueue"></a> <span class="permalink"><a href="../../monix/catnap/ConcurrentQueue$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="ConcurrentQueue$.html" title=""><span class="name">ConcurrentQueue</span></a><span class="result"> extends <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></span></span><p class="shortcomment cmt"></p></li><li class="indented0 " name="monix.catnap.ConsumerF" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="ConsumerF"></a><a id="ConsumerF:ConsumerF"></a> <span class="permalink"><a href="../../monix/catnap/ConsumerF$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="ConsumerF$.html" title=""><span class="name">ConsumerF</span></a><span class="result"> extends <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></span></span></li><li class="indented0 " name="monix.catnap.FutureLift" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="FutureLift"></a><a id="FutureLift:FutureLift"></a> <span class="permalink"><a href="../../monix/catnap/FutureLift$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="FutureLift$.html" title=""><span class="name">FutureLift</span></a><span class="result"> extends <span name="monix.catnap.internal.FutureLiftForPlatform" class="extype">FutureLiftForPlatform</span> with <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></span></span></li><li class="indented0 " name="monix.catnap.MVar" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="MVar"></a><a id="MVar:MVar"></a> <span class="permalink"><a href="../../monix/catnap/MVar$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="MVar$.html" title=""><span class="name">MVar</span></a></span></li><li class="indented0 " name="monix.catnap.OrElse" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="OrElse"></a><a id="OrElse:OrElse"></a> <span class="permalink"><a href="../../monix/catnap/OrElse$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="OrElse$.html" title=""><span class="name">OrElse</span></a><span class="result"> extends <span name="monix.catnap.OrElse0" class="extype">OrElse0</span></span></span></li><li class="indented0 " name="monix.catnap.SchedulerEffect" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="SchedulerEffect"></a><a id="SchedulerEffect:SchedulerEffect"></a> <span class="permalink"><a href="../../monix/catnap/SchedulerEffect$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="SchedulerEffect$.html" title=""><span class="name">SchedulerEffect</span></a></span></li><li class="indented0 " name="monix.catnap.Semaphore" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="Semaphore"></a><a id="Semaphore:Semaphore"></a> <span class="permalink"><a href="../../monix/catnap/Semaphore$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Semaphore$.html" title=""><span class="name">Semaphore</span></a></span></li><li class="indented0 " name="monix.catnap.syntax" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="syntax"></a><a id="syntax:syntax"></a> <span class="permalink"><a href="../../monix/catnap/syntax$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="syntax$.html" title=""><span class="name">syntax</span></a></span></li></ol></div></div><div id="inheritedMembers"></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
