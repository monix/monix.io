<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Monix 3.4.0 - monix.eval.Coeval</title><meta content="Monix 3.4.0 - monix.eval.Coeval" name="description"/><meta content="Monix 3.4.0 monix.eval.Coeval" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../lib/jquery.min.js"></script><script type="text/javascript" src="../../lib/index.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript" src="../../lib/scheduler.js"></script><script type="text/javascript" src="../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../';</script></head><body><div id="search"><span id="doc-title">Monix<span id="doc-version">3.4.0</span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">root</span></a></span><p class="shortcomment cmt"><img src="https://monix.io/public/images/monix-logo.png" align="right" width="200" /></p><div class="fullcomment"><div class="comment cmt"><p><img src="https://monix.io/public/images/monix-logo.png" align="right" width="200" /></p><p>This is the API documentation for the <a href="https://monix.io" target="_blank">Monix</a> library.</p><h4>Package Overview</h4><p><b><a href="../execution/index.html" name="monix.execution" id="monix.execution" class="extype">monix.execution</a></b> exposes lower level primitives for dealing
with asynchronous execution:</p><ul><li><a href="../execution/atomic/index.html" name="monix.execution.atomic" id="monix.execution.atomic" class="extype">monix.execution.atomic</a> exposes the <code>Atomic</code> types, as alternative
   to <code>java.util.concurrent.atomic</code></li><li><a href="../execution/cancelables/index.html" name="monix.execution.cancelables" id="monix.execution.cancelables" class="extype">monix.execution.cancelables</a> contains several
   useful <a href="../execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a> implementations</li><li><a href="../execution/schedulers/index.html" name="monix.execution.schedulers" id="monix.execution.schedulers" class="extype">monix.execution.schedulers</a> contains several
   useful <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> implementations</li><li><a href="../execution/rstreams/index.html" name="monix.execution.rstreams" id="monix.execution.rstreams" class="extype">monix.execution.rstreams</a> contains helpers for dealing
   with the <a href="http://www.reactive-streams.org" target="_blank">Reactive Streams</a> specification</li><li><a href="../execution/misc/index.html" name="monix.execution.misc" id="monix.execution.misc" class="extype">monix.execution.misc</a> provides miscellaneous primitives
   useful for dealing with concurrency</li><li><a href="../execution/exceptions/index.html" name="monix.execution.exceptions" id="monix.execution.exceptions" class="extype">monix.execution.exceptions</a> groups some exceptions thrown by
   the implementation</li></ul><p><b><a href="../catnap/index.html" name="monix.catnap" id="monix.catnap" class="extype">monix.catnap</a></b> exposes pure abstractions built on top of
the <a href="https://typelevel.org/cats-effect/" target="_blank">Cats-Effect</a> type classes:</p><ul><li><a href="../catnap/cancelables/index.html" name="monix.catnap.cancelables" id="monix.catnap.cancelables" class="extype">monix.catnap.cancelables</a> exposes pure counterparts to the
   cancelable data types described in <a href="../execution/cancelables/index.html" name="monix.execution.cancelables" id="monix.execution.cancelables" class="extype">monix.execution.cancelables</a></li></ul><p><b><a href="index.html" name="monix.eval" id="monix.eval" class="extype">monix.eval</a></b> is for dealing with evaluation of results, thus exposing
<a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> and <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>.</p><p><b><a href="../reactive/index.html" name="monix.reactive" id="monix.reactive" class="extype">monix.reactive</a></b> exposes the <code>Observable</code> pattern:</p><ul><li><a href="../reactive/observables/index.html" name="monix.reactive.observables" id="monix.reactive.observables" class="extype">monix.reactive.observables</a> groups reusable <code>Observable</code> implementations</li><li><a href="../reactive/observers/index.html" name="monix.reactive.observers" id="monix.reactive.observers" class="extype">monix.reactive.observers</a> groups reusable <a href="../reactive/Observer.html" name="monix.reactive.Observer" id="monix.reactive.Observer" class="extype">Observer</a>
   implementations</li><li><a href="../reactive/subjects/index.html" name="monix.reactive.subjects" id="monix.reactive.subjects" class="extype">monix.reactive.subjects</a> exposes <a href="../reactive/subjects/Subject.html" name="monix.reactive.subjects.Subject" id="monix.reactive.subjects.Subject" class="extype">Subject</a>
   and <a href="../reactive/subjects/ConcurrentSubject.html" name="monix.reactive.subjects.ConcurrentSubject" id="monix.reactive.subjects.ConcurrentSubject" class="extype">ConcurrentSubject</a>,
   which are implementations of hot observables that function both as input and output</li></ul><p><b><a href="../tail/index.html" name="monix.tail" id="monix.tail" class="extype">monix.tail</a></b> exposes <a href="../tail/Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a> for purely functional pull based streaming:</p><ul><li><a href="../tail/batches/index.html" name="monix.tail.batches" id="monix.tail.batches" class="extype">monix.tail.batches</a> describes <code>Batch</code> and <code>BatchCursor</code>, the
   alternatives to Scala's <code>Iterable</code> and <code>Iterator</code> respectively that
   we are using within Iterant's encoding</li></ul><p>You can control evaluation with type you choose - be it <a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>, <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>, <a href="https://typelevel.org/cats-effect/api/cats/effect/IO.html" target="_blank">cats.effect.IO</a>
or your own as long as you provide correct <a href="https://typelevel.org/cats-effect/typeclasses/" target="_blank">cats-effect</a> or <a href="https://typelevel.org/cats/typeclasses.html" target="_blank">cats</a> typeclass instance.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.monix" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="monix"></a><a id="monix:monix"></a> <span class="permalink"><a href="../../monix/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">monix</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="monix.eval" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eval"></a><a id="eval:eval"></a> <span class="permalink"><a href="../../monix/eval/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title=""><span class="name">eval</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="monix" id="monix" class="extype">monix</a></dd></dl></div></li><li class="indented3 " name="monix.eval.instances" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="instances"></a><a id="instances:instances"></a> <span class="permalink"><a href="../../monix/eval/instances/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="instances/index.html" title=""><span class="name">instances</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="monix.eval" id="monix.eval" class="extype">eval</a></dd></dl></div></li><li class="indented3 " name="monix.eval.tracing" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="tracing"></a><a id="tracing:tracing"></a> <span class="permalink"><a href="../../monix/eval/tracing/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="tracing/index.html" title=""><span class="name">tracing</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="monix.eval" id="monix.eval" class="extype">eval</a></dd></dl></div></li><li class="current-entities indented2"><a href="Coeval$.html" title="Coeval builders." class="object"></a> <a href="" title="Coeval represents lazy computations that can execute synchronously." class="class"></a><a href="" title="Coeval represents lazy computations that can execute synchronously.">Coeval</a></li><li class="current-entities indented2"><a href="CoevalLift$.html" title="" class="object"></a> <a href="CoevalLift.html" title="A lawless type class that specifies conversions from Coeval to similar data types (i.e." class="trait"></a><a href="CoevalLift.html" title="A lawless type class that specifies conversions from Coeval to similar data types (i.e.">CoevalLift</a></li><li class="current-entities indented2"><a href="CoevalLike$.html" title="" class="object"></a> <a href="CoevalLike.html" title="A lawless type class that provides conversions to Coeval." class="trait"></a><a href="CoevalLike.html" title="A lawless type class that provides conversions to Coeval.">CoevalLike</a></li><li class="current-entities indented2"><a href="Fiber$.html" title="" class="object"></a> <a href="Fiber.html" title="Fiber represents the (pure) result of a Task being started concurrently and that can be either joined or cancelled." class="trait"></a><a href="Fiber.html" title="Fiber represents the (pure) result of a Task being started concurrently and that can be either joined or cancelled.">Fiber</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="package$$MVar$.html" title="DEPRECATED — moved and made generic in monix.catnap.CircuitBreaker." class="object"></a><a href="package$$MVar$.html" title="DEPRECATED — moved and made generic in monix.catnap.CircuitBreaker.">MVar</a></li><li class="current-entities indented2"><a href="Task$.html" title="Builders for Task." class="object"></a> <a href="Task.html" title="Task represents a specification for a possibly lazy or asynchronous computation, which when executed will produce an A as a result, along with possible side-effects." class="class"></a><a href="Task.html" title="Task represents a specification for a possibly lazy or asynchronous computation, which when executed will produce an A as a result, along with possible side-effects.">Task</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="TaskApp.html" title="Safe App type that executes a Task." class="trait"></a><a href="TaskApp.html" title="Safe App type that executes a Task.">TaskApp</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="package$$TaskCircuitBreaker$.html" title="DEPRECATED — moved and made generic in monix.catnap.CircuitBreaker." class="object"></a><a href="package$$TaskCircuitBreaker$.html" title="DEPRECATED — moved and made generic in monix.catnap.CircuitBreaker.">TaskCircuitBreaker</a></li><li class="current-entities indented2"><a href="TaskLift$.html" title="" class="object"></a> <a href="TaskLift.html" title="A lawless type class that specifies conversions from Task to similar data types (i.e." class="trait"></a><a href="TaskLift.html" title="A lawless type class that specifies conversions from Task to similar data types (i.e.">TaskLift</a></li><li class="current-entities indented2"><a href="TaskLike$.html" title="" class="object"></a> <a href="TaskLike.html" title="A lawless type class that provides conversions to Task." class="trait"></a><a href="TaskLike.html" title="A lawless type class that provides conversions to Task.">TaskLike</a></li><li class="current-entities indented2"><a href="TaskLocal$.html" title="Builders for TaskLocal" class="object"></a> <a href="TaskLocal.html" title="A TaskLocal is like a ThreadLocal that is pure and with a flexible scope, being processed in the context of the Task data type." class="class"></a><a href="TaskLocal.html" title="A TaskLocal is like a ThreadLocal that is pure and with a flexible scope, being processed in the context of the Task data type.">TaskLocal</a></li><li class="current-entities indented2"><span class="separator"></span> <a href="package$$TaskSemaphore$.html" title="DEPRECATED — moved and made generic in monix.catnap.Semaphore." class="object"></a><a href="package$$TaskSemaphore$.html" title="DEPRECATED — moved and made generic in monix.catnap.Semaphore.">TaskSemaphore</a></li></ul></div></div><div id="content"><body class="class type"><div id="definition"><a href="Coeval$.html" title="See companion object"><div class="big-circle class-companion-object">c</div></a><p id="owner"><a href="../index.html" name="monix" id="monix" class="extype">monix</a>.<a href="index.html" name="monix.eval" id="monix.eval" class="extype">eval</a></p><h1><a href="Coeval$.html" title="See companion object">Coeval</a><span class="permalink"><a href="../../monix/eval/Coeval.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"><div>Companion <a href="Coeval$.html" title="See companion object">object Coeval</a></div></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier">sealed abstract </span> <span class="kind">class</span></span> <span class="symbol"><span class="name">Coeval</span><span class="tparams">[<span name="A">+A</span>]</span><span class="result"> extends () =&gt; <span name="monix.eval.Coeval.A" class="extype">A</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p><code>Coeval</code> represents lazy computations that can execute synchronously.</p><p>Word definition and origin:</p><ul><li>Having the same age or date of origin; a contemporary; synchronous.</li><li>From the Latin "coævus": com- ‎("equal") in combination with aevum ‎(aevum, "age").</li><li>The constructor of <code>Coeval</code> is the dual of an expression that evaluates to an <code>A</code>.</li></ul><p>There are three evaluation strategies:</p><ul><li><a href="Coeval$.html#now[A](a:A):monix.eval.Coeval[A]" name="monix.eval.Coeval#now" id="monix.eval.Coeval#now" class="extmbr">now</a> or
   <a href="Coeval$.html#raiseError[A](ex:Throwable):monix.eval.Coeval[A]" name="monix.eval.Coeval#raiseError" id="monix.eval.Coeval#raiseError" class="extmbr">raiseError</a>: for describing
   strict values, evaluated immediately</li><li><a href="Coeval$.html#evalOnce[A](a:=&gt;A):monix.eval.Coeval[A]" name="monix.eval.Coeval#evalOnce" id="monix.eval.Coeval#evalOnce" class="extmbr">evalOnce</a>: expressions evaluated a single time</li><li><a href="Coeval$.html#eval[A](a:=&gt;A):monix.eval.Coeval[A]" name="monix.eval.Coeval#eval" id="monix.eval.Coeval#eval" class="extmbr">eval</a>: expressions evaluated every time
   the value is needed</li></ul><p>The <code>Once</code> and <code>Always</code> are both lazy strategies while
<code>Now</code> and <code>Error</code> are eager. <code>Once</code> and <code>Always</code> are
distinguished from each other only by memoization: once evaluated
<code>Once</code> will save the value to be returned immediately if it is
needed again. <code>Always</code> will run its computation every time.</p><p>Both <code>Now</code> and <code>Error</code> are represented by the
<a href="Coeval$$Eager.html" name="monix.eval.Coeval.Eager" id="monix.eval.Coeval.Eager" class="extype">Eager</a> trait, a sub-type of <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>
that can be used as a replacement for Scala's own <code>Try</code> type.</p><p><code>Coeval</code> supports stack-safe lazy computation via the
<a href="#map[B](f:A=&gt;B):monix.eval.Coeval[B]" name="monix.eval.Coeval#map" id="monix.eval.Coeval#map" class="extmbr">.map</a> and <a href="#flatMap[B](f:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#flatMap" id="monix.eval.Coeval#flatMap" class="extmbr">.flatMap</a> methods,
which use an internal trampoline to avoid stack overflows.
Computations done within <code>.map</code> and <code>.flatMap</code> are always
lazy, even when applied to a
<a href="Coeval$$Eager.html" name="monix.eval.Coeval.Eager" id="monix.eval.Coeval.Eager" class="extype">Coeval.Eager</a> instance (e.g.
<a href="Coeval$$Now.html" name="monix.eval.Coeval.Now" id="monix.eval.Coeval.Now" class="extype">Coeval.Now</a>,
<a href="Coeval$$Error.html" name="monix.eval.Coeval.Error" id="monix.eval.Coeval.Error" class="extype">Coeval.Error</a>).</p><h3>Evaluation Strategies</h3><p>The "now" and "raiseError" builders are building <code>Coeval</code>
instances out of strict values:</p><pre><span class="kw">val</span> fa = Coeval.now(<span class="num">1</span>)
fa.value() <span class="cmt">// =&gt; 1</span>

<span class="kw">val</span> fe = Coeval.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"dummy"</span>))
fe.failed <span class="cmt">// =&gt; has RuntimeException</span></pre><p>The "always" strategy is equivalent with a plain function:</p><pre><span class="cmt">// For didactic purposes, don't use shared vars at home :-)</span>
<span class="kw">var</span> i = <span class="num">0</span>
<span class="kw">val</span> coeval = Coeval.eval { i += <span class="num">1</span>; i }

coeval.value() <span class="cmt">// =&gt; 1</span>
coeval.value() <span class="cmt">// =&gt; 2</span>
coeval.value() <span class="cmt">// =&gt; 3</span></pre><p>The "once" strategy is equivalent with Scala's <code>lazy val</code>
(along with thread-safe idempotency guarantees):</p><pre><span class="kw">var</span> j = <span class="num">0</span>
<span class="kw">val</span> coevalOnce = Coeval.evalOnce { j += <span class="num">1</span>; j }

coevalOnce.value() <span class="cmt">// =&gt; 1</span>
coevalOnce.value() <span class="cmt">// =&gt; 1</span>
coevalOnce.value() <span class="cmt">// =&gt; 1</span></pre><h3>Versus Task</h3><p>The other option of suspending side-effects is <a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>.
As a quick comparison:</p><ul><li><code>Coeval</code>'s execution is always immediate / synchronous, whereas
   <code>Task</code> can describe asynchronous computations</li><li><code>Coeval</code> is not cancelable, obviously, since execution is
   immediate and there's nothing to cancel</li></ul><h3>Versus cats.Eval</h3><p>The <code>Coeval</code> data type is very similar with <a href="http://typelevel.org/cats/api/cats/Eval.html" name="cats.Eval" id="cats.Eval" class="extype">cats.Eval</a>.
As a quick comparison:</p><ul><li><code>cats.Eval</code> is only for controlling laziness, but it doesn't
   handle side effects, hence <code>cats.Eval</code> is a <code>Comonad</code></li><li>Monix's <code>Coeval</code> can handle side effects as well and thus it
   implements <code>MonadError[Coeval, Throwable]</code> and
   <code>cats.effect.Sync</code>, providing error-handling utilities</li></ul><p>If you just want to delay the evaluation of a pure expression
use <code>cats.Eval</code>, but if you need to suspend side effects or you
need error handling capabilities, then use <code>Coeval</code>.</p></div><dl class="attributes block"><dt>Self Type</dt><dd><a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.A" class="extype">A</span>]</dd><dt>Source</dt><dd><a href="https://github.com/monix/monix/tree/346352380c4b2b12a66f83cf7ca416dbebde357b/monix-eval/shared/src/main/scala/monix/eval/Coeval.scala" target="_blank">Coeval.scala</a></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a>, () =&gt; <span name="monix.eval.Coeval.A" class="extype">A</span>, <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>, <a href="https://www.scala-lang.org/api/2.13.3/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></div></div></div><div class="toggleContainer"><div class="toggle block"><span>Known Subclasses</span><div class="subClasses hiddenContent"><a href="Coeval$$Always.html" name="monix.eval.Coeval.Always" id="monix.eval.Coeval.Always" class="extype">Always</a>, <a href="Coeval$$Eager.html" name="monix.eval.Coeval.Eager" id="monix.eval.Coeval.Eager" class="extype">Eager</a>, <a href="Coeval$$Error.html" name="monix.eval.Coeval.Error" id="monix.eval.Coeval.Error" class="extype">Error</a>, <a href="Coeval$$Now.html" name="monix.eval.Coeval.Now" id="monix.eval.Coeval.Now" class="extype">Now</a></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="monix.eval.Coeval"><span>Coeval</span></li><li class="in" name="java.io.Serializable"><span>Serializable</span></li><li class="in" name="scala.Function0"><span>Function0</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##:Int"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html###:Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#*&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="*&gt;[B](that:monix.eval.Coeval[B]):monix.eval.Coeval[B]"></a><a id="*&gt;[B](Coeval[B]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#*&gt;[B](that:monix.eval.Coeval[B]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $times$greater">*&gt;</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="that">that: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.*&gt;.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.*&gt;.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Runs this coeval first and then, when successful, the given coeval.</p><div class="fullcomment"><div class="comment cmt"><p>Runs this coeval first and then, when successful, the given coeval.
Returns the result of the given coeval.</p><p>Example:</p><pre><span class="kw">val</span> combined = Coeval{println(<span class="lit">"first"</span>); <span class="lit">"first"</span>} *&gt; Coeval{println(<span class="lit">"second"</span>); <span class="lit">"second"</span>}
<span class="cmt">// Prints "first" and then "second"</span>
<span class="cmt">// Result value will be "second"</span></pre></div></div></li><li class="indented0 " name="monix.eval.Coeval#&lt;*" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="&lt;*[B](that:monix.eval.Coeval[B]):monix.eval.Coeval[A]"></a><a id="&lt;*[B](Coeval[B]):Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#&lt;*[B](that:monix.eval.Coeval[B]):monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $less$times">&lt;*</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="that">that: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.&lt;*.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Runs this coeval first and then, when successful, the given coeval.</p><div class="fullcomment"><div class="comment cmt"><p>Runs this coeval first and then, when successful, the given coeval.
Returns the result of this coeval.</p><p>Example:</p><pre><span class="kw">val</span> combined = Coeval{println(<span class="lit">"first"</span>); <span class="lit">"first"</span>} &lt;* Coeval{println(<span class="lit">"second"</span>); <span class="lit">"second"</span>}
<span class="cmt">// Prints "first" and then "second"</span>
<span class="cmt">// Result value will be "first"</span></pre></div></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#&gt;&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="&gt;&gt;[B](that:=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]"></a><a id="&gt;&gt;[B](=&gt;Coeval[B]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#&gt;&gt;[B](that:=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $greater$greater">&gt;&gt;</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="that">that: =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.&gt;&gt;.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.&gt;&gt;.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Runs this underlying computation first and then, when successful, the given one.</p><div class="fullcomment"><div class="comment cmt"><p>Runs this underlying computation first and then, when successful, the given one.
Returns the result of the given underlying computation.</p><p>Example:</p><pre><span class="kw">val</span> combined = Coeval{println(<span class="lit">"first"</span>); <span class="lit">"first"</span>} &gt;&gt; Coeval{println(<span class="lit">"second"</span>); <span class="lit">"second"</span>}
<span class="cmt">// Prints "first" and then "second"</span>
<span class="cmt">// Result value will be "second"</span></pre></div></div></li><li class="indented0 " name="monix.eval.Coeval#apply" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="apply():A"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#apply():A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">apply</span><span class="params">()</span><span class="result">: <span name="monix.eval.Coeval.A" class="extype">A</span></span></span><p class="shortcomment cmt">Evaluates the underlying computation and returns the result.</p><div class="fullcomment"><div class="comment cmt"><p>Evaluates the underlying computation and returns the result.</p><p>NOTE: this can throw exceptions.</p><pre><span class="cmt">// For didactic purposes, don't do shared vars at home :-)</span>
<span class="kw">var</span> i = <span class="num">0</span>
<span class="kw">val</span> fa = Coeval { i += <span class="num">1</span>; i }

fa() <span class="cmt">// =&gt; 1</span>
fa() <span class="cmt">// =&gt; 2</span>
fa() <span class="cmt">// =&gt; 3</span></pre><p><b>UNSAFE</b> — this operation can trigger the
        execution of side effects, which break referential
        transparency and is thus not a pure function.</p><p>        In FP code use with care, suspended in another <code>Coeval</code>
        or <a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>, or at the edge of the FP
        program.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> → Function0</dd><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#as" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="as[B](b:B):monix.eval.Coeval[B]"></a><a id="as[B](B):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#as[B](b:B):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">as</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="b">b: <span name="monix.eval.Coeval.as.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.as.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns this coeval mapped to the supplied value.</p></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#attempt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="attempt:monix.eval.Coeval[Either[Throwable,A]]"></a><a id="attempt:Coeval[Either[Throwable,A]]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#attempt:monix.eval.Coeval[Either[Throwable,A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">attempt</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="scala.Either" class="extype">Either</span>[<span name="scala.Throwable" class="extype">Throwable</span>, <span name="monix.eval.Coeval.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Creates a new <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> that will expose any triggered error
from the source.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> that will expose any triggered error
from the source.</p><pre><span class="kw">val</span> fa: Coeval[<span class="std">Int</span>] =
  Coeval.raiseError[<span class="std">Int</span>](<span class="kw">new</span> RuntimeException(<span class="lit">"dummy"</span>))

<span class="kw">val</span> fe: Coeval[Either[Throwable, <span class="std">Int</span>]] =
  fa.attempt

fe.map {
  <span class="kw">case</span> Left(_) <span class="kw">=&gt;</span> <span class="std">Int</span>.MaxValue
  <span class="kw">case</span> Right(v) <span class="kw">=&gt;</span> v
}</pre><p>By exposing errors by lifting the <code>Coeval</code>'s result into an
<code>Either</code> value, we can handle those errors in <code>flatMap</code>
transformations.</p><p>Also see <a href="#materialize:monix.eval.Coeval[scala.util.Try[A]]" name="monix.eval.Coeval#materialize" id="monix.eval.Coeval#materialize" class="extmbr">materialize</a> for working with Scala's
<a href="https://www.scala-lang.org/api/2.13.3/scala/util/Try.html" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a> or <a href="#redeemWith[B](recover:Throwable=&gt;monix.eval.Coeval[B],bind:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#redeemWith" id="monix.eval.Coeval#redeemWith" class="extmbr">redeemWith</a> for an alternative.
</p></div></div></li><li class="indented0 " name="monix.eval.Coeval#bracket" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bracket[B](use:A=&gt;monix.eval.Coeval[B])(release:A=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]"></a><a id="bracket[B]((A)=&gt;Coeval[B])((A)=&gt;Coeval[Unit]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#bracket[B](use:A=&gt;monix.eval.Coeval[B])(release:A=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bracket</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="use">use: (<span name="monix.eval.Coeval.A" class="extype">A</span>) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.bracket.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="release">release: (<span name="monix.eval.Coeval.A" class="extype">A</span>) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.bracket.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a task that treats the source as the acquisition of a resource,
which is then exploited by the <code>use</code> function and then <code>released</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a task that treats the source as the acquisition of a resource,
which is then exploited by the <code>use</code> function and then <code>released</code>.</p><p>The <code>bracket</code> operation is the equivalent of the
<code>try {} finally {}</code> statements from mainstream languages, installing
the necessary exception handler to release the resource in the event of
an exception being raised during the computation. If an exception is raised,
then <code>bracket</code> will re-raise the exception <i>after</i> performing the <code>release</code>.</p><p>Example:</p><pre><span class="kw">import</span> java.io._

<span class="kw">def</span> readFile(file: File): Coeval[<span class="std">String</span>] = {
  <span class="cmt">// Opening a file handle for reading text</span>
  <span class="kw">val</span> acquire = Coeval.eval(<span class="kw">new</span> BufferedReader(
    <span class="kw">new</span> InputStreamReader(<span class="kw">new</span> FileInputStream(file), <span class="lit">"utf-8"</span>)
  ))

  acquire.bracket { in <span class="kw">=&gt;</span>
    <span class="cmt">// Usage part</span>
    Coeval.eval {
      <span class="cmt">// Yes, ugly Java, non-FP loop;</span>
      <span class="cmt">// side-effects are suspended though</span>
      <span class="kw">var</span> line: <span class="std">String</span> = <span class="lit">""</span>
      <span class="kw">val</span> buff = <span class="kw">new</span> StringBuilder()
      <span class="kw">while</span> (line != <span class="kw">null</span>) {
        line = in.readLine()
        <span class="kw">if</span> (line != <span class="kw">null</span>) buff.append(line)
      }
      buff.toString()
    }
  } { in <span class="kw">=&gt;</span>
    <span class="cmt">// The release part</span>
    Coeval.eval(in.close())
  }
}</pre><p><b>NOTE on error handling</b>: one big
        difference versus <code>try {} finally {}</code> is that, in case
        both the <code>release</code> function and the <code>use</code> function throws,
        the error raised by <code>use</code> gets signaled and the error
        raised by <code>release</code> gets reported with <code>System.err</code> for
        <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> or with
        <a href="../execution/Scheduler.html#reportFailure(t:Throwable):Unit" name="monix.execution.Scheduler#reportFailure" id="monix.execution.Scheduler#reportFailure" class="extmbr">Scheduler.reportFailure</a>
        for <a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>.</p><p>        For example:</p><pre>Coeval(<span class="lit">"resource"</span>).bracket { _ <span class="kw">=&gt;</span>
  <span class="cmt">// use</span>
  Coeval.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"Foo"</span>))
} { _ <span class="kw">=&gt;</span>
  <span class="cmt">// release</span>
  Coeval.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"Bar"</span>))
}</pre><p>        In this case the error signaled downstream is <code>"Foo"</code>,
        while the <code>"Bar"</code> error gets reported. This is consistent
        with the behavior of Haskell's <code>bracket</code> operation and NOT
        with <code>try {} finally {}</code> from Scala, Java or JavaScript.</p></div><dl class="paramcmts block"><dt class="param">use</dt><dd class="cmt"><p>is a function that evaluates the resource yielded by the source,
       yielding a result that will get generated by the task returned
       by this <code>bracket</code> function</p></dd><dt class="param">release</dt><dd class="cmt"><p>is a function that gets called after <code>use</code> terminates,
       either normally or in error, receiving as input the resource that
       needs to be released</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#bracketCase[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracketCase" id="monix.eval.Coeval#bracketCase" class="extmbr">bracketCase</a> and <a href="#bracketE[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,Either[Throwable,B])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracketE" id="monix.eval.Coeval#bracketE" class="extmbr">bracketE</a></p></span></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#bracketCase" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bracketCase[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]"></a><a id="bracketCase[B]((A)=&gt;Coeval[B])((A,ExitCase[Throwable])=&gt;Coeval[Unit]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#bracketCase[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bracketCase</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="use">use: (<span name="monix.eval.Coeval.A" class="extype">A</span>) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.bracketCase.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="release">release: (<span name="monix.eval.Coeval.A" class="extype">A</span>, <span name="cats.effect.ExitCase" class="extype">ExitCase</span>[<span name="scala.Throwable" class="extype">Throwable</span>]) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.bracketCase.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a new task that treats the source task as the
acquisition of a resource, which is then exploited by the <code>use</code>
function and then <code>released</code>, with the possibility of
distinguishing between successful completion and failure, such
that an appropriate release of resources can be executed.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new task that treats the source task as the
acquisition of a resource, which is then exploited by the <code>use</code>
function and then <code>released</code>, with the possibility of
distinguishing between successful completion and failure, such
that an appropriate release of resources can be executed.</p><p>The <code>bracketCase</code> operation is the equivalent of
<code>try {} catch {} finally {}</code> statements from mainstream languages
when used for the acquisition and release of resources.</p><p>The <code>bracketCase</code> operation installs the necessary exception handler
to release the resource in the event of an exception being raised
during the computation.</p><p>In comparison with the simpler <a href="#bracket[B](use:A=&gt;monix.eval.Coeval[B])(release:A=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracket" id="monix.eval.Coeval#bracket" class="extmbr">bracket</a> version, this one
allows the caller to differentiate between normal termination and
termination in error via an <code>ExitCase</code> parameter.
</p></div><dl class="paramcmts block"><dt class="param">use</dt><dd class="cmt"><p>is a function that evaluates the resource yielded by
       the source, yielding a result that will get generated by
       this function on evaluation</p></dd><dt class="param">release</dt><dd class="cmt"><p>is a function that gets called after <code>use</code>
       terminates, either normally or in error, receiving as
       input the resource that needs that needs release, along
       with the result of <code>use</code></p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#bracket[B](use:A=&gt;monix.eval.Coeval[B])(release:A=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracket" id="monix.eval.Coeval#bracket" class="extmbr">bracket</a> and <a href="#bracketE[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,Either[Throwable,B])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracketE" id="monix.eval.Coeval#bracketE" class="extmbr">bracketE</a></p></span></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#bracketE" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bracketE[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,Either[Throwable,B])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]"></a><a id="bracketE[B]((A)=&gt;Coeval[B])((A,Either[Throwable,B])=&gt;Coeval[Unit]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#bracketE[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,Either[Throwable,B])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bracketE</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="use">use: (<span name="monix.eval.Coeval.A" class="extype">A</span>) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.bracketE.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="release">release: (<span name="monix.eval.Coeval.A" class="extype">A</span>, <span name="scala.Either" class="extype">Either</span>[<span name="scala.Throwable" class="extype">Throwable</span>, <span name="monix.eval.Coeval.bracketE.B" class="extype">B</span>]) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.bracketE.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a task that treats the source task as the acquisition of a resource,
which is then exploited by the <code>use</code> function and then <code>released</code>, with
the possibility of distinguishing between successful termination and
error,  such that an appropriate release of resources can be executed.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a task that treats the source task as the acquisition of a resource,
which is then exploited by the <code>use</code> function and then <code>released</code>, with
the possibility of distinguishing between successful termination and
error,  such that an appropriate release of resources can be executed.</p><p>The <code>bracket</code> operation is the equivalent of the
<code>try {} finally {}</code> statements from mainstream languages, installing
the necessary exception handler to release the resource in the event of
an exception being raised during the computation. If an exception is raised,
then <code>bracket</code> will re-raise the exception <i>after</i> performing the <code>release</code>.</p><p>The <code>release</code> function receives as input:</p><ul><li><code>Left(error)</code> in case <code>use</code> terminated with an error</li><li><code>Right(b)</code> in case of success</li></ul><p><b>NOTE on error handling</b>: one big
        difference versus <code>try {} finally {}</code> is that, in case
        both the <code>release</code> function and the <code>use</code> function throws,
        the error raised by <code>use</code> gets signaled and the error
        raised by <code>release</code> gets reported with <code>System.err</code> for
        <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> or with
        <a href="../execution/Scheduler.html#reportFailure(t:Throwable):Unit" name="monix.execution.Scheduler#reportFailure" id="monix.execution.Scheduler#reportFailure" class="extmbr">Scheduler.reportFailure</a>
        for <a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>.</p><p>        For example:</p><pre>Coeval(<span class="lit">"resource"</span>).bracket { _ <span class="kw">=&gt;</span>
  <span class="cmt">// use</span>
  Coeval.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"Foo"</span>))
} { _ <span class="kw">=&gt;</span>
  <span class="cmt">// release</span>
  Coeval.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"Bar"</span>))
}</pre><p>        In this case the error signaled downstream is <code>"Foo"</code>,
        while the <code>"Bar"</code> error gets reported. This is consistent
        with the behavior of Haskell's <code>bracket</code> operation and NOT
        with <code>try {} finally {}</code> from Scala, Java or JavaScript.</p></div><dl class="paramcmts block"><dt class="param">use</dt><dd class="cmt"><p>is a function that evaluates the resource yielded by the source,
       yielding a result that will get generated by this function on
       evaluation</p></dd><dt class="param">release</dt><dd class="cmt"><p>is a function that gets called after <code>use</code> terminates,
       either normally or in error, receiving as input the resource that
       needs that needs release, along with the result of <code>use</code></p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#bracket[B](use:A=&gt;monix.eval.Coeval[B])(release:A=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracket" id="monix.eval.Coeval#bracket" class="extmbr">bracket</a> and <a href="#bracketCase[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracketCase" id="monix.eval.Coeval#bracketCase" class="extmbr">bracketCase</a></p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object"></a><a id="clone():AnyRef"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#dematerialize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dematerialize[B](implicitev:A&lt;:&lt;scala.util.Try[B]):monix.eval.Coeval[B]"></a><a id="dematerialize[B](&lt;:&lt;[A,Try[B]]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#dematerialize[B](implicitev:A&lt;:&lt;scala.util.Try[B]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">dematerialize</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.3/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.eval.Coeval.A" class="extype">A</span>, <a href="https://www.scala-lang.org/api/2.13.3/scala/util/Try.html#scala.util.Try" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a>[<span name="monix.eval.Coeval.dematerialize.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.dematerialize.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Dematerializes the source's result from a <code>Try</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Dematerializes the source's result from a <code>Try</code>.</p><p>This equivalence always holds:</p><p><code>fa.materialize.dematerialize &lt;-&gt; fa</code>
</p></div></div></li><li class="indented0 " name="monix.eval.Coeval#doOnFinish" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnFinish(f:Option[Throwable]=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[A]"></a><a id="doOnFinish((Option[Throwable])=&gt;Coeval[Unit]):Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#doOnFinish(f:Option[Throwable]=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnFinish</span><span class="params">(<span name="f">f: (<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="scala.Throwable" class="extype">Throwable</span>]) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns a new <code>Coeval</code> in which <code>f</code> is scheduled to be run on completion.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new <code>Coeval</code> in which <code>f</code> is scheduled to be run on completion.
This would typically be used to release any resources acquired by this
<code>Coeval</code>.
</p></div></div></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#equals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="equals(x$1:Object):Boolean"></a><a id="equals(AnyRef):Boolean"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#equals(x$1:Object):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#failed" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="failed:monix.eval.Coeval[Throwable]"></a><a id="failed:Coeval[Throwable]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#failed:monix.eval.Coeval[Throwable]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">failed</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="scala.Throwable" class="extype">Throwable</span>]</span></span><p class="shortcomment cmt">Returns a failed projection of this coeval.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a failed projection of this coeval.</p><p>The failed projection is a <code>Coeval</code> holding a value of type <code>Throwable</code>,
emitting the error yielded by the source, in case the source fails,
otherwise if the source succeeds the result will fail with a
<code>NoSuchElementException</code>.
</p></div></div></li><li class="indented0 " name="monix.eval.Coeval#flatMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatMap[B](f:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]"></a><a id="flatMap[B]((A)=&gt;Coeval[B]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#flatMap[B](f:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.eval.Coeval.A" class="extype">A</span>) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.flatMap.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.flatMap.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new <code>Coeval</code> by applying a function to the successful result
of the source, and returns a new instance equivalent
to the result of the function.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new <code>Coeval</code> by applying a function to the successful result
of the source, and returns a new instance equivalent
to the result of the function.</p><p>The application of <code>flatMap</code> is always lazy and because of the
implementation it is memory safe and thus it can be used in
recursive loops.</p><p>Sample:</p><pre><span class="kw">import</span> scala.util.Random

<span class="kw">def</span> randomEven: Coeval[<span class="std">Int</span>] =
  Coeval(Random.nextInt()).flatMap { x <span class="kw">=&gt;</span>
    <span class="kw">if</span> (x &lt; <span class="num">0</span> || x % <span class="num">2</span> == <span class="num">1</span>)
      randomEven <span class="cmt">// retry</span>
    <span class="kw">else</span>
      Coeval.now(x)
  }</pre></div></div></li><li class="indented0 " name="monix.eval.Coeval#flatMapLoop" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatMapLoop[S](seed:S)(f:(A,S,S=&gt;monix.eval.Coeval[S])=&gt;monix.eval.Coeval[S]):monix.eval.Coeval[S]"></a><a id="flatMapLoop[S](S)((A,S,(S)=&gt;Coeval[S])=&gt;Coeval[S]):Coeval[S]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#flatMapLoop[S](seed:S)(f:(A,S,S=&gt;monix.eval.Coeval[S])=&gt;monix.eval.Coeval[S]):monix.eval.Coeval[S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatMapLoop</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: <span name="monix.eval.Coeval.flatMapLoop.S" class="extype">S</span></span>)</span><span class="params">(<span name="f">f: (<span name="monix.eval.Coeval.A" class="extype">A</span>, <span name="monix.eval.Coeval.flatMapLoop.S" class="extype">S</span>, (<span name="monix.eval.Coeval.flatMapLoop.S" class="extype">S</span>) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.flatMapLoop.S" class="extype">S</span>]) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.flatMapLoop.S" class="extype">S</span>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.flatMapLoop.S" class="extype">S</span>]</span></span><p class="shortcomment cmt">Describes flatMap-driven loops, as an alternative to recursive functions.</p><div class="fullcomment"><div class="comment cmt"><p>Describes flatMap-driven loops, as an alternative to recursive functions.</p><p>Sample:</p><pre><span class="kw">import</span> scala.util.Random

<span class="kw">val</span> random = Coeval(Random.nextInt())
<span class="kw">val</span> loop = random.flatMapLoop(Vector.empty[<span class="std">Int</span>]) { (a, list, continue) <span class="kw">=&gt;</span>
  <span class="kw">val</span> newList = list :+ a
  <span class="kw">if</span> (newList.length &lt; <span class="num">5</span>)
    continue(newList)
  <span class="kw">else</span>
    Coeval.now(newList)
}</pre></div><dl class="paramcmts block"><dt class="param">seed</dt><dd class="cmt"><p>initializes the result of the loop</p></dd><dt class="param">f</dt><dd class="cmt"><p>is the function that updates the result
       on each iteration, returning a <code>Coeval</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>a new <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> that contains the result of the loop.</p></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#flatten" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatten[B](implicitev:A&lt;:&lt;monix.eval.Coeval[B]):monix.eval.Coeval[B]"></a><a id="flatten[B](&lt;:&lt;[A,Coeval[B]]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#flatten[B](implicitev:A&lt;:&lt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatten</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.3/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.eval.Coeval.A" class="extype">A</span>, <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.flatten.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.flatten.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Given a source Coeval that emits another Coeval, this function
flattens the result, returning a Coeval equivalent to the emitted
Coeval by the source.</p><div class="fullcomment"><div class="comment cmt"><p>Given a source Coeval that emits another Coeval, this function
flattens the result, returning a Coeval equivalent to the emitted
Coeval by the source.</p><p>This equivalence with <a href="#flatMap[B](f:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#flatMap" id="monix.eval.Coeval#flatMap" class="extmbr">flatMap</a> always holds:</p><p><code>fa.flatten &lt;-&gt; fa.flatMap(x =&gt; x)</code>
</p></div></div></li><li class="indented0 " name="monix.eval.Coeval#foreach" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foreach(f:A=&gt;Unit):Unit"></a><a id="foreach((A)=&gt;Unit):Unit"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#foreach(f:A=&gt;Unit):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foreach</span><span class="params">(<span name="f">f: (<span name="monix.eval.Coeval.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><p class="shortcomment cmt">Triggers the evaluation of the source, executing
the given function for the generated element.</p><div class="fullcomment"><div class="comment cmt"><p>Triggers the evaluation of the source, executing
the given function for the generated element.</p><p>The application of this function has strict
behavior, as the coeval is immediately executed.
</p></div></div></li><li class="indented0 " name="monix.eval.Coeval#foreachL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foreachL(f:A=&gt;Unit):monix.eval.Coeval[Unit]"></a><a id="foreachL((A)=&gt;Unit):Coeval[Unit]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#foreachL(f:A=&gt;Unit):monix.eval.Coeval[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foreachL</span><span class="params">(<span name="f">f: (<span name="monix.eval.Coeval.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Returns a new task that upon evaluation will execute
the given function for the generated element,
transforming the source into a <code>Coeval[Unit]</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new task that upon evaluation will execute
the given function for the generated element,
transforming the source into a <code>Coeval[Unit]</code>.</p><p>Similar in spirit with normal <a href="#foreach(f:A=&gt;Unit):Unit" name="monix.eval.Coeval#foreach" id="monix.eval.Coeval#foreach" class="extmbr">foreach</a>, but lazy,
as obviously nothing gets executed at this point.
</p></div></div></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]"></a><a id="getClass():Class[_&lt;:AnyRef]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html#java.lang.Class" name="java.lang.Class" id="java.lang.Class" class="extype">Class</a>[_ &lt;: <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#guarantee" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="guarantee(finalizer:monix.eval.Coeval[Unit]):monix.eval.Coeval[A]"></a><a id="guarantee(Coeval[Unit]):Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#guarantee(finalizer:monix.eval.Coeval[Unit]):monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">guarantee</span><span class="params">(<span name="finalizer">finalizer: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Executes the given <code>finalizer</code> when the source is finished,
either in success or in error, or if canceled.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the given <code>finalizer</code> when the source is finished,
either in success or in error, or if canceled.</p><p>This variant of <a href="#guaranteeCase(finalizer:cats.effect.ExitCase[Throwable]=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[A]" name="monix.eval.Coeval#guaranteeCase" id="monix.eval.Coeval#guaranteeCase" class="extmbr">guaranteeCase</a> evaluates the given <code>finalizer</code>
regardless of how the source gets terminated:</p><ul><li>normal completion</li><li>completion in error</li><li>cancellation</li></ul><p>As best practice, it's not a good idea to release resources
via <code>guaranteeCase</code> in polymorphic code. Prefer <a href="#bracket[B](use:A=&gt;monix.eval.Coeval[B])(release:A=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracket" id="monix.eval.Coeval#bracket" class="extmbr">bracket</a>
for the acquisition and release of resources.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#guaranteeCase(finalizer:cats.effect.ExitCase[Throwable]=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[A]" name="monix.eval.Coeval#guaranteeCase" id="monix.eval.Coeval#guaranteeCase" class="extmbr">guaranteeCase</a> for the version that can discriminate
     between termination conditions</p></span><span class="cmt"><p><a href="#bracket[B](use:A=&gt;monix.eval.Coeval[B])(release:A=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracket" id="monix.eval.Coeval#bracket" class="extmbr">bracket</a> for the more general operation</p></span></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#guaranteeCase" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="guaranteeCase(finalizer:cats.effect.ExitCase[Throwable]=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[A]"></a><a id="guaranteeCase((ExitCase[Throwable])=&gt;Coeval[Unit]):Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#guaranteeCase(finalizer:cats.effect.ExitCase[Throwable]=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">guaranteeCase</span><span class="params">(<span name="finalizer">finalizer: (<span name="cats.effect.ExitCase" class="extype">ExitCase</span>[<span name="scala.Throwable" class="extype">Throwable</span>]) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Executes the given <code>finalizer</code> when the source is finished,
either in success or in error, or if canceled, allowing
for differentiating between exit conditions.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the given <code>finalizer</code> when the source is finished,
either in success or in error, or if canceled, allowing
for differentiating between exit conditions.</p><p>This variant of <a href="#guarantee(finalizer:monix.eval.Coeval[Unit]):monix.eval.Coeval[A]" name="monix.eval.Coeval#guarantee" id="monix.eval.Coeval#guarantee" class="extmbr">guarantee</a> injects an ExitCase in
the provided function, allowing one to make a difference
between:</p><ul><li>normal completion</li><li>completion in error</li><li>cancellation</li></ul><p>As best practice, it's not a good idea to release resources
via <code>guaranteeCase</code> in polymorphic code. Prefer <a href="#bracketCase[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracketCase" id="monix.eval.Coeval#bracketCase" class="extmbr">bracketCase</a>
for the acquisition and release of resources.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#guarantee(finalizer:monix.eval.Coeval[Unit]):monix.eval.Coeval[A]" name="monix.eval.Coeval#guarantee" id="monix.eval.Coeval#guarantee" class="extmbr">guarantee</a> for the simpler version</p></span><span class="cmt"><p><a href="#bracketCase[B](use:A=&gt;monix.eval.Coeval[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Coeval[Unit]):monix.eval.Coeval[B]" name="monix.eval.Coeval#bracketCase" id="monix.eval.Coeval#bracketCase" class="extmbr">bracketCase</a> for the more general operation</p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#hashCode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hashCode():Int"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#hashCode():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#map" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="map[B](f:A=&gt;B):monix.eval.Coeval[B]"></a><a id="map[B]((A)=&gt;B):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#map[B](f:A=&gt;B):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">map</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.eval.Coeval.A" class="extype">A</span>) =&gt; <span name="monix.eval.Coeval.map.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.map.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a new <code>Coeval</code> that applies the mapping function to
the element emitted by the source.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new <code>Coeval</code> that applies the mapping function to
the element emitted by the source.</p><p>Can be used for specifying a (lazy) transformation to the result
of the source.</p><p>This equivalence with <a href="#flatMap[B](f:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#flatMap" id="monix.eval.Coeval#flatMap" class="extmbr">flatMap</a> always holds:</p><p><code>fa.map(f) &lt;-&gt; fa.flatMap(x =&gt; Coeval.pure(f(x)))</code>
</p></div></div></li><li class="indented0 " name="monix.eval.Coeval#materialize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="materialize:monix.eval.Coeval[scala.util.Try[A]]"></a><a id="materialize:Coeval[Try[A]]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#materialize:monix.eval.Coeval[scala.util.Try[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">materialize</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/util/Try.html#scala.util.Try" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a>[<span name="monix.eval.Coeval.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Creates a new <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> that will expose any triggered error from
the source.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> that will expose any triggered error from
the source.</p><p>Also see <a href="#attempt:monix.eval.Coeval[Either[Throwable,A]]" name="monix.eval.Coeval#attempt" id="monix.eval.Coeval#attempt" class="extmbr">attempt</a> for working with Scala's
<a href="https://www.scala-lang.org/api/2.13.3/scala/index.html#Either[+A,+B]=scala.util.Either[A,B]" name="scala" id="scala" class="extype">Either</a> or <a href="#redeemWith[B](recover:Throwable=&gt;monix.eval.Coeval[B],bind:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#redeemWith" id="monix.eval.Coeval#redeemWith" class="extmbr">redeemWith</a> for an alternative.
</p></div></div></li><li class="indented0 " name="monix.eval.Coeval#memoize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="memoize:monix.eval.Coeval[A]"></a><a id="memoize:Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#memoize:monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">memoize</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Memoizes (caches) the result of the source and reuses it on
subsequent invocations of <code>value</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Memoizes (caches) the result of the source and reuses it on
subsequent invocations of <code>value</code>.</p><p>The resulting coeval will be idempotent, meaning that
evaluating the resulting coeval multiple times will have the
same effect as evaluating it once.</p><p><b>UNSAFE</b> — this operation allocates a shared,
        mutable reference, which can break in certain cases
        referential transparency, even if this operation guarantees
        idempotency (i.e. referential transparency implies idempotency,
        but idempotency does not imply referential transparency).</p><p>        The allocation of a mutable reference is known to be a
        side effect, thus breaking referential transparency,
        even if calling this method does not trigger the evaluation
        of side effects suspended by the source.</p><p>        Use with care. Sometimes it's easier to just keep a shared,
        memoized reference to some connection, but keep in mind
        it might be better to pass such a reference around as
        a parameter.
</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd><dt>See also</dt><dd><span class="cmt"><p><a href="#memoizeOnSuccess:monix.eval.Coeval[A]" name="monix.eval.Coeval#memoizeOnSuccess" id="monix.eval.Coeval#memoizeOnSuccess" class="extmbr">memoizeOnSuccess</a> for a version that only caches
    successful results</p></span></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#memoizeOnSuccess" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="memoizeOnSuccess:monix.eval.Coeval[A]"></a><a id="memoizeOnSuccess:Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#memoizeOnSuccess:monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">memoizeOnSuccess</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Memoizes (cache) the successful result of the source
and reuses it on subsequent invocations of <code>value</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Memoizes (cache) the successful result of the source
and reuses it on subsequent invocations of <code>value</code>.
Thrown exceptions are not cached.</p><p>The resulting coeval will be idempotent, but only if the
result is successful.</p><p><b>UNSAFE</b> — this operation allocates a shared,
        mutable reference, which can break in certain cases
        referential transparency, even if this operation guarantees
        idempotency (i.e. referential transparency implies idempotency,
        but idempotency does not imply referential transparency).</p><p>        The allocation of a mutable reference is known to be a
        side effect, thus breaking referential transparency,
        even if calling this method does not trigger the evaluation
        of side effects suspended by the source.</p><p>        Use with care. Sometimes it's easier to just keep a shared,
        memoized reference to some connection, but keep in mind
        it might be better to pass such a reference around as
        a parameter.
</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd><dt>See also</dt><dd><span class="cmt"><p><a href="#memoize:monix.eval.Coeval[A]" name="monix.eval.Coeval#memoize" id="monix.eval.Coeval#memoize" class="extmbr">memoize</a> for a version that caches both successful
    results and failures</p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#onErrorFallbackTo" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="onErrorFallbackTo[B&gt;:A](that:monix.eval.Coeval[B]):monix.eval.Coeval[B]"></a><a id="onErrorFallbackTo[B&gt;:A](Coeval[B]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#onErrorFallbackTo[B&gt;:A](that:monix.eval.Coeval[B]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorFallbackTo</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.eval.Coeval.A" class="extype">A</span></span>]</span><span class="params">(<span name="that">that: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorFallbackTo.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorFallbackTo.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new coeval that in case of error will fallback to the
given backup coeval.</p></li><li class="indented0 " name="monix.eval.Coeval#onErrorHandle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorHandle[U&gt;:A](f:Throwable=&gt;U):monix.eval.Coeval[U]"></a><a id="onErrorHandle[U&gt;:A]((Throwable)=&gt;U):Coeval[U]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#onErrorHandle[U&gt;:A](f:Throwable=&gt;U):monix.eval.Coeval[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorHandle</span><span class="tparams">[<span name="U">U &gt;: <span name="monix.eval.Coeval.A" class="extype">A</span></span>]</span><span class="params">(<span name="f">f: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <span name="monix.eval.Coeval.onErrorHandle.U" class="extype">U</span></span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorHandle.U" class="extype">U</span>]</span></span><p class="shortcomment cmt">Creates a new coeval that will handle any matching throwable that
this coeval might emit.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new coeval that will handle any matching throwable that
this coeval might emit.</p><p>See <a href="#onErrorRecover[U&gt;:A](pf:PartialFunction[Throwable,U]):monix.eval.Coeval[U]" name="monix.eval.Coeval#onErrorRecover" id="monix.eval.Coeval#onErrorRecover" class="extmbr">onErrorRecover</a> for the version that takes a partial function.
</p></div></div></li><li class="indented0 " name="monix.eval.Coeval#onErrorHandleWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorHandleWith[B&gt;:A](f:Throwable=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]"></a><a id="onErrorHandleWith[B&gt;:A]((Throwable)=&gt;Coeval[B]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#onErrorHandleWith[B&gt;:A](f:Throwable=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorHandleWith</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.eval.Coeval.A" class="extype">A</span></span>]</span><span class="params">(<span name="f">f: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorHandleWith.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorHandleWith.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new coeval that will handle any matching throwable that
this coeval might emit by executing another coeval.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new coeval that will handle any matching throwable that
this coeval might emit by executing another coeval.</p><p>See <a href="#onErrorRecoverWith[B&gt;:A](pf:PartialFunction[Throwable,monix.eval.Coeval[B]]):monix.eval.Coeval[B]" name="monix.eval.Coeval#onErrorRecoverWith" id="monix.eval.Coeval#onErrorRecoverWith" class="extmbr">onErrorRecoverWith</a> for the version that takes a partial function.
</p></div></div></li><li class="indented0 " name="monix.eval.Coeval#onErrorRecover" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRecover[U&gt;:A](pf:PartialFunction[Throwable,U]):monix.eval.Coeval[U]"></a><a id="onErrorRecover[U&gt;:A](PartialFunction[Throwable,U]):Coeval[U]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#onErrorRecover[U&gt;:A](pf:PartialFunction[Throwable,U]):monix.eval.Coeval[U]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRecover</span><span class="tparams">[<span name="U">U &gt;: <span name="monix.eval.Coeval.A" class="extype">A</span></span>]</span><span class="params">(<span name="pf">pf: <a href="https://www.scala-lang.org/api/2.13.3/scala/PartialFunction.html#scala.PartialFunction" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<span name="scala.Throwable" class="extype">Throwable</span>, <span name="monix.eval.Coeval.onErrorRecover.U" class="extype">U</span>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorRecover.U" class="extype">U</span>]</span></span><p class="shortcomment cmt">Creates a new coeval that on error will try to map the error
to another value using the provided partial function.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new coeval that on error will try to map the error
to another value using the provided partial function.</p><p>See <a href="#onErrorHandle[U&gt;:A](f:Throwable=&gt;U):monix.eval.Coeval[U]" name="monix.eval.Coeval#onErrorHandle" id="monix.eval.Coeval#onErrorHandle" class="extmbr">onErrorHandle</a> for the version that takes a total function.
</p></div></div></li><li class="indented0 " name="monix.eval.Coeval#onErrorRecoverWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRecoverWith[B&gt;:A](pf:PartialFunction[Throwable,monix.eval.Coeval[B]]):monix.eval.Coeval[B]"></a><a id="onErrorRecoverWith[B&gt;:A](PartialFunction[Throwable,Coeval[B]]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#onErrorRecoverWith[B&gt;:A](pf:PartialFunction[Throwable,monix.eval.Coeval[B]]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRecoverWith</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.eval.Coeval.A" class="extype">A</span></span>]</span><span class="params">(<span name="pf">pf: <a href="https://www.scala-lang.org/api/2.13.3/scala/PartialFunction.html#scala.PartialFunction" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<span name="scala.Throwable" class="extype">Throwable</span>, <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorRecoverWith.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorRecoverWith.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new coeval that will try recovering from an error by
matching it with another coeval using the given partial function.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new coeval that will try recovering from an error by
matching it with another coeval using the given partial function.</p><p>See <a href="#onErrorHandleWith[B&gt;:A](f:Throwable=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#onErrorHandleWith" id="monix.eval.Coeval#onErrorHandleWith" class="extmbr">onErrorHandleWith</a> for the version that takes a total function.
</p></div></div></li><li class="indented0 " name="monix.eval.Coeval#onErrorRestart" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRestart(maxRetries:Long):monix.eval.Coeval[A]"></a><a id="onErrorRestart(Long):Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#onErrorRestart(maxRetries:Long):monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRestart</span><span class="params">(<span name="maxRetries">maxRetries: <a href="https://www.scala-lang.org/api/2.13.3/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new coeval that in case of error will retry executing the
source again and again, until it succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new coeval that in case of error will retry executing the
source again and again, until it succeeds.</p><p>In case of continuous failure the total number of executions
will be <code>maxRetries + 1</code>.
</p></div></div></li><li class="indented0 " name="monix.eval.Coeval#onErrorRestartIf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRestartIf(p:Throwable=&gt;Boolean):monix.eval.Coeval[A]"></a><a id="onErrorRestartIf((Throwable)=&gt;Boolean):Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#onErrorRestartIf(p:Throwable=&gt;Boolean):monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRestartIf</span><span class="params">(<span name="p">p: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new coeval that in case of error will retry executing the
source again and again, until it succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new coeval that in case of error will retry executing the
source again and again, until it succeeds.</p><p>In case of continuous failure the total number of executions
will be <code>maxRetries + 1</code>.
</p></div></div></li><li class="indented0 " name="monix.eval.Coeval#onErrorRestartLoop" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRestartLoop[S,B&gt;:A](initial:S)(f:(Throwable,S,S=&gt;monix.eval.Coeval[B])=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]"></a><a id="onErrorRestartLoop[S,B&gt;:A](S)((Throwable,S,(S)=&gt;Coeval[B])=&gt;Coeval[B]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#onErrorRestartLoop[S,B&gt;:A](initial:S)(f:(Throwable,S,S=&gt;monix.eval.Coeval[B])=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRestartLoop</span><span class="tparams">[<span name="S">S</span>, <span name="B">B &gt;: <span name="monix.eval.Coeval.A" class="extype">A</span></span>]</span><span class="params">(<span name="initial">initial: <span name="monix.eval.Coeval.onErrorRestartLoop.S" class="extype">S</span></span>)</span><span class="params">(<span name="f">f: (<span name="scala.Throwable" class="extype">Throwable</span>, <span name="monix.eval.Coeval.onErrorRestartLoop.S" class="extype">S</span>, (<span name="monix.eval.Coeval.onErrorRestartLoop.S" class="extype">S</span>) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorRestartLoop.B" class="extype">B</span>]) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorRestartLoop.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.onErrorRestartLoop.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">On error restarts the source with a customizable restart loop.</p><div class="fullcomment"><div class="comment cmt"><p>On error restarts the source with a customizable restart loop.</p><p>This operation keeps an internal <code>state</code>, with a start value, an internal
state that gets evolved and based on which the next step gets decided,
e.g. should it restart, or should it give up and rethrow the current error.</p><p>Example that implements a simple retry policy that retries for a maximum
of 10 times before giving up:</p><pre><span class="kw">import</span> scala.util.Random

<span class="kw">val</span> fa = Coeval {
  <span class="kw">if</span> (Random.nextInt(<span class="num">20</span>) &gt; <span class="num">10</span>)
    <span class="kw">throw</span> <span class="kw">new</span> RuntimeException(<span class="lit">"boo"</span>)
  <span class="kw">else</span> <span class="num">78</span>
}

fa.onErrorRestartLoop(<span class="num">10</span>) { (err, maxRetries, retry) <span class="kw">=&gt;</span>
  <span class="kw">if</span> (maxRetries &gt; <span class="num">0</span>)
    <span class="cmt">// Do next retry please</span>
    retry(maxRetries - <span class="num">1</span>)
  <span class="kw">else</span>
    <span class="cmt">// No retries left, rethrow the error</span>
    Coeval.raiseError(err)
}</pre><p>The given function injects the following parameters:</p><ol class="decimal"><li><code>error</code> reference that was thrown
 2. the current <code>state</code>, based on which a decision for the retry is made
 3. <code>retry: S =&gt; Task[B]</code> function that schedules the next retry
</li></ol></div><dl class="paramcmts block"><dt class="param">initial</dt><dd class="cmt"><p>is the initial state used to determine the next on error
       retry cycle</p></dd><dt class="param">f</dt><dd class="cmt"><p>is a function that injects the current error, state, a
       function that can signal a retry is to be made and returns
       the next coeval</p></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#redeem" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="redeem[B](recover:Throwable=&gt;B,map:A=&gt;B):monix.eval.Coeval[B]"></a><a id="redeem[B]((Throwable)=&gt;B,(A)=&gt;B):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#redeem[B](recover:Throwable=&gt;B,map:A=&gt;B):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">redeem</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="recover">recover: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <span name="monix.eval.Coeval.redeem.B" class="extype">B</span></span>, <span name="map">map: (<span name="monix.eval.Coeval.A" class="extype">A</span>) =&gt; <span name="monix.eval.Coeval.redeem.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.redeem.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a new value that transforms the result of the source,
given the <code>recover</code> or <code>map</code> functions, which get executed depending
on whether the result is successful or if it ends in error.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new value that transforms the result of the source,
given the <code>recover</code> or <code>map</code> functions, which get executed depending
on whether the result is successful or if it ends in error.</p><p>This is an optimization on usage of <a href="#attempt:monix.eval.Coeval[Either[Throwable,A]]" name="monix.eval.Coeval#attempt" id="monix.eval.Coeval#attempt" class="extmbr">attempt</a> and <a href="#map[B](f:A=&gt;B):monix.eval.Coeval[B]" name="monix.eval.Coeval#map" id="monix.eval.Coeval#map" class="extmbr">map</a>,
this equivalence being true:</p><p><code>coeval.redeem(recover, map) &lt;-&gt; coeval.attempt.map(_.fold(recover, map))</code></p><p>Usage of <code>redeem</code> subsumes <a href="#onErrorHandle[U&gt;:A](f:Throwable=&gt;U):monix.eval.Coeval[U]" name="monix.eval.Coeval#onErrorHandle" id="monix.eval.Coeval#onErrorHandle" class="extmbr">onErrorHandle</a> because:</p><p><code>coeval.redeem(fe, id) &lt;-&gt; coeval.onErrorHandle(fe)</code>
</p></div><dl class="paramcmts block"><dt class="param">recover</dt><dd class="cmt"><p>is a function used for error recover in case the
       source ends in error</p></dd><dt class="param">map</dt><dd class="cmt"><p>is a function used for mapping the result of the source
       in case it ends in success</p></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#redeemWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="redeemWith[B](recover:Throwable=&gt;monix.eval.Coeval[B],bind:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]"></a><a id="redeemWith[B]((Throwable)=&gt;Coeval[B],(A)=&gt;Coeval[B]):Coeval[B]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#redeemWith[B](recover:Throwable=&gt;monix.eval.Coeval[B],bind:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">redeemWith</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="recover">recover: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.redeemWith.B" class="extype">B</span>]</span>, <span name="bind">bind: (<span name="monix.eval.Coeval.A" class="extype">A</span>) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.redeemWith.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.redeemWith.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a new value that transforms the result of the source,
given the <code>recover</code> or <code>bind</code> functions, which get executed depending
on whether the result is successful or if it ends in error.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new value that transforms the result of the source,
given the <code>recover</code> or <code>bind</code> functions, which get executed depending
on whether the result is successful or if it ends in error.</p><p>This is an optimization on usage of <a href="#attempt:monix.eval.Coeval[Either[Throwable,A]]" name="monix.eval.Coeval#attempt" id="monix.eval.Coeval#attempt" class="extmbr">attempt</a> and <a href="#flatMap[B](f:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#flatMap" id="monix.eval.Coeval#flatMap" class="extmbr">flatMap</a>,
this equivalence being available:</p><p><code>coeval.redeemWith(recover, bind) &lt;-&gt; coeval.attempt.flatMap(_.fold(recover, bind))</code></p><p>Usage of <code>redeemWith</code> subsumes <a href="#onErrorHandleWith[B&gt;:A](f:Throwable=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#onErrorHandleWith" id="monix.eval.Coeval#onErrorHandleWith" class="extmbr">onErrorHandleWith</a> because:</p><p><code>coeval.redeemWith(fe, F.pure) &lt;-&gt; coeval.onErrorHandleWith(fe)</code></p><p>Usage of <code>redeemWith</code> also subsumes <a href="#flatMap[B](f:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#flatMap" id="monix.eval.Coeval#flatMap" class="extmbr">flatMap</a> because:</p><p><code>coeval.redeemWith(Coeval.raiseError, fs) &lt;-&gt; coeval.flatMap(fs)</code>
</p></div><dl class="paramcmts block"><dt class="param">recover</dt><dd class="cmt"><p>is the function that gets called to recover the source
       in case of error</p></dd><dt class="param">bind</dt><dd class="cmt"><p>is the function that gets to transform the source
       in case of success</p></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#restartUntil" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="restartUntil(p:A=&gt;Boolean):monix.eval.Coeval[A]"></a><a id="restartUntil((A)=&gt;Boolean):Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#restartUntil(p:A=&gt;Boolean):monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">restartUntil</span><span class="params">(<span name="p">p: (<span name="monix.eval.Coeval.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Given a predicate function, keep retrying the
coeval until the function returns true.</p></li><li class="indented0 " name="monix.eval.Coeval#run" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="run():monix.eval.Coeval.Eager[A]"></a><a id="run():Eager[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#run():monix.eval.Coeval.Eager[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">run</span><span class="params">()</span><span class="result">: <a href="Coeval$$Eager.html" name="monix.eval.Coeval.Eager" id="monix.eval.Coeval.Eager" class="extype">Eager</a>[<span name="monix.eval.Coeval.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Evaluates the underlying computation, reducing this <code>Coeval</code>
to a <a href="Coeval$$Eager.html" name="monix.eval.Coeval.Eager" id="monix.eval.Coeval.Eager" class="extype">Coeval.Eager</a> value, with successful results being
signaled with <a href="Coeval$$Now.html" name="monix.eval.Coeval.Now" id="monix.eval.Coeval.Now" class="extype">Coeval.Now</a> and failures with <a href="Coeval$$Error.html" name="monix.eval.Coeval.Error" id="monix.eval.Coeval.Error" class="extype">Coeval.Error</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Evaluates the underlying computation, reducing this <code>Coeval</code>
to a <a href="Coeval$$Eager.html" name="monix.eval.Coeval.Eager" id="monix.eval.Coeval.Eager" class="extype">Coeval.Eager</a> value, with successful results being
signaled with <a href="Coeval$$Now.html" name="monix.eval.Coeval.Now" id="monix.eval.Coeval.Now" class="extype">Coeval.Now</a> and failures with <a href="Coeval$$Error.html" name="monix.eval.Coeval.Error" id="monix.eval.Coeval.Error" class="extype">Coeval.Error</a>.</p><pre><span class="kw">val</span> fa = Coeval.eval(<span class="num">10</span> * <span class="num">2</span>)

fa.run() <span class="kw">match</span> {
  <span class="kw">case</span> Coeval.Now(value) <span class="kw">=&gt;</span>
    println(<span class="lit">"Success: "</span> + value)
  <span class="kw">case</span> Coeval.Error(e) <span class="kw">=&gt;</span>
    e.printStackTrace()
}</pre><p>See [.runAttempt()]] for working with <a href="https://www.scala-lang.org/api/2.13.3/scala/index.html#Either[+A,+B]=scala.util.Either[A,B]" name="scala" id="scala" class="extype">Either</a>
values and [.runTry()]] for working with <a href="https://www.scala-lang.org/api/2.13.3/scala/util/Try.html" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a>
values. See <a href="#apply():A" name="monix.eval.Coeval#apply" id="monix.eval.Coeval#apply" class="extmbr">apply</a> for a partial function (that may throw
exceptions in case of failure).</p><p><b>UNSAFE</b> — this operation can trigger the
        execution of side effects, which break referential
        transparency and is thus not a pure function.</p><p>        In FP code use with care, suspended in another <code>Coeval</code>
        or <a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>, or at the edge of the FP
        program.</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#runAttempt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runAttempt():Either[Throwable,A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#runAttempt():Either[Throwable,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runAttempt</span><span class="params">()</span><span class="result">: <span name="scala.Either" class="extype">Either</span>[<span name="scala.Throwable" class="extype">Throwable</span>, <span name="monix.eval.Coeval.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Evaluates the underlying computation and returns the result or
any triggered errors as a Scala <code>Either</code>, where <code>Right(_)</code> is
for successful values and <code>Left(_)</code> is for thrown errors.</p><div class="fullcomment"><div class="comment cmt"><p>Evaluates the underlying computation and returns the result or
any triggered errors as a Scala <code>Either</code>, where <code>Right(_)</code> is
for successful values and <code>Left(_)</code> is for thrown errors.</p><pre><span class="kw">val</span> fa = Coeval(<span class="num">10</span> * <span class="num">2</span>)

fa.runAttempt() <span class="kw">match</span> {
  <span class="kw">case</span> Right(value) <span class="kw">=&gt;</span>
    println(<span class="lit">"Success: "</span> + value)
  <span class="kw">case</span> Left(e) <span class="kw">=&gt;</span>
    e.printStackTrace()
}</pre><p>See <a href="#run():monix.eval.Coeval.Eager[A]" name="monix.eval.Coeval#run" id="monix.eval.Coeval#run" class="extmbr">run</a> for working with <a href="Coeval$$Eager.html" name="monix.eval.Coeval.Eager" id="monix.eval.Coeval.Eager" class="extype">Coeval.Eager</a> values and
[.runTry()]] for working with <a href="https://www.scala-lang.org/api/2.13.3/scala/util/Try.html" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a> values.
See <a href="#apply():A" name="monix.eval.Coeval#apply" id="monix.eval.Coeval#apply" class="extmbr">apply</a> for a partial function (that may throw exceptions
in case of failure).</p><p><b>UNSAFE</b> — this operation can trigger the
        execution of side effects, which break referential
        transparency and is thus not a pure function.</p><p>        In FP code use with care, suspended in another <code>Coeval</code>
        or <a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>, or at the edge of the FP
        program.</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#runTry" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runTry():scala.util.Try[A]"></a><a id="runTry():Try[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#runTry():scala.util.Try[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runTry</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/util/Try.html#scala.util.Try" name="scala.util.Try" id="scala.util.Try" class="extype">Try</a>[<span name="monix.eval.Coeval.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Evaluates the underlying computation and returns the
result or any triggered errors as a <code>scala.util.Try</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Evaluates the underlying computation and returns the
result or any triggered errors as a <code>scala.util.Try</code>.</p><pre><span class="kw">import</span> scala.util._

<span class="kw">val</span> fa = Coeval(<span class="num">10</span> * <span class="num">2</span>)

fa.runTry() <span class="kw">match</span> {
  <span class="kw">case</span> Success(value) <span class="kw">=&gt;</span>
    println(<span class="lit">"Success: "</span> + value)
  <span class="kw">case</span> Failure(e) <span class="kw">=&gt;</span>
    e.printStackTrace()
}</pre><p>See <a href="#run():monix.eval.Coeval.Eager[A]" name="monix.eval.Coeval#run" id="monix.eval.Coeval#run" class="extmbr">run</a> for working with <a href="Coeval$$Eager.html" name="monix.eval.Coeval.Eager" id="monix.eval.Coeval.Eager" class="extype">Coeval.Eager</a> values and
[.runAttempt()]] for working with <a href="https://www.scala-lang.org/api/2.13.3/scala/index.html#Either[+A,+B]=scala.util.Either[A,B]" name="scala" id="scala" class="extype">Either</a> values.
See <a href="#apply():A" name="monix.eval.Coeval#apply" id="monix.eval.Coeval#apply" class="extmbr">apply</a> for a partial function (that may throw exceptions
in case of failure).</p><p><b>UNSAFE</b> — this operation can trigger the
        execution of side effects, which break referential
        transparency and is thus not a pure function.</p><p>        In FP code use with care, suspended in another <code>Coeval</code>
        or <a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>, or at the edge of the FP
        program.</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](=&gt;T0):T0"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#tapError" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="tapError[B](f:Throwable=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[A]"></a><a id="tapError[B]((Throwable)=&gt;Coeval[B]):Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#tapError[B](f:Throwable=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">tapError</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.tapError.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new <code>Coeval</code> that will run the given function in case of error
and raise the original error in case the provided function is successful.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new <code>Coeval</code> that will run the given function in case of error
and raise the original error in case the provided function is successful.</p><p>Example:</p><pre><span class="cmt">// will result in Left("Error")</span>
Coeval
   .raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"Error"</span>))
   .tapError(err <span class="kw">=&gt;</span> Coeval(err))</pre><p>If provided function returns an error then the resulting coeval will raise that error instead.</p><p>Example:</p><pre><span class="cmt">// will result in Left("Error2")</span>
Coeval
   .raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"Error1"</span>))
   .tapError(err <span class="kw">=&gt;</span> Coeval.raiseError(<span class="kw">new</span> RuntimeException(<span class="lit">"Error2"</span>)))</pre></div></div></li><li class="indented0 " name="monix.eval.Coeval#tapEval" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="tapEval[B](f:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[A]"></a><a id="tapEval[B]((A)=&gt;Coeval[B]):Coeval[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#tapEval[B](f:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">tapEval</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.eval.Coeval.A" class="extype">A</span>) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.tapEval.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new <code>Coeval</code> that will run the given function on the success
and return the original value.</p></li><li class="indented0 " name="monix.eval.Coeval#to" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="to[F[_]](implicitF:monix.eval.CoevalLift[F]):F[A@scala.annotation.unchecked.uncheckedVariance]"></a><a id="to[F[_]](CoevalLift[F]):F[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#to[F[_]](implicitF:monix.eval.CoevalLift[F]):F[A@scala.annotation.unchecked.uncheckedVariance]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">to</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="CoevalLift.html" name="monix.eval.CoevalLift" id="monix.eval.CoevalLift" class="extype">CoevalLift</a>[<span name="monix.eval.Coeval.to.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.eval.Coeval.to.F" class="extype">F</span>[<span name="monix.eval.Coeval.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Converts the source <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> into any <code>F[_]</code> that implements
<code>cats.effect.Sync</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Converts the source <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> into any <code>F[_]</code> that implements
<code>cats.effect.Sync</code>.</p><p>For example it can work with <code>cats.effect.IO</code>:</p><pre><span class="kw">import</span> cats._
<span class="kw">import</span> cats.effect._

<span class="kw">val</span> source = Coeval { <span class="num">1</span> + <span class="num">1</span> }

<span class="kw">val</span> asIO: IO[<span class="std">Int</span>]     = source.to[IO]
<span class="kw">val</span> asEval: Eval[<span class="std">Int</span>] = source.to[Eval]
<span class="kw">val</span> asTask: Task[<span class="std">Int</span>] = source.to[Task]</pre></div></div></li><li class="indented0 " name="monix.eval.Coeval#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a> → Function0 → AnyRef → Any</dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#toSync" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toSync[F[_]](implicitF:cats.effect.Sync[F]):F[A@scala.annotation.unchecked.uncheckedVariance]"></a><a id="toSync[F[_]](Sync[F]):F[A]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#toSync[F[_]](implicitF:cats.effect.Sync[F]):F[A@scala.annotation.unchecked.uncheckedVariance]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toSync</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.eval.Coeval.toSync.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.eval.Coeval.toSync.F" class="extype">F</span>[<span name="monix.eval.Coeval.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Converts the source to any value that implements <code>cats.effect.Sync</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Converts the source to any value that implements <code>cats.effect.Sync</code>.</p><p>Prefer to use <a href="#to[F[_]](implicitF:monix.eval.CoevalLift[F]):F[A@scala.annotation.unchecked.uncheckedVariance]" name="monix.eval.Coeval#to" id="monix.eval.Coeval#to" class="extmbr">to</a>, this method is provided in order to force
the usage of <code>cats.effect.Sync</code> instances (instead of <a href="CoevalLift.html" name="monix.eval.CoevalLift" id="monix.eval.CoevalLift" class="extype">CoevalLift</a>).
</p></div></div></li><li class="indented0 " name="monix.eval.Coeval#value" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="value():A"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#value():A" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">value</span><span class="params">()</span><span class="result">: <span name="monix.eval.Coeval.A" class="extype">A</span></span></span><p class="shortcomment cmt">Evaluates the underlying computation and returns the result.</p><div class="fullcomment"><div class="comment cmt"><p>Evaluates the underlying computation and returns the result.</p><p>NOTE: this can throw exceptions.</p><p>Alias for <a href="#apply():A" name="monix.eval.Coeval#apply" id="monix.eval.Coeval#apply" class="extmbr">apply</a>.</p><p><b>UNSAFE</b> — this operation can trigger the
        execution of side effects, which break referential
        transparency and is thus not a pure function.</p><p>        In FP code use with care, suspended in another <code>Coeval</code>
        or <a href="Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>, or at the edge of the FP
        program.</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#void" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="void:monix.eval.Coeval[Unit]"></a><a id="void:Coeval[Unit]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#void:monix.eval.Coeval[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">void</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Returns this coeval mapped to unit
</p></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="arg1">arg1: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#zip" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="zip[B](that:monix.eval.Coeval[B]):monix.eval.Coeval[(A,B)]"></a><a id="zip[B](Coeval[B]):Coeval[(A,B)]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#zip[B](that:monix.eval.Coeval[B]):monix.eval.Coeval[(A,B)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zip</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="that">that: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.zip.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[(<span name="monix.eval.Coeval.A" class="extype">A</span>, <span name="monix.eval.Coeval.zip.B" class="extype">B</span>)]</span></span><p class="shortcomment cmt">Zips the values of <code>this</code> and <code>that</code> coeval, and creates a new coeval
that will emit the tuple of their results.</p></li><li class="indented0 " name="monix.eval.Coeval#zipMap" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="zipMap[B,C](that:monix.eval.Coeval[B])(f:(A,B)=&gt;C):monix.eval.Coeval[C]"></a><a id="zipMap[B,C](Coeval[B])((A,B)=&gt;C):Coeval[C]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#zipMap[B,C](that:monix.eval.Coeval[B])(f:(A,B)=&gt;C):monix.eval.Coeval[C]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zipMap</span><span class="tparams">[<span name="B">B</span>, <span name="C">C</span>]</span><span class="params">(<span name="that">that: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.zipMap.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.eval.Coeval.A" class="extype">A</span>, <span name="monix.eval.Coeval.zipMap.B" class="extype">B</span>) =&gt; <span name="monix.eval.Coeval.zipMap.C" class="extype">C</span></span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.zipMap.C" class="extype">C</span>]</span></span><p class="shortcomment cmt">Zips the values of <code>this</code> and <code>that</code> and applies the given
mapping function on their results.</p></li></ol></div><div class="values members"><h3>Deprecated Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: ">finalize</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> <span class="name">@Deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#transform" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="transform[R](fa:A=&gt;R,fe:Throwable=&gt;R):monix.eval.Coeval[R]"></a><a id="transform[R]((A)=&gt;R,(Throwable)=&gt;R):Coeval[R]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#transform[R](fa:A=&gt;R,fe:Throwable=&gt;R):monix.eval.Coeval[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: (Since version 3.0.0-RC2) Please use Coeval.redeem">transform</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="fa">fa: (<span name="monix.eval.Coeval.A" class="extype">A</span>) =&gt; <span name="monix.eval.Coeval.transform.R" class="extype">R</span></span>, <span name="fe">fe: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <span name="monix.eval.Coeval.transform.R" class="extype">R</span></span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.transform.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Deprecated — use <a href="#redeem[B](recover:Throwable=&gt;B,map:A=&gt;B):monix.eval.Coeval[B]" name="monix.eval.Coeval#redeem" id="monix.eval.Coeval#redeem" class="extmbr">redeem</a> instead.</p><div class="fullcomment"><div class="comment cmt"><p>Deprecated — use <a href="#redeem[B](recover:Throwable=&gt;B,map:A=&gt;B):monix.eval.Coeval[B]" name="monix.eval.Coeval#redeem" id="monix.eval.Coeval#redeem" class="extmbr">redeem</a> instead.</p><p><a href="#redeem[B](recover:Throwable=&gt;B,map:A=&gt;B):monix.eval.Coeval[B]" name="monix.eval.Coeval#redeem" id="monix.eval.Coeval#redeem" class="extmbr">Coeval.redeem</a> is the same operation, but with a different name and the
function parameters in an inverted order, to make it consistent with <code>fold</code>
on <code>Either</code> and others (i.e. the function for error recovery is at the left).
</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 3.0.0-RC2)</i> Please use <code>Coeval.redeem</code></p></dd></dl></div></li><li class="indented0 " name="monix.eval.Coeval#transformWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="transformWith[R](fa:A=&gt;monix.eval.Coeval[R],fe:Throwable=&gt;monix.eval.Coeval[R]):monix.eval.Coeval[R]"></a><a id="transformWith[R]((A)=&gt;Coeval[R],(Throwable)=&gt;Coeval[R]):Coeval[R]"></a> <span class="permalink"><a href="../../monix/eval/Coeval.html#transformWith[R](fa:A=&gt;monix.eval.Coeval[R],fe:Throwable=&gt;monix.eval.Coeval[R]):monix.eval.Coeval[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: (Since version 3.0.0-RC2) Please use Coeval.redeemWith">transformWith</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="fa">fa: (<span name="monix.eval.Coeval.A" class="extype">A</span>) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.transformWith.R" class="extype">R</span>]</span>, <span name="fe">fe: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.transformWith.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>[<span name="monix.eval.Coeval.transformWith.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Deprecated — use <a href="#redeemWith[B](recover:Throwable=&gt;monix.eval.Coeval[B],bind:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#redeemWith" id="monix.eval.Coeval#redeemWith" class="extmbr">redeemWith</a> instead.</p><div class="fullcomment"><div class="comment cmt"><p>Deprecated — use <a href="#redeemWith[B](recover:Throwable=&gt;monix.eval.Coeval[B],bind:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#redeemWith" id="monix.eval.Coeval#redeemWith" class="extmbr">redeemWith</a> instead.</p><p><a href="#redeemWith[B](recover:Throwable=&gt;monix.eval.Coeval[B],bind:A=&gt;monix.eval.Coeval[B]):monix.eval.Coeval[B]" name="monix.eval.Coeval#redeemWith" id="monix.eval.Coeval#redeemWith" class="extmbr">Coeval.redeemWith</a> is the same operation, but with a different name and the
function parameters in an inverted order, to make it consistent with <code>fold</code>
on <code>Either</code> and others (i.e. the function for error recovery is at the left).
</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 3.0.0-RC2)</i> Please use <code>Coeval.redeemWith</code></p></dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="java.io.Serializable" class="parent"><h3>Inherited from <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></h3></div><div name="scala.Function0" class="parent"><h3>Inherited from () =&gt; <span name="monix.eval.Coeval.A" class="extype">A</span></h3></div><div name="scala.AnyRef" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.3/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
