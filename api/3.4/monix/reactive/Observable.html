<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Monix 3.4.0 - monix.reactive.Observable</title><meta content="Monix 3.4.0 - monix.reactive.Observable" name="description"/><meta content="Monix 3.4.0 monix.reactive.Observable" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../lib/jquery.min.js"></script><script type="text/javascript" src="../../lib/index.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript" src="../../lib/scheduler.js"></script><script type="text/javascript" src="../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../';</script></head><body><div id="search"><span id="doc-title">Monix<span id="doc-version">3.4.0</span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">root</span></a></span><p class="shortcomment cmt"><img src="https://monix.io/public/images/monix-logo.png" align="right" width="200" /></p><div class="fullcomment"><div class="comment cmt"><p><img src="https://monix.io/public/images/monix-logo.png" align="right" width="200" /></p><p>This is the API documentation for the <a href="https://monix.io" target="_blank">Monix</a> library.</p><h4>Package Overview</h4><p><b><a href="../execution/index.html" name="monix.execution" id="monix.execution" class="extype">monix.execution</a></b> exposes lower level primitives for dealing
with asynchronous execution:</p><ul><li><a href="../execution/atomic/index.html" name="monix.execution.atomic" id="monix.execution.atomic" class="extype">monix.execution.atomic</a> exposes the <code>Atomic</code> types, as alternative
   to <code>java.util.concurrent.atomic</code></li><li><a href="../execution/cancelables/index.html" name="monix.execution.cancelables" id="monix.execution.cancelables" class="extype">monix.execution.cancelables</a> contains several
   useful <a href="../execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a> implementations</li><li><a href="../execution/schedulers/index.html" name="monix.execution.schedulers" id="monix.execution.schedulers" class="extype">monix.execution.schedulers</a> contains several
   useful <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> implementations</li><li><a href="../execution/rstreams/index.html" name="monix.execution.rstreams" id="monix.execution.rstreams" class="extype">monix.execution.rstreams</a> contains helpers for dealing
   with the <a href="http://www.reactive-streams.org" target="_blank">Reactive Streams</a> specification</li><li><a href="../execution/misc/index.html" name="monix.execution.misc" id="monix.execution.misc" class="extype">monix.execution.misc</a> provides miscellaneous primitives
   useful for dealing with concurrency</li><li><a href="../execution/exceptions/index.html" name="monix.execution.exceptions" id="monix.execution.exceptions" class="extype">monix.execution.exceptions</a> groups some exceptions thrown by
   the implementation</li></ul><p><b><a href="../catnap/index.html" name="monix.catnap" id="monix.catnap" class="extype">monix.catnap</a></b> exposes pure abstractions built on top of
the <a href="https://typelevel.org/cats-effect/" target="_blank">Cats-Effect</a> type classes:</p><ul><li><a href="../catnap/cancelables/index.html" name="monix.catnap.cancelables" id="monix.catnap.cancelables" class="extype">monix.catnap.cancelables</a> exposes pure counterparts to the
   cancelable data types described in <a href="../execution/cancelables/index.html" name="monix.execution.cancelables" id="monix.execution.cancelables" class="extype">monix.execution.cancelables</a></li></ul><p><b><a href="../eval/index.html" name="monix.eval" id="monix.eval" class="extype">monix.eval</a></b> is for dealing with evaluation of results, thus exposing
<a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> and <a href="../eval/Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>.</p><p><b><a href="index.html" name="monix.reactive" id="monix.reactive" class="extype">monix.reactive</a></b> exposes the <code>Observable</code> pattern:</p><ul><li><a href="observables/index.html" name="monix.reactive.observables" id="monix.reactive.observables" class="extype">monix.reactive.observables</a> groups reusable <code>Observable</code> implementations</li><li><a href="observers/index.html" name="monix.reactive.observers" id="monix.reactive.observers" class="extype">monix.reactive.observers</a> groups reusable <a href="Observer.html" name="monix.reactive.Observer" id="monix.reactive.Observer" class="extype">Observer</a>
   implementations</li><li><a href="subjects/index.html" name="monix.reactive.subjects" id="monix.reactive.subjects" class="extype">monix.reactive.subjects</a> exposes <a href="subjects/Subject.html" name="monix.reactive.subjects.Subject" id="monix.reactive.subjects.Subject" class="extype">Subject</a>
   and <a href="subjects/ConcurrentSubject.html" name="monix.reactive.subjects.ConcurrentSubject" id="monix.reactive.subjects.ConcurrentSubject" class="extype">ConcurrentSubject</a>,
   which are implementations of hot observables that function both as input and output</li></ul><p><b><a href="../tail/index.html" name="monix.tail" id="monix.tail" class="extype">monix.tail</a></b> exposes <a href="../tail/Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a> for purely functional pull based streaming:</p><ul><li><a href="../tail/batches/index.html" name="monix.tail.batches" id="monix.tail.batches" class="extype">monix.tail.batches</a> describes <code>Batch</code> and <code>BatchCursor</code>, the
   alternatives to Scala's <code>Iterable</code> and <code>Iterator</code> respectively that
   we are using within Iterant's encoding</li></ul><p>You can control evaluation with type you choose - be it <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>, <a href="../eval/Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>, <a href="https://typelevel.org/cats-effect/api/cats/effect/IO.html" target="_blank">cats.effect.IO</a>
or your own as long as you provide correct <a href="https://typelevel.org/cats-effect/typeclasses/" target="_blank">cats-effect</a> or <a href="https://typelevel.org/cats/typeclasses.html" target="_blank">cats</a> typeclass instance.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.monix" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="monix"></a><a id="monix:monix"></a> <span class="permalink"><a href="../../monix/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">monix</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="monix.reactive" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="reactive"></a><a id="reactive:reactive"></a> <span class="permalink"><a href="../../monix/reactive/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title=""><span class="name">reactive</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="monix" id="monix" class="extype">monix</a></dd></dl></div></li><li class="indented3 " name="monix.reactive.compression" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="compression"></a><a id="compression:compression"></a> <span class="permalink"><a href="../../monix/reactive/compression/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="compression/index.html" title=""><span class="name">compression</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="monix.reactive" id="monix.reactive" class="extype">reactive</a></dd></dl></div></li><li class="indented3 " name="monix.reactive.instances" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="instances"></a><a id="instances:instances"></a> <span class="permalink"><a href="../../monix/reactive/instances/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="instances/index.html" title=""><span class="name">instances</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="monix.reactive" id="monix.reactive" class="extype">reactive</a></dd></dl></div></li><li class="indented3 " name="monix.reactive.observables" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="observables"></a><a id="observables:observables"></a> <span class="permalink"><a href="../../monix/reactive/observables/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="observables/index.html" title=""><span class="name">observables</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="monix.reactive" id="monix.reactive" class="extype">reactive</a></dd></dl></div></li><li class="indented3 " name="monix.reactive.observers" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="observers"></a><a id="observers:observers"></a> <span class="permalink"><a href="../../monix/reactive/observers/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="observers/index.html" title=""><span class="name">observers</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="monix.reactive" id="monix.reactive" class="extype">reactive</a></dd></dl></div></li><li class="indented3 " name="monix.reactive.subjects" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="subjects"></a><a id="subjects:subjects"></a> <span class="permalink"><a href="../../monix/reactive/subjects/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="subjects/index.html" title=""><span class="name">subjects</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="monix.reactive" id="monix.reactive" class="extype">reactive</a></dd></dl></div></li><li class="current-entities indented2"><a href="Consumer$.html" title="The companion object of Consumer, defines consumer builders." class="object"></a> <a href="Consumer.html" title="The Consumer is a specification of how to consume an observable." class="class"></a><a href="Consumer.html" title="The Consumer is a specification of how to consume an observable.">Consumer</a></li><li class="current-entities indented2"><a href="MulticastStrategy$.html" title="The MulticastStrategy enumerated." class="object"></a> <a href="MulticastStrategy.html" title="The MulticastStrategy specifies the strategy for building data-sources that are shared between multiple subscribers." class="class"></a><a href="MulticastStrategy.html" title="The MulticastStrategy specifies the strategy for building data-sources that are shared between multiple subscribers.">MulticastStrategy</a></li><li class="current-entities indented2"><a href="Notification$.html" title="" class="object"></a> <a href="Notification.html" title="Used by Observable.materialize." class="class"></a><a href="Notification.html" title="Used by Observable.materialize.">Notification</a></li><li class="current-entities indented2"><a href="Observable$.html" title="Observable builders." class="object"></a> <a href="" title="The Observable type that implements the Reactive Pattern." class="class"></a><a href="" title="The Observable type that implements the Reactive Pattern.">Observable</a></li><li class="current-entities indented2"><a href="ObservableLike$.html" title="" class="object"></a> <a href="ObservableLike.html" title="A lawless type class that provides conversions to Observable." class="trait"></a><a href="ObservableLike.html" title="A lawless type class that provides conversions to Observable.">ObservableLike</a></li><li class="current-entities indented2"><a href="Observer$.html" title="" class="object"></a> <a href="Observer.html" title="The Observer from the Rx pattern is the trio of callbacks that get subscribed to an Observable for receiving events." class="trait"></a><a href="Observer.html" title="The Observer from the Rx pattern is the trio of callbacks that get subscribed to an Observable for receiving events.">Observer</a></li><li class="current-entities indented2"><a href="OverflowStrategy$.html" title="" class="object"></a> <a href="OverflowStrategy.html" title="Represents the buffering overflowStrategy chosen for actions that need buffering, instructing the pipeline what to do when the buffer is full." class="class"></a><a href="OverflowStrategy.html" title="Represents the buffering overflowStrategy chosen for actions that need buffering, instructing the pipeline what to do when the buffer is full.">OverflowStrategy</a></li><li class="current-entities indented2"><a href="Pipe$.html" title="" class="object"></a> <a href="Pipe.html" title="Represents a factory for an input/output channel for broadcasting input to multiple subscribers." class="class"></a><a href="Pipe.html" title="Represents a factory for an input/output channel for broadcasting input to multiple subscribers.">Pipe</a></li></ul></div></div><div id="content"><body class="class type"><div id="definition"><a href="Observable$.html" title="See companion object"><div class="big-circle class-companion-object">c</div></a><p id="owner"><a href="../index.html" name="monix" id="monix" class="extype">monix</a>.<a href="index.html" name="monix.reactive" id="monix.reactive" class="extype">reactive</a></p><h1><a href="Observable$.html" title="See companion object">Observable</a><span class="permalink"><a href="../../monix/reactive/Observable.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"><div>Companion <a href="Observable$.html" title="See companion object">object Observable</a></div></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><span class="name">Observable</span><span class="tparams">[<span name="A">+A</span>]</span><span class="result"> extends <span name="scala.Serializable" class="extype">Serializable</span></span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>The <code>Observable</code> type that implements the Reactive Pattern.</p><p>Provides methods of subscribing to the Observable and operators
for combining observable sources, filtering, modifying,
throttling, buffering, error handling and others.</p><p>See the available documentation at: <a href="https://monix.io" target="_blank">https://monix.io</a></p></div><dl class="attributes block"><dt>Self Type</dt><dd><a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</dd><dt>Source</dt><dd><a href="https://github.com/monix/monix/tree/346352380c4b2b12a66f83cf7ca416dbebde357b/monix-reactive/shared/src/main/scala/monix/reactive/Observable.scala" target="_blank">Observable.scala</a></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a>, <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>, <a href="https://www.scala-lang.org/api/2.13.3/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></div></div></div><div class="toggleContainer"><div class="toggle block"><span>Known Subclasses</span><div class="subClasses hiddenContent"><a href="observables/CachedObservable.html" name="monix.reactive.observables.CachedObservable" id="monix.reactive.observables.CachedObservable" class="extype">CachedObservable</a>, <a href="observables/ChainedObservable.html" name="monix.reactive.observables.ChainedObservable" id="monix.reactive.observables.ChainedObservable" class="extype">ChainedObservable</a>, <a href="observables/ConnectableObservable.html" name="monix.reactive.observables.ConnectableObservable" id="monix.reactive.observables.ConnectableObservable" class="extype">ConnectableObservable</a>, <a href="observables/GroupedObservable.html" name="monix.reactive.observables.GroupedObservable" id="monix.reactive.observables.GroupedObservable" class="extype">GroupedObservable</a>, <a href="observables/RefCountObservable.html" name="monix.reactive.observables.RefCountObservable" id="monix.reactive.observables.RefCountObservable" class="extype">RefCountObservable</a>, <a href="subjects/AsyncSubject.html" name="monix.reactive.subjects.AsyncSubject" id="monix.reactive.subjects.AsyncSubject" class="extype">AsyncSubject</a>, <a href="subjects/BehaviorSubject.html" name="monix.reactive.subjects.BehaviorSubject" id="monix.reactive.subjects.BehaviorSubject" class="extype">BehaviorSubject</a>, <a href="subjects/ConcurrentSubject.html" name="monix.reactive.subjects.ConcurrentSubject" id="monix.reactive.subjects.ConcurrentSubject" class="extype">ConcurrentSubject</a>, <a href="subjects/PublishSubject.html" name="monix.reactive.subjects.PublishSubject" id="monix.reactive.subjects.PublishSubject" class="extype">PublishSubject</a>, <a href="subjects/PublishToOneSubject.html" name="monix.reactive.subjects.PublishToOneSubject" id="monix.reactive.subjects.PublishToOneSubject" class="extype">PublishToOneSubject</a>, <a href="subjects/ReplaySubject.html" name="monix.reactive.subjects.ReplaySubject" id="monix.reactive.subjects.ReplaySubject" class="extype">ReplaySubject</a>, <a href="subjects/Subject.html" name="monix.reactive.subjects.Subject" id="monix.reactive.subjects.Subject" class="extype">Subject</a>, <a href="subjects/Var.html" name="monix.reactive.subjects.Var" id="monix.reactive.subjects.Var" class="extype">Var</a></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="monix.reactive.Observable"><span>Observable</span></li><li class="in" name="java.io.Serializable"><span>Serializable</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="constructors" class="members"><h3>Instance Constructors</h3><ol><li class="indented0 " name="monix.reactive.Observable#&lt;init&gt;" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="&lt;init&gt;():monix.reactive.Observable[A]"></a><a id="&lt;init&gt;:Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#&lt;init&gt;():monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">new</span></span> <span class="symbol"><span class="name">Observable</span><span class="params">()</span></span></li></ol></div><div class="values members"><h3>Abstract Value Members</h3><ol><li class="indented0 " name="monix.reactive.Observable#unsafeSubscribeFn" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="unsafeSubscribeFn(subscriber:monix.reactive.observers.Subscriber[A]):monix.execution.Cancelable"></a><a id="unsafeSubscribeFn(Subscriber[A]):Cancelable"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#unsafeSubscribeFn(subscriber:monix.reactive.observers.Subscriber[A]):monix.execution.Cancelable" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">unsafeSubscribeFn</span><span class="params">(<span name="subscriber">subscriber: <a href="observers/Subscriber.html" name="monix.reactive.observers.Subscriber" id="monix.reactive.observers.Subscriber" class="extype">Subscriber</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="../execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a></span></span><p class="shortcomment cmt">Characteristic function for an <code>Observable</code> instance, that creates
the subscription and that eventually starts the streaming of
events to the given <a href="Observer.html" name="monix.reactive.Observer" id="monix.reactive.Observer" class="extype">Observer</a>, to be provided by observable
implementations.</p><div class="fullcomment"><div class="comment cmt"><p>Characteristic function for an <code>Observable</code> instance, that creates
the subscription and that eventually starts the streaming of
events to the given <a href="Observer.html" name="monix.reactive.Observer" id="monix.reactive.Observer" class="extype">Observer</a>, to be provided by observable
implementations.</p><p><b>UNSAFE PROTOCOL:</b> This function is
        "unsafe" to call because it does not protect the calls to
        the given <a href="Observer.html" name="monix.reactive.Observer" id="monix.reactive.Observer" class="extype">Observer</a> implementation and thus knowledge
        of the protocol is needed.</p><p>        Prefer normal
        <a href="#subscribe(subscriber:monix.reactive.observers.Subscriber[A]):monix.execution.Cancelable" name="monix.reactive.Observable#subscribe" id="monix.reactive.Observable#subscribe" class="extmbr">subscribe</a>
        when consuming a stream, these unsafe subscription methods
        being useful when building operators and for testing
        purposes.</p><p>        Normal <code>subscribe</code> protects users in these ways:</p><ul><li>it does a best effort attempt to catch and report
           exceptions that violate the protocol</li><li>the final <code>onComplete</code> or <code>onError</code> message is
           guaranteed to be signaled after the completion
           of the <a href="../execution/Ack.html" name="monix.execution.Ack" id="monix.execution.Ack" class="extype">acknowledgement</a>
           received from the last <code>onNext</code>; the internal
           protocol doesn't require back-pressuring of
           this last message for performance reasons</li></ul><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeProtocol.html" name="monix.execution.annotations.UnsafeProtocol" id="monix.execution.annotations.UnsafeProtocol" class="extype">UnsafeProtocol</a></span><span class="args">()</span> <span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li></ol></div><div class="values members"><h3>Concrete Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##:Int"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html###:Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#++" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="++[B&gt;:A](other:=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="++[B&gt;:A](=&gt;Observable[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#++[B&gt;:A](other:=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $plus$plus">++</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="other">other: =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.++.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.++.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Concatenates the source with another observable.</p><div class="fullcomment"><div class="comment cmt"><p>Concatenates the source with another observable.</p><p>Ordering of subscription is preserved, so the second observable
starts only after the source observable is completed
successfully with an <code>onComplete</code>. On the other hand, the second
observable is never subscribed if the source completes with an
error.</p><h4> Visual Example </h4><p><pre>
streamA: a1 -- -- a2 -- -- a3 -- a4 -- --
streamB: b1 -- -- b2 -- b3 -- -- -- -- b4

result: a1, a2, a3, a4, b1, b2, b3, b4
</pre>
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#+:" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="+:[B&gt;:A](elem:B):monix.reactive.Observable[B]"></a><a id="+:[B&gt;:A](B):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#+:[B&gt;:A](elem:B):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $plus$colon">+:</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="elem">elem: <span name="monix.reactive.Observable.+:.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.+:.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Alias for <a href="#prepend[B&gt;:A](elem:B):monix.reactive.Observable[B]" name="monix.reactive.Observable#prepend" id="monix.reactive.Observable#prepend" class="extmbr">prepend</a>.</p></li><li class="indented0 " name="monix.reactive.Observable#:+" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id=":+[B&gt;:A](elem:B):monix.reactive.Observable[B]"></a><a id=":+[B&gt;:A](B):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#:+[B&gt;:A](elem:B):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $colon$plus">:+</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="elem">elem: <span name="monix.reactive.Observable.:+.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.:+.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Alias for <a href="#append[B&gt;:A](elem:B):monix.reactive.Observable[B]" name="monix.reactive.Observable#append" id="monix.reactive.Observable#append" class="extmbr">append</a>.</p></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#ambWith" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="ambWith[B&gt;:A](other:monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="ambWith[B&gt;:A](Observable[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#ambWith[B&gt;:A](other:monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ambWith</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="other">other: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.ambWith.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.ambWith.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Given the source observable and another <code>Observable</code>, emits all of
the items from the first of these Observables to emit an item
and cancel the other.</p></li><li class="indented0 " name="monix.reactive.Observable#append" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="append[B&gt;:A](elem:B):monix.reactive.Observable[B]"></a><a id="append[B&gt;:A](B):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#append[B&gt;:A](elem:B):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">append</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="elem">elem: <span name="monix.reactive.Observable.append.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.append.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new Observable that emits the events of the source and
then it also emits the given element (appended to the stream).</p></li><li class="indented0 " name="monix.reactive.Observable#appendAll" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="appendAll[B&gt;:A](other:monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="appendAll[B&gt;:A](Observable[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#appendAll[B&gt;:A](other:monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">appendAll</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="other">other: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.appendAll.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.appendAll.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">A strict variant of <a href="#++[B&gt;:A](other:=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#++" id="monix.reactive.Observable#++" class="extmbr">++</a>.</p></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#asyncBoundary" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asyncBoundary[B&gt;:A](overflowStrategy:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]"></a><a id="asyncBoundary[B&gt;:A](OverflowStrategy[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#asyncBoundary[B&gt;:A](overflowStrategy:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asyncBoundary</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="overflowStrategy">overflowStrategy: <a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a>[<span name="monix.reactive.Observable.asyncBoundary.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.asyncBoundary.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Forces a buffered asynchronous boundary.</p><div class="fullcomment"><div class="comment cmt"><p>Forces a buffered asynchronous boundary.
Asynchronous boundary refers to an independent processing
of an upstream and a downstream - producer does not have to wait
for consumer to acknowledge a new event.</p><p>Internally it wraps the observer implementation given to
<code>onSubscribe</code> into a
<a href="observers/BufferedSubscriber.html" name="monix.reactive.observers.BufferedSubscriber" id="monix.reactive.observers.BufferedSubscriber" class="extype">BufferedSubscriber</a>.</p><p>Normally Monix's implementation guarantees that events are
not emitted concurrently, and that the publisher MUST NOT
emit the next event without acknowledgement from the
consumer that it may proceed, however for badly behaved
publishers, this wrapper provides the guarantee that the
downstream <a href="Observer.html" name="monix.reactive.Observer" id="monix.reactive.Observer" class="extype">Observer</a> given in
<code>subscribe</code> will not receive concurrent events.</p><p>WARNING: if the buffer created by this operator is
unbounded, it can blow up the process if the data source
is pushing events faster than what the observer can
consume, as it introduces an asynchronous boundary that
eliminates the back-pressure requirements of the data
source. Unbounded is the default
<a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">overflowStrategy</a>, see
<a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a> for
options.</p><p>Usage:</p><pre><span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> scala.concurrent.duration._

Observable(<span class="lit">"A"</span>, <span class="lit">"B"</span>, <span class="lit">"C"</span>, <span class="lit">"D"</span>)
  .mapEval(i <span class="kw">=&gt;</span> Task { println(s<span class="lit">"1: Processing $$i"</span>); i ++ i })
  .asyncBoundary(OverflowStrategy.Unbounded)
  .mapEval(i <span class="kw">=&gt;</span> Task { println(s<span class="lit">"2: Processing $$i"</span>) }.delayExecution(<span class="num">100.</span>millis))

<span class="cmt">// Without asyncBoundary it would process A, AA, B, BB, ...</span>
<span class="cmt">// 1: Processing A</span>
<span class="cmt">// 1: Processing B</span>
<span class="cmt">// 1: Processing C</span>
<span class="cmt">// 1: Processing D</span>
<span class="cmt">// 2: Processing AA</span>
<span class="cmt">// 2: Processing BB</span>
<span class="cmt">// 2: Processing CC</span>
<span class="cmt">// 2: Processing DD</span></pre></div><dl class="paramcmts block"><dt class="param">overflowStrategy</dt><dd class="cmt"><p>- the <a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">overflow strategy</a>
        used for buffering, which specifies what to do in case
        we're dealing with a slow consumer - should an unbounded
        buffer be used, should back-pressure be applied, should
        the pipeline drop newer or older events, should it drop
        the whole buffer? See <a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a> for more
        details.</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#behavior" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="behavior[B&gt;:A](initialValue:B)(implicits:monix.execution.Scheduler):monix.reactive.observables.ConnectableObservable[B]"></a><a id="behavior[B&gt;:A](B)(Scheduler):ConnectableObservable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#behavior[B&gt;:A](initialValue:B)(implicits:monix.execution.Scheduler):monix.reactive.observables.ConnectableObservable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">behavior</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="initialValue">initialValue: <span name="monix.reactive.Observable.behavior.B" class="extype">B</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="observables/ConnectableObservable.html" name="monix.reactive.observables.ConnectableObservable" id="monix.reactive.observables.ConnectableObservable" class="extype">ConnectableObservable</a>[<span name="monix.reactive.Observable.behavior.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Converts this observable into a multicast observable, useful for
turning a cold observable into a hot one (i.e.</p><div class="fullcomment"><div class="comment cmt"><p>Converts this observable into a multicast observable, useful for
turning a cold observable into a hot one (i.e. whose source is
shared by all observers). The underlying subject used is a
<a href="subjects/BehaviorSubject.html" name="monix.reactive.subjects.BehaviorSubject" id="monix.reactive.subjects.BehaviorSubject" class="extype">BehaviorSubject</a>.</p><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#bracket" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bracket[B](use:A=&gt;monix.reactive.Observable[B])(release:A=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[B]"></a><a id="bracket[B]((A)=&gt;Observable[B])((A)=&gt;Task[Unit]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#bracket[B](use:A=&gt;monix.reactive.Observable[B])(release:A=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bracket</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="use">use: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.bracket.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="release">release: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.bracket.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Implementation of <code>bracket</code> from <code>cats.effect.Bracket</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implementation of <code>bracket</code> from <code>cats.effect.Bracket</code>.</p><p>See <a href="https://typelevel.org/cats-effect/typeclasses/bracket.html" target="_blank">documentation</a>.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#bracketCase" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bracketCase[B](use:A=&gt;monix.reactive.Observable[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[B]"></a><a id="bracketCase[B]((A)=&gt;Observable[B])((A,ExitCase[Throwable])=&gt;Task[Unit]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#bracketCase[B](use:A=&gt;monix.reactive.Observable[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bracketCase</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="use">use: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.bracketCase.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="release">release: (<span name="monix.reactive.Observable.A" class="extype">A</span>, <span name="cats.effect.ExitCase" class="extype">ExitCase</span>[<span name="scala.Throwable" class="extype">Throwable</span>]) =&gt; <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.bracketCase.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Implementation of <code>bracketCase</code> from <code>cats.effect.Bracket</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Implementation of <code>bracketCase</code> from <code>cats.effect.Bracket</code>.</p><p>See <a href="https://typelevel.org/cats-effect/typeclasses/bracket.html" target="_blank">documentation</a>.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#bracketCaseF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bracketCaseF[F[_],B](use:A=&gt;monix.reactive.Observable[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[B]"></a><a id="bracketCaseF[F[_],B]((A)=&gt;Observable[B])((A,ExitCase[Throwable])=&gt;F[Unit])(TaskLike[F]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#bracketCaseF[F[_],B](use:A=&gt;monix.reactive.Observable[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bracketCaseF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="B">B</span>]</span><span class="params">(<span name="use">use: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.bracketCaseF.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="release">release: (<span name="monix.reactive.Observable.A" class="extype">A</span>, <span name="cats.effect.ExitCase" class="extype">ExitCase</span>[<span name="scala.Throwable" class="extype">Throwable</span>]) =&gt; <span name="monix.reactive.Observable.bracketCaseF.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.bracketCaseF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.bracketCaseF.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Version of <a href="#bracketCase[B](use:A=&gt;monix.reactive.Observable[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[B]" name="monix.reactive.Observable#bracketCase" id="monix.reactive.Observable#bracketCase" class="extmbr">bracketCase</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#bracketCase[B](use:A=&gt;monix.reactive.Observable[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[B]" name="monix.reactive.Observable#bracketCase" id="monix.reactive.Observable#bracketCase" class="extmbr">bracketCase</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><p>So in <code>release</code> you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...
</li></ul></div></div></li><li class="indented0 " name="monix.reactive.Observable#bracketF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bracketF[F[_],B](use:A=&gt;monix.reactive.Observable[B])(release:A=&gt;F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[B]"></a><a id="bracketF[F[_],B]((A)=&gt;Observable[B])((A)=&gt;F[Unit])(TaskLike[F]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#bracketF[F[_],B](use:A=&gt;monix.reactive.Observable[B])(release:A=&gt;F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bracketF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="B">B</span>]</span><span class="params">(<span name="use">use: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.bracketF.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="release">release: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.bracketF.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.bracketF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.bracketF.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Version of <a href="#bracket[B](use:A=&gt;monix.reactive.Observable[B])(release:A=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[B]" name="monix.reactive.Observable#bracket" id="monix.reactive.Observable#bracket" class="extmbr">bracket</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#bracket[B](use:A=&gt;monix.reactive.Observable[B])(release:A=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[B]" name="monix.reactive.Observable#bracket" id="monix.reactive.Observable#bracket" class="extmbr">bracket</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><p>So in <code>release</code> you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...
</li></ul></div></div></li><li class="indented0 " name="monix.reactive.Observable#bufferIntrospective" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bufferIntrospective(maxSize:Int):monix.reactive.Observable[List[A]]"></a><a id="bufferIntrospective(Int):Observable[List[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#bufferIntrospective(maxSize:Int):monix.reactive.Observable[List[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bufferIntrospective</span><span class="params">(<span name="maxSize">maxSize: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="scala.List" class="extype">List</span>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Buffers signals while busy, after which it emits the
buffered events as a single bundle.</p><div class="fullcomment"><div class="comment cmt"><p>Buffers signals while busy, after which it emits the
buffered events as a single bundle.</p><p>This operator starts applying back-pressure when the
underlying buffer's size is exceeded.</p><p>Usage:</p><pre><span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> scala.concurrent.duration._

Observable.range(<span class="num">1</span>, <span class="num">6</span>)
  .doOnNext(l <span class="kw">=&gt;</span> Task(println(s<span class="lit">"Started $$l"</span>)))
  .bufferIntrospective(maxSize = <span class="num">2</span>)
  .doOnNext(l <span class="kw">=&gt;</span> Task(println(s<span class="lit">"Emitted batch $$l"</span>)))
  .mapEval(l <span class="kw">=&gt;</span> Task(println(s<span class="lit">"Processed batch $$l"</span>)).delayExecution(<span class="num">500.</span>millis))

<span class="cmt">// Started 1</span>
<span class="cmt">// Emitted batch List(1)</span>
<span class="cmt">// Started 2</span>
<span class="cmt">// Started 3</span>
<span class="cmt">// Processed batch List(1)</span>
<span class="cmt">// Emitted batch List(2, 3)</span>
<span class="cmt">// Started 4</span>
<span class="cmt">// Started 5</span>
<span class="cmt">// Processed batch List(2, 3)</span>
<span class="cmt">// Emitted batch List(4, 5)</span>
<span class="cmt">// Processed batch List(4, 5)</span></pre></div></div></li><li class="indented0 " name="monix.reactive.Observable#bufferSliding" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bufferSliding(count:Int,skip:Int):monix.reactive.Observable[Seq[A]]"></a><a id="bufferSliding(Int,Int):Observable[Seq[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#bufferSliding(count:Int,skip:Int):monix.reactive.Observable[Seq[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bufferSliding</span><span class="params">(<span name="count">count: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="skip">skip: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="scala.Seq" class="extype">Seq</span>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Returns an observable that emits buffers of items it collects from
the source observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an observable that emits buffers of items it collects from
the source observable. The resulting observable emits buffers
every <code>skip</code> items, each containing <code>count</code> items.</p><p>If the source observable completes, then the current buffer gets
signaled downstream. If the source triggers an error then the
current buffer is being dropped and the error gets propagated
immediately.</p><p>For <code>count</code> and <code>skip</code> there are 3 possibilities:</p><ol class="decimal"><li>in case <code>skip == count</code>, then there are no items dropped and
    no overlap, the call being equivalent to <code>bufferTumbling(count)</code></li><li>in case <code>skip &lt; count</code>, then overlap between buffers
    happens, with the number of elements being repeated being
    <code>count - skip</code></li><li>in case <code>skip &gt; count</code>, then <code>skip - count</code> elements start
    getting dropped between windows</li></ol><p>Usage:</p><pre><span class="cmt">// Emits [2, 3], [5, 6]</span>
Observable.range(<span class="num">2</span>, <span class="num">7</span>)
  .bufferSliding(count = <span class="num">2</span>, skip = <span class="num">3</span>)</pre><pre><span class="cmt">// Emits [2, 3, 4], [4, 5, 6]</span>
Observable.range(<span class="num">2</span>, <span class="num">7</span>)
  .bufferSliding(count = <span class="num">3</span>, skip = <span class="num">2</span>)</pre></div><dl class="paramcmts block"><dt class="param">count</dt><dd class="cmt"><p>the maximum size of each buffer before it should
       be emitted</p></dd><dt class="param">skip</dt><dd class="cmt"><p>how many items emitted by the source observable should
       be skipped before starting a new buffer. Note that when
       skip and count are equal, this is the same operation as
       <code>bufferTumbling(count)</code></p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#bufferTimed" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bufferTimed(timespan:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[Seq[A]]"></a><a id="bufferTimed(FiniteDuration):Observable[Seq[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#bufferTimed(timespan:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[Seq[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bufferTimed</span><span class="params">(<span name="timespan">timespan: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="scala.Seq" class="extype">Seq</span>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Periodically gather items emitted by an observable into bundles
and emit these bundles rather than emitting the items one at a
time.</p><div class="fullcomment"><div class="comment cmt"><p>Periodically gather items emitted by an observable into bundles
and emit these bundles rather than emitting the items one at a
time.</p><p>This version of <code>buffer</code> emits a new bundle of items
periodically, every timespan amount of time, containing all
items emitted by the source Observable since the previous bundle
emission.</p><p>If the source observable completes, then the current buffer gets
signaled downstream. If the source triggers an error then the
current buffer is being dropped and the error gets propagated
immediately.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>the interval of time at which it should emit
       the buffered bundle</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#bufferTimedAndCounted" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bufferTimedAndCounted(timespan:scala.concurrent.duration.FiniteDuration,maxCount:Int):monix.reactive.Observable[Seq[A]]"></a><a id="bufferTimedAndCounted(FiniteDuration,Int):Observable[Seq[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#bufferTimedAndCounted(timespan:scala.concurrent.duration.FiniteDuration,maxCount:Int):monix.reactive.Observable[Seq[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bufferTimedAndCounted</span><span class="params">(<span name="timespan">timespan: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>, <span name="maxCount">maxCount: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="scala.Seq" class="extype">Seq</span>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Periodically gather items emitted by an observable into bundles
and emit these bundles rather than emitting the items one at a
time.</p><div class="fullcomment"><div class="comment cmt"><p>Periodically gather items emitted by an observable into bundles
and emit these bundles rather than emitting the items one at a
time.</p><p>The resulting observable emits connected, non-overlapping
buffers, each of a fixed duration specified by the <code>timespan</code>
argument or a maximum size specified by the <code>maxCount</code> argument
(whichever is reached first).</p><p>If the source observable completes, then the current buffer gets
signaled downstream. If the source triggers an error then the
current buffer is being dropped and the error gets propagated
immediately.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>the interval of time at which it should emit
       the buffered bundle</p></dd><dt class="param">maxCount</dt><dd class="cmt"><p>is the maximum bundle size, after which the
       buffered bundle gets forcefully emitted</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#bufferTimedWithPressure" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bufferTimedWithPressure[AA&gt;:A](period:scala.concurrent.duration.FiniteDuration,maxSize:Int,sizeOf:AA=&gt;Int):monix.reactive.Observable[Seq[AA]]"></a><a id="bufferTimedWithPressure[AA&gt;:A](FiniteDuration,Int,(AA)=&gt;Int):Observable[Seq[AA]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#bufferTimedWithPressure[AA&gt;:A](period:scala.concurrent.duration.FiniteDuration,maxSize:Int,sizeOf:AA=&gt;Int):monix.reactive.Observable[Seq[AA]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bufferTimedWithPressure</span><span class="tparams">[<span name="AA">AA &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="period">period: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>, <span name="maxSize">maxSize: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="sizeOf">sizeOf: (<span name="monix.reactive.Observable.bufferTimedWithPressure.AA" class="extype">AA</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a> = <span class="symbol">(_: AA) =&gt; 1</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="scala.Seq" class="extype">Seq</span>[<span name="monix.reactive.Observable.bufferTimedWithPressure.AA" class="extype">AA</span>]]</span></span><p class="shortcomment cmt">Periodically gather items emitted by an observable into bundles
and emit these bundles rather than emitting the items one at a
time.</p><div class="fullcomment"><div class="comment cmt"><p>Periodically gather items emitted by an observable into bundles
and emit these bundles rather than emitting the items one at a
time. Back-pressure the source when the buffer is full.</p><p>The resulting observable emits connected, non-overlapping
buffers, each of a fixed duration specified by the <code>period</code>
argument.</p><p>The bundles are emitted at a fixed rate. If the source is
silent, then the resulting observable will start emitting empty
sequences.</p><p>If the source observable completes, then the current buffer gets
signaled downstream. If the source triggers an error then the
current buffer is being dropped and the error gets propagated
immediately.</p><p>A <code>maxSize</code> argument is specified as the capacity of the
bundle. In case the source is too fast and <code>maxSize</code> is reached,
then the source will be back-pressured.</p><p>A <code>sizeOf</code> argument is specified as the weight each element
represents in the bundle. Defaults to count each element as
weighting 1.</p><p>The difference with <a href="#bufferTimedAndCounted(timespan:scala.concurrent.duration.FiniteDuration,maxCount:Int):monix.reactive.Observable[Seq[A]]" name="monix.reactive.Observable#bufferTimedAndCounted" id="monix.reactive.Observable#bufferTimedAndCounted" class="extmbr">bufferTimedAndCounted</a> is that
<a href="#bufferTimedWithPressure[AA&gt;:A](period:scala.concurrent.duration.FiniteDuration,maxSize:Int,sizeOf:AA=&gt;Int):monix.reactive.Observable[Seq[AA]]" name="monix.reactive.Observable#bufferTimedWithPressure" id="monix.reactive.Observable#bufferTimedWithPressure" class="extmbr">bufferTimedWithPressure</a> applies back-pressure from the time
when the buffer is full until the buffer is emitted, whereas
<a href="#bufferTimedAndCounted(timespan:scala.concurrent.duration.FiniteDuration,maxCount:Int):monix.reactive.Observable[Seq[A]]" name="monix.reactive.Observable#bufferTimedAndCounted" id="monix.reactive.Observable#bufferTimedAndCounted" class="extmbr">bufferTimedAndCounted</a> will forcefully emit the buffer when
it's full.
</p></div><dl class="paramcmts block"><dt class="param">period</dt><dd class="cmt"><p>the interval of time at which it should emit
       the buffered bundle</p></dd><dt class="param">maxSize</dt><dd class="cmt"><p>is the maximum buffer size, after which the
       source starts being back-pressured</p></dd><dt class="param">sizeOf</dt><dd class="cmt"><p>is the function to compute the weight of each
       element in the buffer</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#bufferTumbling" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bufferTumbling(count:Int):monix.reactive.Observable[Seq[A]]"></a><a id="bufferTumbling(Int):Observable[Seq[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#bufferTumbling(count:Int):monix.reactive.Observable[Seq[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bufferTumbling</span><span class="params">(<span name="count">count: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="scala.Seq" class="extype">Seq</span>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Periodically gather items emitted by an observable into bundles
and emit these bundles rather than emitting the items one at a
time.</p><div class="fullcomment"><div class="comment cmt"><p>Periodically gather items emitted by an observable into bundles
and emit these bundles rather than emitting the items one at a
time. This version of <code>buffer</code> is emitting items once the
internal buffer has reached the given count.</p><p>If the source observable completes, then the current buffer gets
signaled downstream. If the source triggers an error then the
current buffer is being dropped and the error gets propagated
immediately.</p><p>Usage:</p><pre><span class="cmt">// Emits [2, 3], [4, 5], [6]</span>
Observable.range(<span class="num">2</span>, <span class="num">7</span>)
  .bufferTumbling(count = <span class="num">2</span>)</pre></div><dl class="paramcmts block"><dt class="param">count</dt><dd class="cmt"><p>the maximum size of each buffer before it should
       be emitted</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#bufferWhile" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bufferWhile(p:A=&gt;Boolean):monix.reactive.Observable[Seq[A]]"></a><a id="bufferWhile((A)=&gt;Boolean):Observable[Seq[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#bufferWhile(p:A=&gt;Boolean):monix.reactive.Observable[Seq[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bufferWhile</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="scala.Seq" class="extype">Seq</span>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Buffers elements while predicate returns true,
after which it emits the buffered events as a single bundle
and creates a new buffer.</p><div class="fullcomment"><div class="comment cmt"><p>Buffers elements while predicate returns true,
after which it emits the buffered events as a single bundle
and creates a new buffer.</p><p>Usage:</p><pre><span class="kw">import</span> monix.eval.Task

Observable(<span class="num">1</span>, <span class="num">1</span>, <span class="num">1</span>, <span class="num">2</span>, <span class="num">2</span>, <span class="num">1</span>, <span class="num">3</span>)
  .bufferWhile(_ == <span class="num">1</span>)
  .doOnNext(l <span class="kw">=&gt;</span> Task(println(s<span class="lit">"Emitted batch $$l"</span>)))

<span class="cmt">// Emitted batch List(1, 1, 1)</span>
<span class="cmt">// Emitted batch List(2)</span>
<span class="cmt">// Emitted batch List(2, 1)</span>
<span class="cmt">// Emitted batch List(3)</span></pre></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#bufferWhileInclusive(p:A=&gt;Boolean):monix.reactive.Observable[Seq[A]]" name="monix.reactive.Observable#bufferWhileInclusive" id="monix.reactive.Observable#bufferWhileInclusive" class="extmbr">bufferWhileInclusive</a> for a similar operator that includes
     the value that caused <code>predicate</code> to return <code>false</code></p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#bufferWhileInclusive" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bufferWhileInclusive(p:A=&gt;Boolean):monix.reactive.Observable[Seq[A]]"></a><a id="bufferWhileInclusive((A)=&gt;Boolean):Observable[Seq[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#bufferWhileInclusive(p:A=&gt;Boolean):monix.reactive.Observable[Seq[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bufferWhileInclusive</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="scala.Seq" class="extype">Seq</span>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Buffers elements while predicate returns true,
after which it emits the buffered events as a single bundle,
including the value that caused <code>predicate</code> to return <code>false</code>
and creates a new buffer.</p><div class="fullcomment"><div class="comment cmt"><p>Buffers elements while predicate returns true,
after which it emits the buffered events as a single bundle,
including the value that caused <code>predicate</code> to return <code>false</code>
and creates a new buffer.</p><p>Usage:</p><pre><span class="kw">import</span> monix.eval.Task

Observable(<span class="num">1</span>, <span class="num">1</span>, <span class="num">1</span>, <span class="num">2</span>, <span class="num">2</span>, <span class="num">1</span>, <span class="num">3</span>)
  .bufferWhileInclusive(_ == <span class="num">1</span>)
  .doOnNext(l <span class="kw">=&gt;</span> Task(println(s<span class="lit">"Emitted batch $$l"</span>)))

<span class="cmt">// Emitted batch List(1, 1, 1, 2)</span>
<span class="cmt">// Emitted batch List(2)</span>
<span class="cmt">// Emitted batch List(1, 3)</span></pre></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#bufferWhile(p:A=&gt;Boolean):monix.reactive.Observable[Seq[A]]" name="monix.reactive.Observable#bufferWhile" id="monix.reactive.Observable#bufferWhile" class="extmbr">bufferWhile</a> for a similar operator that does not include
     the value that caused <code>predicate</code> to return <code>false</code></p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#bufferWithSelector" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bufferWithSelector[S](selector:monix.reactive.Observable[S],maxSize:Int):monix.reactive.Observable[Seq[A]]"></a><a id="bufferWithSelector[S](Observable[S],Int):Observable[Seq[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#bufferWithSelector[S](selector:monix.reactive.Observable[S],maxSize:Int):monix.reactive.Observable[Seq[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bufferWithSelector</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="selector">selector: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.bufferWithSelector.S" class="extype">S</span>]</span>, <span name="maxSize">maxSize: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="scala.Seq" class="extype">Seq</span>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Periodically gather items emitted by
        an observable into bundles and emit these bundles rather than
        emitting the items one at a time, whenever the <code>selector</code>
        observable signals an event.</p><div class="fullcomment"><div class="comment cmt"><p>Periodically gather items emitted by
        an observable into bundles and emit these bundles rather than
        emitting the items one at a time, whenever the <code>selector</code>
        observable signals an event.</p><p>        The resulting observable collects the elements of the source
        in a buffer and emits that buffer whenever the given <code>selector</code>
        observable emits an <code>onNext</code> event, when the buffer is emitted
        as a sequence downstream and then reset. Thus the resulting
        observable emits connected, non-overlapping bundles triggered
        by the given <code>selector</code>.</p><p>        If <code>selector</code> terminates with an <code>onComplete</code>, then the resulting
        observable also terminates normally. If <code>selector</code> terminates with
        an <code>onError</code>, then the resulting observable also terminates with an
        error.</p><p>        If the source observable completes, then the current buffer gets
        signaled downstream. If the source triggers an error then the
        current buffer is being dropped and the error gets propagated
        immediately.</p><p>A <code>maxSize</code> argument is specified as the capacity of the
bundle. In case the source is too fast and <code>maxSize</code> is reached,
then the source will be back-pressured.
</p></div><dl class="paramcmts block"><dt class="param">selector</dt><dd class="cmt"><p>is the observable that triggers the signaling of the
       current buffer</p></dd><dt class="param">maxSize</dt><dd class="cmt"><p>is the maximum bundle size, after which the
       source starts being back-pressured</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#bufferWithSelector" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bufferWithSelector[S](selector:monix.reactive.Observable[S]):monix.reactive.Observable[Seq[A]]"></a><a id="bufferWithSelector[S](Observable[S]):Observable[Seq[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#bufferWithSelector[S](selector:monix.reactive.Observable[S]):monix.reactive.Observable[Seq[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bufferWithSelector</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="selector">selector: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.bufferWithSelector.S" class="extype">S</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="scala.Seq" class="extype">Seq</span>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Periodically gather items emitted by
        an observable into bundles and emit these bundles rather than
        emitting the items one at a time, whenever the <code>selector</code>
        observable signals an event.</p><div class="fullcomment"><div class="comment cmt"><p>Periodically gather items emitted by
        an observable into bundles and emit these bundles rather than
        emitting the items one at a time, whenever the <code>selector</code>
        observable signals an event.</p><p>        The resulting observable collects the elements of the source
        in a buffer and emits that buffer whenever the given <code>selector</code>
        observable emits an <code>onNext</code> event, when the buffer is emitted
        as a sequence downstream and then reset. Thus the resulting
        observable emits connected, non-overlapping bundles triggered
        by the given <code>selector</code>.</p><p>        If <code>selector</code> terminates with an <code>onComplete</code>, then the resulting
        observable also terminates normally. If <code>selector</code> terminates with
        an <code>onError</code>, then the resulting observable also terminates with an
        error.</p><p>        If the source observable completes, then the current buffer gets
        signaled downstream. If the source triggers an error then the
        current buffer is being dropped and the error gets propagated
        immediately.</p></div><dl class="paramcmts block"><dt class="param">selector</dt><dd class="cmt"><p>is the observable that triggers the
       signaling of the current buffer</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#cache" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="cache(maxCapacity:Int):monix.reactive.Observable[A]"></a><a id="cache(Int):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#cache(maxCapacity:Int):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">cache</span><span class="params">(<span name="maxCapacity">maxCapacity: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Caches the emissions from the source Observable and replays them
in order to any subsequent Subscribers.</p><div class="fullcomment"><div class="comment cmt"><p>Caches the emissions from the source Observable and replays them
in order to any subsequent Subscribers. This operator has
similar behavior to <a href="#replay(implicits:monix.execution.Scheduler):monix.reactive.observables.ConnectableObservable[A]" name="monix.reactive.Observable#replay" id="monix.reactive.Observable#replay" class="extmbr">replay</a>
except that this auto-subscribes to the source Observable rather
than returning a
<a href="observables/ConnectableObservable.html" name="monix.reactive.observables.ConnectableObservable" id="monix.reactive.observables.ConnectableObservable" class="extype">ConnectableObservable</a>
for which you must call
<a href="observables/ConnectableObservable.html#connect():monix.execution.Cancelable" name="monix.reactive.observables.ConnectableObservable#connect" id="monix.reactive.observables.ConnectableObservable#connect" class="extmbr">connect</a>
to activate the subscription.</p><p>When you call cache, it does not yet subscribe to the source
Observable and so does not yet begin caching items. This only
happens when the first Subscriber calls the resulting
Observable's <code>subscribe</code> method.</p><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="paramcmts block"><dt class="param">maxCapacity</dt><dd class="cmt"><p>is the maximum buffer size after which old events
       start being dropped (according to what happens when using
       <a href="subjects/ReplaySubject$.html#createLimited[A](capacity:Int,initial:Seq[A]):monix.reactive.subjects.ReplaySubject[A]" name="monix.reactive.subjects.ReplaySubject#createLimited" id="monix.reactive.subjects.ReplaySubject#createLimited" class="extmbr">ReplaySubject.createLimited</a>)</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that, when first subscribed to, caches all of its
        items and notifications for the benefit of subsequent subscribers</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#cache" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="cache:monix.reactive.Observable[A]"></a><a id="cache:Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#cache:monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">cache</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Caches the emissions from the source Observable and replays them
in order to any subsequent Subscribers.</p><div class="fullcomment"><div class="comment cmt"><p>Caches the emissions from the source Observable and replays them
in order to any subsequent Subscribers. This operator has
similar behavior to <a href="#replay(implicits:monix.execution.Scheduler):monix.reactive.observables.ConnectableObservable[A]" name="monix.reactive.Observable#replay" id="monix.reactive.Observable#replay" class="extmbr">replay</a>
except that this auto-subscribes to the source Observable rather
than returning a
<a href="observables/ConnectableObservable.html" name="monix.reactive.observables.ConnectableObservable" id="monix.reactive.observables.ConnectableObservable" class="extype">ConnectableObservable</a>
for which you must call
<a href="observables/ConnectableObservable.html#connect():monix.execution.Cancelable" name="monix.reactive.observables.ConnectableObservable#connect" id="monix.reactive.observables.ConnectableObservable#connect" class="extmbr">connect</a>
to activate the subscription.</p><p>When you call cache, it does not yet subscribe to the source
Observable and so does not yet begin caching items. This only
happens when the first Subscriber calls the resulting
Observable's <code>subscribe</code> method.</p><p>Note: You sacrifice the ability to cancel the origin when you
use the cache operator so be careful not to use this on
Observables that emit an infinite or very large number of items
that will use up memory.</p><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an Observable that, when first subscribed to, caches all of its
        items and notifications for the benefit of subsequent subscribers</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object"></a><a id="clone():AnyRef"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#collect" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="collect[B](pf:PartialFunction[A,B]):monix.reactive.Observable[B]"></a><a id="collect[B](PartialFunction[A,B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#collect[B](pf:PartialFunction[A,B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">collect</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="pf">pf: <a href="https://www.scala-lang.org/api/2.13.3/scala/PartialFunction.html#scala.PartialFunction" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>, <span name="monix.reactive.Observable.collect.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.collect.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Applies the given partial function to the source
for each element for which the given partial function is defined.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the given partial function to the source
for each element for which the given partial function is defined.
</p></div><dl class="paramcmts block"><dt class="param">pf</dt><dd class="cmt"><p>the function that filters and maps the source</p></dd><dt>returns</dt><dd class="cmt"><p>an observable that emits the transformed items by the
        given partial function</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#collectWhile" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="collectWhile[B](pf:PartialFunction[A,B]):monix.reactive.Observable[B]"></a><a id="collectWhile[B](PartialFunction[A,B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#collectWhile[B](pf:PartialFunction[A,B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">collectWhile</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="pf">pf: <a href="https://www.scala-lang.org/api/2.13.3/scala/PartialFunction.html#scala.PartialFunction" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>, <span name="monix.reactive.Observable.collectWhile.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.collectWhile.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Takes longest prefix of elements that satisfy the given partial function
and returns a new Observable that emits those elements.</p><div class="fullcomment"><div class="comment cmt"><p>Takes longest prefix of elements that satisfy the given partial function
and returns a new Observable that emits those elements.
</p></div><dl class="paramcmts block"><dt class="param">pf</dt><dd class="cmt"><p>the function that filters and maps the source</p></dd><dt>returns</dt><dd class="cmt"><p>an observable that emits the transformed items by the
        given partial function until it is contained in the function's domain</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#combineLatest" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="combineLatest[B](other:monix.reactive.Observable[B]):monix.reactive.Observable[(A,B)]"></a><a id="combineLatest[B](Observable[B]):Observable[(A,B)]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#combineLatest[B](other:monix.reactive.Observable[B]):monix.reactive.Observable[(A,B)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">combineLatest</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="other">other: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.combineLatest.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[(<span name="monix.reactive.Observable.A" class="extype">A</span>, <span name="monix.reactive.Observable.combineLatest.B" class="extype">B</span>)]</span></span><p class="shortcomment cmt">Creates a new observable from the source and another given
observable, by emitting elements combined in pairs.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new observable from the source and another given
observable, by emitting elements combined in pairs.</p><p>It emits an item whenever any of the source Observables emits an
item (so long as each of the source Observables has emitted at
least one item).</p><h4> Visual Example </h4><p><pre>
stream1: 1 - - 2 - - 3 - 4 - -
stream2: 1 - - 2 - 3 - - - - 4

result: (1, 1), (2, 2), (2, 3), (3, 3), (4, 3), (4, 4)
</pre></p><p>See <a href="#zip[B](other:monix.reactive.Observable[B]):monix.reactive.Observable[(A,B)]" name="monix.reactive.Observable#zip" id="monix.reactive.Observable#zip" class="extmbr">zip</a> for an alternative that pairs the items in strict sequence.
</p></div><dl class="paramcmts block"><dt class="param">other</dt><dd class="cmt"><p>is an observable that gets paired with the source</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#combineLatestMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="combineLatestMap[B,R](other:monix.reactive.Observable[B])(f:(A,B)=&gt;R):monix.reactive.Observable[R]"></a><a id="combineLatestMap[B,R](Observable[B])((A,B)=&gt;R):Observable[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#combineLatestMap[B,R](other:monix.reactive.Observable[B])(f:(A,B)=&gt;R):monix.reactive.Observable[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">combineLatestMap</span><span class="tparams">[<span name="B">B</span>, <span name="R">R</span>]</span><span class="params">(<span name="other">other: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.combineLatestMap.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>, <span name="monix.reactive.Observable.combineLatestMap.B" class="extype">B</span>) =&gt; <span name="monix.reactive.Observable.combineLatestMap.R" class="extype">R</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.combineLatestMap.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Creates a new observable from the source and another given
observable, by emitting elements combined in pairs.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new observable from the source and another given
observable, by emitting elements combined in pairs.</p><p>It emits an item whenever any of the source Observables emits an
item (so long as each of the source Observables has emitted at
least one item).</p><h4> Visual Example </h4><p><pre>
stream1: 1 - - 2 - - 3 - 4 - -
stream2: 1 - - 2 - 3 - - - - 4

result: (1, 1), (2, 2), (2, 3), (3, 3), (4, 3), (4, 4)
</pre></p><p>See <a href="#zipMap[B,R](other:monix.reactive.Observable[B])(f:(A,B)=&gt;R):monix.reactive.Observable[R]" name="monix.reactive.Observable#zipMap" id="monix.reactive.Observable#zipMap" class="extmbr">zipMap</a> for an alternative that pairs the items
in strict sequence.
</p></div><dl class="paramcmts block"><dt class="param">other</dt><dd class="cmt"><p>is an observable that gets paired with the source</p></dd><dt class="param">f</dt><dd class="cmt"><p>is a mapping function over the generated pairs</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#completed" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="completed:monix.reactive.Observable[Nothing]"></a><a id="completed:Observable[Nothing]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#completed:monix.reactive.Observable[Nothing]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">completed</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Nothing.html#scala.Nothing" name="scala.Nothing" id="scala.Nothing" class="extype">Nothing</a>]</span></span><p class="shortcomment cmt">Ignores all items emitted by the source Observable and only calls
onCompleted or onError.</p><div class="fullcomment"><div class="comment cmt"><p>Ignores all items emitted by the source Observable and only calls
onCompleted or onError.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an empty Observable that only calls onCompleted or onError,
        based on which one is called by the source Observable</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#completedF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="completedF[F[_]](implicitF:monix.eval.TaskLift[F]):F[Unit]"></a><a id="completedF[F[_]](TaskLift[F]):F[Unit]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#completedF[F[_]](implicitF:monix.eval.TaskLift[F]):F[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">completedF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="../eval/TaskLift.html" name="monix.eval.TaskLift" id="monix.eval.TaskLift" class="extype">TaskLift</a>[<span name="monix.reactive.Observable.completedF.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.reactive.Observable.completedF.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Polymorphic version of <a href="#completedL:monix.eval.Task[Unit]" name="monix.reactive.Observable#completedL" id="monix.reactive.Observable#completedL" class="extmbr">completedL</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLift.html" name="monix.eval.TaskLift" id="monix.eval.TaskLift" class="extype">monix.eval.TaskLift</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Polymorphic version of <a href="#completedL:monix.eval.Task[Unit]" name="monix.reactive.Observable#completedL" id="monix.reactive.Observable#completedL" class="extmbr">completedL</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLift.html" name="monix.eval.TaskLift" id="monix.eval.TaskLift" class="extype">monix.eval.TaskLift</a>
conversions.</p><p>So you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...
</li></ul></div></div></li><li class="indented0 " name="monix.reactive.Observable#completedL" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="completedL:monix.eval.Task[Unit]"></a><a id="completedL:Task[Unit]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#completedL:monix.eval.Task[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">completedL</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Creates a new <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> that will consume the
source observable and upon completion of the source it will
complete with <code>Unit</code>.</p></li><li class="indented0 " name="monix.reactive.Observable#concat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="concat[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="concat[B](&lt;:&lt;[A,Observable[B]]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#concat[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">concat</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.3/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>, <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.concat.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.concat.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Concatenates the sequence of observables
        emitted by the source into one observable, without any
        transformation.</p><div class="fullcomment"><div class="comment cmt"><p>Concatenates the sequence of observables
        emitted by the source into one observable, without any
        transformation.</p><p>        You can combine the items emitted by multiple observables
        so that they act like a single sequence by using this
        operator.</p><p>        This operation is the "monadic bind", implementing the
        <code>flatMap</code> operation of <a href="http://typelevel.org/cats/api/cats/Monad.html" name="cats.Monad" id="cats.Monad" class="extype">cats.Monad</a>.</p><h4>Concat vs Merge</h4><p>        The difference between the <a href="#concat[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#concat" id="monix.reactive.Observable#concat" class="extmbr">concat</a>
        operation and <a href="#merge[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B],implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#merge" id="monix.reactive.Observable#merge" class="extmbr">merge</a> is that <code>concat</code>
        cares about the ordering of sequences (e.g. all items
        emitted by the first observable in the sequence will come
        before the elements emitted by the second observable),
        whereas <code>merge</code> doesn't care about that (elements get
        emitted as they come). Because of back-pressure applied to
        observables, <code>concat</code> is safe to use in all contexts,
        whereas <code>merge</code> requires buffering. Or in other words
        <code>concat</code> has deterministic, lawful behavior (being the
        "monadic bind"), whereas <code>merge</code> has non-deterministic
        behavior.</p><h4>Equivalence with concatMap</h4><p>The <code>concat</code> operation is basically <code>concatMap</code> with the
identity function, as you can count on this equivalence:</p><p><code>stream.concat &lt;-&gt; stream.concatMap(x =&gt; x)</code></p><h4> Visual Example </h4><p><pre>
streamA: a1 -- -- a2 -- -- a3 -- a4 -- --
streamB: b1 -- -- b2 -- b3 -- -- -- -- b4

result: a1, a2, a3, a4, b1, b2, b3, b4
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an observable that emits the merged events of all
        streams created by the source</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#concatDelayErrors" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="concatDelayErrors[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="concatDelayErrors[B](&lt;:&lt;[A,Observable[B]]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#concatDelayErrors[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">concatDelayErrors</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.3/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>, <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.concatDelayErrors.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.concatDelayErrors.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Version of <a href="#concat[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#concat" id="monix.reactive.Observable#concat" class="extmbr">concat</a> that delays errors emitted by child
observables until the stream completes.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#concat[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#concat" id="monix.reactive.Observable#concat" class="extmbr">concat</a> that delays errors emitted by child
observables until the stream completes.</p><h4>Delaying Errors</h4><p>        This version is reserving <code>onError</code> notifications until
        all of the observables complete and only then passing the
        issued errors(s) downstream. Note that the streamed error is a
        <a href="../execution/exceptions/CompositeException.html" name="monix.execution.exceptions.CompositeException" id="monix.execution.exceptions.CompositeException" class="extype">CompositeException</a>,
        since multiple errors from multiple streams can happen.</p><h4>Example</h4><pre><span class="kw">val</span> dummy1 = <span class="kw">new</span> RuntimeException(<span class="lit">"dummy1"</span>)
<span class="kw">val</span> dummy2 = <span class="kw">new</span> RuntimeException(<span class="lit">"dummy2"</span>)

<span class="kw">val</span> stream = Observable(
  Observable(<span class="num">1</span>).endWithError(dummy1),
  Observable.raiseError(dummy2),
  Observable(<span class="num">2</span>, <span class="num">3</span>)
)

<span class="kw">val</span> concatenated =
  stream.concatDelayErrors</pre><p>The resulting stream in this example emits <code>1, 2, 3</code> in order
and then completes with a <code>CompositeException</code> of both <code>dummy1</code>
and <code>dummy2</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an observable that emits the merged events of all
        streams created by the source</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#concatMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="concatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="concatMap[B]((A)=&gt;Observable[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#concatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">concatMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.concatMap.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.concatMap.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Applies a function that you supply to each item emitted by the
source observable, where that function returns observables, and
then concatenating those resulting sequences and emitting the
results of this concatenation.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a function that you supply to each item emitted by the
source observable, where that function returns observables, and
then concatenating those resulting sequences and emitting the
results of this concatenation.</p><p>This implements the lawful "monadic bind", the <code>flatMap</code>
operation of <a href="http://typelevel.org/cats/api/cats/Monad.html" name="cats.Monad" id="cats.Monad" class="extype">cats.Monad</a>.</p><h4>Example</h4><pre>Observable(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>).concatMap { x <span class="kw">=&gt;</span>
  <span class="kw">for</span> {
    _ <span class="kw">&lt;-</span> Observable.eval(println(s<span class="lit">"Processing $$x"</span>))
    x <span class="kw">&lt;-</span> Observable(x, x)
  } <span class="kw">yield</span> x
}</pre><h4>Concat vs Merge</h4><p>        The difference between the <a href="#concat[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#concat" id="monix.reactive.Observable#concat" class="extmbr">concat</a>
        operation and <a href="#merge[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B],implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#merge" id="monix.reactive.Observable#merge" class="extmbr">merge</a> is that <code>concat</code>
        cares about the ordering of sequences (e.g. all items
        emitted by the first observable in the sequence will come
        before the elements emitted by the second observable),
        whereas <code>merge</code> doesn't care about that (elements get
        emitted as they come). Because of back-pressure applied to
        observables, <code>concat</code> is safe to use in all contexts,
        whereas <code>merge</code> requires buffering. Or in other words
        <code>concat</code> has deterministic, lawful behavior (being the
        "monadic bind"), whereas <code>merge</code> has non-deterministic
        behavior.</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is a generator for the streams being concatenated</p></dd><dt>returns</dt><dd class="cmt"><p>an observable that emits the merged events of all
        streams created by the source</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#concatMapDelayErrors" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="concatMapDelayErrors[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="concatMapDelayErrors[B]((A)=&gt;Observable[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#concatMapDelayErrors[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">concatMapDelayErrors</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.concatMapDelayErrors.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.concatMapDelayErrors.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Applies a function that you supply to each item emitted by the
source observable, where that function returns sequences
and then concatenating those resulting sequences and emitting the
results of this concatenation.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a function that you supply to each item emitted by the
source observable, where that function returns sequences
and then concatenating those resulting sequences and emitting the
results of this concatenation.</p><h4>Delaying Errors</h4><p>        This version is reserving <code>onError</code> notifications until
        all of the observables complete and only then passing the
        issued errors(s) downstream. Note that the streamed error is a
        <a href="../execution/exceptions/CompositeException.html" name="monix.execution.exceptions.CompositeException" id="monix.execution.exceptions.CompositeException" class="extype">CompositeException</a>,
        since multiple errors from multiple streams can happen.</p><h4>Example</h4><pre><span class="kw">val</span> dummy1 = <span class="kw">new</span> RuntimeException(<span class="lit">"dummy1"</span>)
<span class="kw">val</span> dummy2 = <span class="kw">new</span> RuntimeException(<span class="lit">"dummy2"</span>)

Observable(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>).concatMapDelayErrors {
  <span class="kw">case</span> <span class="num">1</span> <span class="kw">=&gt;</span> Observable(<span class="num">1</span>).endWithError(dummy1)
  <span class="kw">case</span> <span class="num">2</span> <span class="kw">=&gt;</span> Observable.raiseError(dummy2)
  <span class="kw">case</span> x <span class="kw">=&gt;</span> Observable(x, x)
}</pre><p>The resulting stream in this example emits <code>1, 3, 3</code> in order
and then completes with a <code>CompositeException</code> of both <code>dummy1</code>
and <code>dummy2</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is a generator for the streams being concatenated</p></dd><dt>returns</dt><dd class="cmt"><p>an observable that emits the merged events of all
        streams created by the source</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#concatMapIterable" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="concatMapIterable[B](f:A=&gt;scala.collection.immutable.Iterable[B]):monix.reactive.Observable[B]"></a><a id="concatMapIterable[B]((A)=&gt;Iterable[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#concatMapIterable[B](f:A=&gt;scala.collection.immutable.Iterable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">concatMapIterable</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/collection/immutable/Iterable.html#scala.collection.immutable.Iterable" name="scala.collection.immutable.Iterable" id="scala.collection.immutable.Iterable" class="extype">Iterable</a>[<span name="monix.reactive.Observable.concatMapIterable.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.concatMapIterable.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Applies a function that you supply to each item emitted by the
source observable, where that function returns a sequence of elements, and
then concatenating those resulting sequences and emitting the
results of this concatenation.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a function that you supply to each item emitted by the
source observable, where that function returns a sequence of elements, and
then concatenating those resulting sequences and emitting the
results of this concatenation.</p><h4>Example</h4><pre>Observable(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>).concatMapIterable( x <span class="kw">=&gt;</span> <span class="std">List</span>(x, x * <span class="num">10</span>, x * <span class="num">100</span>))</pre><h4> Visual Example </h4><p><pre>
stream: 1 -- -- 2 -- -- 3 -- --
result: 1, 10, 100, 2, 20, 200, 3, 30, 300
</pre>
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is a generator for the sequences being concatenated</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#consumeWith" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="consumeWith[R](f:monix.reactive.Consumer[A,R]):monix.eval.Task[R]"></a><a id="consumeWith[R](Consumer[A,R]):Task[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#consumeWith[R](f:monix.reactive.Consumer[A,R]):monix.eval.Task[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">consumeWith</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="f">f: <a href="Consumer.html" name="monix.reactive.Consumer" id="monix.reactive.Consumer" class="extype">Consumer</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>, <span name="monix.reactive.Observable.consumeWith.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="monix.reactive.Observable.consumeWith.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">On execution, consumes the source observable
with the given <a href="Consumer.html" name="monix.reactive.Consumer" id="monix.reactive.Consumer" class="extype">Consumer</a>, effectively transforming the
source observable into a <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>.</p></li><li class="indented0 " name="monix.reactive.Observable#consumeWithF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="consumeWithF[F[_],R](f:monix.reactive.Consumer[A,R])(implicitF:monix.eval.TaskLift[F]):F[R]"></a><a id="consumeWithF[F[_],R](Consumer[A,R])(TaskLift[F]):F[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#consumeWithF[F[_],R](f:monix.reactive.Consumer[A,R])(implicitF:monix.eval.TaskLift[F]):F[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">consumeWithF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="R">R</span>]</span><span class="params">(<span name="f">f: <a href="Consumer.html" name="monix.reactive.Consumer" id="monix.reactive.Consumer" class="extype">Consumer</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>, <span name="monix.reactive.Observable.consumeWithF.R" class="extype">R</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="../eval/TaskLift.html" name="monix.eval.TaskLift" id="monix.eval.TaskLift" class="extype">TaskLift</a>[<span name="monix.reactive.Observable.consumeWithF.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.reactive.Observable.consumeWithF.F" class="extype">F</span>[<span name="monix.reactive.Observable.consumeWithF.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Polymorphic version <a href="#consumeWith[R](f:monix.reactive.Consumer[A,R]):monix.eval.Task[R]" name="monix.reactive.Observable#consumeWith" id="monix.reactive.Observable#consumeWith" class="extmbr">consumeWith</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLift.html" name="monix.eval.TaskLift" id="monix.eval.TaskLift" class="extype">monix.eval.TaskLift</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Polymorphic version <a href="#consumeWith[R](f:monix.reactive.Consumer[A,R]):monix.eval.Task[R]" name="monix.reactive.Observable#consumeWith" id="monix.reactive.Observable#consumeWith" class="extmbr">consumeWith</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLift.html" name="monix.eval.TaskLift" id="monix.eval.TaskLift" class="extype">monix.eval.TaskLift</a>
conversions.</p><p>So you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...
</li></ul></div></div></li><li class="indented0 " name="monix.reactive.Observable#count" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="count:monix.reactive.Observable[Long]"></a><a id="count:Observable[Long]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#count:monix.reactive.Observable[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">count</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Creates a new Observable that emits the total number of <code>onNext</code>
events that were emitted by the source.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new Observable that emits the total number of <code>onNext</code>
events that were emitted by the source.</p><p>Note that this Observable emits only one item after the source
is complete.  And in case the source emits an error, then only
that error will be emitted.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#countL" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="countL:monix.eval.Task[Long]"></a><a id="countL:Task[Long]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#countL:monix.eval.Task[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">countL</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Creates a task that emits the total number of <code>onNext</code>
events that were emitted by the source.</p></li><li class="indented0 " name="monix.reactive.Observable#debounce" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="debounce(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]"></a><a id="debounce(FiniteDuration):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#debounce(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">debounce</span><span class="params">(<span name="timeout">timeout: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Only emit an item from an observable if a particular timespan has
passed without it emitting another item.</p><div class="fullcomment"><div class="comment cmt"><p>Only emit an item from an observable if a particular timespan has
passed without it emitting another item.</p><p>Note: If the source observable keeps emitting items more
frequently than the length of the time window, then no items will
be emitted by the resulting observable.</p><p>Usage:</p><pre><span class="kw">import</span> scala.concurrent.duration._

(Observable(<span class="lit">"M"</span>, <span class="lit">"O"</span>, <span class="lit">"N"</span>, <span class="lit">"I"</span>, <span class="lit">"X"</span>) ++ Observable.never)
  .delayOnNext(<span class="num">100.</span>millis)
  .scan(<span class="lit">""</span>)(_ ++ _)
  .debounce(<span class="num">200.</span>millis)
  .dump(<span class="lit">"O"</span>)

<span class="cmt">// Output:</span>
<span class="cmt">// 0: O --&gt; MONIX</span></pre></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>the length of the window of time that must pass after
       the emission of an item from the source observable in
       which that observable emits no items in order for the
       item to be emitted by the resulting observable</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#echoOnce(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#echoOnce" id="monix.reactive.Observable#echoOnce" class="extmbr">echoOnce</a> for a similar operator that also mirrors
    the source observable</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#debounceRepeated" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="debounceRepeated(period:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]"></a><a id="debounceRepeated(FiniteDuration):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#debounceRepeated(period:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">debounceRepeated</span><span class="params">(<span name="period">period: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Emits the last item from the source Observable if a particular
timespan has passed without it emitting another item, and keeps
emitting that item at regular intervals until the source breaks
the silence.</p><div class="fullcomment"><div class="comment cmt"><p>Emits the last item from the source Observable if a particular
timespan has passed without it emitting another item, and keeps
emitting that item at regular intervals until the source breaks
the silence.</p><p>So compared to regular <a href="#debounceTo[B](timeout:scala.concurrent.duration.FiniteDuration,f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#debounceTo" id="monix.reactive.Observable#debounceTo" class="extmbr">debounceTo</a> this version
keeps emitting the last item of the source.</p><p>Note: If the source Observable keeps emitting items more
frequently than the length of the time window then no items will
be emitted by the resulting Observable.
</p></div><dl class="paramcmts block"><dt class="param">period</dt><dd class="cmt"><p>the length of the window of time that must pass after
       the emission of an item from the source Observable in
       which that Observable emits no items in order for the
       item to be emitted by the resulting Observable at regular
       intervals, also determined by period</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#echoRepeated(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#echoRepeated" id="monix.reactive.Observable#echoRepeated" class="extmbr">echoRepeated</a> for a similar operator that also mirrors
    the source observable</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#debounceTo" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="debounceTo[B](timeout:scala.concurrent.duration.FiniteDuration,f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="debounceTo[B](FiniteDuration,(A)=&gt;Observable[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#debounceTo[B](timeout:scala.concurrent.duration.FiniteDuration,f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">debounceTo</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="timeout">timeout: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>, <span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.debounceTo.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.debounceTo.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Doesn't emit anything until a <code>timeout</code> period passes without the
source emitting anything.</p><div class="fullcomment"><div class="comment cmt"><p>Doesn't emit anything until a <code>timeout</code> period passes without the
source emitting anything. When that timeout happens, we
subscribe to the observable generated by the given function, an
observable that will keep emitting until the source will break
the silence by emitting another event.</p><p>Note: If the source observable keeps emitting items more
frequently than the length of the time window, then no items
will be emitted by the resulting Observable.
</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>the length of the window of time that must pass after
       the emission of an item from the source Observable in
       which that Observable emits no items in order for the
       item to be emitted by the resulting Observable</p></dd><dt class="param">f</dt><dd class="cmt"><p>is a function that receives the last element generated
       by the source, generating an observable to be subscribed
       when the source is timing out</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#defaultIfEmpty" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="defaultIfEmpty[B&gt;:A](default:=&gt;B):monix.reactive.Observable[B]"></a><a id="defaultIfEmpty[B&gt;:A](=&gt;B):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#defaultIfEmpty[B&gt;:A](default:=&gt;B):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">defaultIfEmpty</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="default">default: =&gt; <span name="monix.reactive.Observable.defaultIfEmpty.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.defaultIfEmpty.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Emit items from the source, or emit a default item if
the source completes after emitting no items.</p></li><li class="indented0 " name="monix.reactive.Observable#delayExecution" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="delayExecution(timespan:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]"></a><a id="delayExecution(FiniteDuration):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#delayExecution(timespan:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">delayExecution</span><span class="params">(<span name="timespan">timespan: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Hold an Observer's subscription request for a specified amount of
time before passing it on to the source Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Hold an Observer's subscription request for a specified amount of
time before passing it on to the source Observable.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>is the time to wait before the subscription
       is being initiated.</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#delayExecutionWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="delayExecutionWith[B](trigger:monix.reactive.Observable[B]):monix.reactive.Observable[A]"></a><a id="delayExecutionWith[B](Observable[B]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#delayExecutionWith[B](trigger:monix.reactive.Observable[B]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">delayExecutionWith</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="trigger">trigger: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.delayExecutionWith.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Hold an Observer's subscription request until the given <code>trigger</code>
observable either emits an item or completes, before passing it
on to the source Observable.</p><div class="fullcomment"><div class="comment cmt"><p>Hold an Observer's subscription request until the given <code>trigger</code>
observable either emits an item or completes, before passing it
on to the source Observable.</p><p>If the given <code>trigger</code> completes in error, then the subscription is
terminated with <code>onError</code>.
</p></div><dl class="paramcmts block"><dt class="param">trigger</dt><dd class="cmt"><p>the observable that must either emit an item or
       complete in order for the source to be subscribed.</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#delayExecutionWithF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="delayExecutionWithF[F[_],B](trigger:F[B])(implicitF:monix.reactive.ObservableLike[F]):monix.reactive.Observable[A]"></a><a id="delayExecutionWithF[F[_],B](F[B])(ObservableLike[F]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#delayExecutionWithF[F[_],B](trigger:F[B])(implicitF:monix.reactive.ObservableLike[F]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">delayExecutionWithF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="B">B</span>]</span><span class="params">(<span name="trigger">trigger: <span name="monix.reactive.Observable.delayExecutionWithF.F" class="extype">F</span>[<span name="monix.reactive.Observable.delayExecutionWithF.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="ObservableLike.html" name="monix.reactive.ObservableLike" id="monix.reactive.ObservableLike" class="extype">ObservableLike</a>[<span name="monix.reactive.Observable.delayExecutionWithF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Version of <a href="#delayExecutionWith[B](trigger:monix.reactive.Observable[B]):monix.reactive.Observable[A]" name="monix.reactive.Observable#delayExecutionWith" id="monix.reactive.Observable#delayExecutionWith" class="extmbr">delayExecutionWith</a> that can work with generic <code>F[_]</code>
tasks, anything that's supported via <a href="ObservableLike.html" name="monix.reactive.ObservableLike" id="monix.reactive.ObservableLike" class="extype">ObservableLike</a> conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#delayExecutionWith[B](trigger:monix.reactive.Observable[B]):monix.reactive.Observable[A]" name="monix.reactive.Observable#delayExecutionWith" id="monix.reactive.Observable#delayExecutionWith" class="extmbr">delayExecutionWith</a> that can work with generic <code>F[_]</code>
tasks, anything that's supported via <a href="ObservableLike.html" name="monix.reactive.ObservableLike" id="monix.reactive.ObservableLike" class="extype">ObservableLike</a> conversions.</p><p>So you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...
</li></ul></div></div></li><li class="indented0 " name="monix.reactive.Observable#delayOnComplete" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="delayOnComplete(delay:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]"></a><a id="delayOnComplete(FiniteDuration):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#delayOnComplete(delay:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">delayOnComplete</span><span class="params">(<span name="delay">delay: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Delays emitting the final <code>onComplete</code> event by the specified amount.</p></li><li class="indented0 " name="monix.reactive.Observable#delayOnNext" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="delayOnNext(duration:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]"></a><a id="delayOnNext(FiniteDuration):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#delayOnNext(duration:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">delayOnNext</span><span class="params">(<span name="duration">duration: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns an Observable that emits the items emitted by the source
Observable shifted forward in time by a specified delay.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits the items emitted by the source
Observable shifted forward in time by a specified delay.</p><p>Each time the source Observable emits an item, delay starts a
timer, and when that timer reaches the given duration, the
Observable returned from delay emits the same item.</p><p>NOTE: this delay refers strictly to the time between the
<code>onNext</code> event coming from our source and the time it takes the
downstream observer to get this event. On the other hand the
operator is also applying back-pressure, so on slow observers
the actual time passing between two successive events may be
higher than the specified <code>duration</code>.
</p></div><dl class="paramcmts block"><dt class="param">duration</dt><dd class="cmt"><p>- the delay to shift the source by</p></dd><dt>returns</dt><dd class="cmt"><p>the source Observable shifted in time by the specified delay</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#delayOnNextBySelector" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="delayOnNextBySelector[B](selector:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[A]"></a><a id="delayOnNextBySelector[B]((A)=&gt;Observable[B]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#delayOnNextBySelector[B](selector:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">delayOnNextBySelector</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="selector">selector: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.delayOnNextBySelector.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns an Observable that emits the items emitted by the source
Observable shifted forward in time.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits the items emitted by the source
Observable shifted forward in time.</p><p>This variant of <code>delay</code> sets its delay duration on a per-item
basis by passing each item from the source Observable into a
function that returns an Observable and then monitoring those
Observables. When any such Observable emits an item or
completes, the Observable returned by delay emits the associated
item.
</p></div><dl class="paramcmts block"><dt class="param">selector</dt><dd class="cmt"><p>is a function that returns an Observable for
       each item emitted by the source Observable, which is then
       used to delay the emission of that item by the resulting
       Observable until the Observable returned from <code>selector</code>
       emits an item</p></dd><dt>returns</dt><dd class="cmt"><p>the source Observable shifted in time by
        the specified delay</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#dematerialize" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="dematerialize[B](implicitev:A&lt;:&lt;monix.reactive.Notification[B]):monix.reactive.Observable[B]"></a><a id="dematerialize[B](&lt;:&lt;[A,Notification[B]]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#dematerialize[B](implicitev:A&lt;:&lt;monix.reactive.Notification[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">dematerialize</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.3/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>, <a href="Notification.html" name="monix.reactive.Notification" id="monix.reactive.Notification" class="extype">Notification</a>[<span name="monix.reactive.Observable.dematerialize.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.dematerialize.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Converts the source Observable that emits <code>Notification[A]</code> (the
result of <a href="#materialize:monix.reactive.Observable[monix.reactive.Notification[A]]" name="monix.reactive.Observable#materialize" id="monix.reactive.Observable#materialize" class="extmbr">materialize</a>) back to an Observable that emits <code>A</code>.</p></li><li class="indented0 " name="monix.reactive.Observable#distinctUntilChanged" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="distinctUntilChanged[AA&gt;:A](implicitA:cats.Eq[AA]):monix.reactive.Observable[AA]"></a><a id="distinctUntilChanged[AA&gt;:A](Eq[AA]):Observable[AA]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#distinctUntilChanged[AA&gt;:A](implicitA:cats.Eq[AA]):monix.reactive.Observable[AA]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">distinctUntilChanged</span><span class="tparams">[<span name="AA">AA &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="A">A: <span name="cats.Eq" class="extype">Eq</span>[<span name="monix.reactive.Observable.distinctUntilChanged.AA" class="extype">AA</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.distinctUntilChanged.AA" class="extype">AA</span>]</span></span><p class="shortcomment cmt">Suppress duplicate consecutive items emitted by the source.</p><div class="fullcomment"><div class="comment cmt"><p>Suppress duplicate consecutive items emitted by the source.</p><p>Example:</p><pre><span class="cmt">// Needed to bring standard Eq instances in scope:</span>
<span class="kw">import</span> cats.implicits._

<span class="cmt">// Yields 1, 2, 1, 3, 2, 4</span>
<span class="kw">val</span> stream = Observable(<span class="num">1</span>, <span class="num">1</span>, <span class="num">1</span>, <span class="num">2</span>, <span class="num">2</span>, <span class="num">1</span>, <span class="num">1</span>, <span class="num">3</span>, <span class="num">3</span>, <span class="num">3</span>, <span class="num">2</span>, <span class="num">2</span>, <span class="num">4</span>, <span class="num">4</span>, <span class="num">4</span>)
  .distinctUntilChanged</pre><p>Duplication is detected by using the equality relationship
provided by the <a href="http://typelevel.org/cats/api/cats/index.html#Eq[A]=cats.kernel.Eq[A]" name="cats" id="cats" class="extype">cats.Eq</a> type class. This allows one to
override the equality operation being used (e.g. maybe the
default <code>.equals</code> is badly defined, or maybe you want reference
equality, so depending on use case).</p><h4>Cats Eq and Scala Interop</h4><p>        Monix prefers to work with <a href="http://typelevel.org/cats/api/cats/index.html#Eq[A]=cats.kernel.Eq[A]" name="cats" id="cats" class="extype">cats.Eq</a> for assessing the equality
        of elements that have an ordering defined, instead of
        <a href="https://www.scala-lang.org/api/2.13.3/scala/math/Equiv.html" name="scala.math.Equiv" id="scala.math.Equiv" class="extype">scala.math.Equiv</a>.</p><p>        We do this because Scala's <code>Equiv</code> has a default instance defined
        that's based on universal equality and that's a big problem, because
        when using the <code>Eq</code> type class, it is universal equality that we
        want to avoid and there have been countless of bugs in the ecosystem
        related to both universal equality and <code>Equiv</code>. Thankfully people
        are working to fix it.</p><p>        We also do this for consistency, as Monix is now building on top of
        Cats. This may change in the future, depending on what happens with
        <a href="https://github.com/typelevel/cats/issues/2455" target="_blank">typelevel/cats#2455</a>.</p><p>        Defining <code>Eq</code> instance is easy and we can use universal equality
        in our definitions as well:</p><pre><span class="kw">import</span> cats.Eq

<span class="kw">case</span> <span class="kw">class</span> Address(host: <span class="std">String</span>, port: <span class="std">Int</span>)

<span class="kw">implicit</span> <span class="kw">val</span> eqForAddress: Eq[Address] =
  Eq.fromUniversalEquals</pre></div><dl class="paramcmts block"><dt class="param">A</dt><dd class="cmt"><p>is the <a href="http://typelevel.org/cats/api/cats/index.html#Eq[A]=cats.kernel.Eq[A]" name="cats" id="cats" class="extype">cats.Eq</a> instance that defines equality
       for the elements emitted by the source</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#distinctUntilChangedByKey" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="distinctUntilChangedByKey[K](key:A=&gt;K)(implicitK:cats.Eq[K]):monix.reactive.Observable[A]"></a><a id="distinctUntilChangedByKey[K]((A)=&gt;K)(Eq[K]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#distinctUntilChangedByKey[K](key:A=&gt;K)(implicitK:cats.Eq[K]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">distinctUntilChangedByKey</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="key">key: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.distinctUntilChangedByKey.K" class="extype">K</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="K">K: <span name="cats.Eq" class="extype">Eq</span>[<span name="monix.reactive.Observable.distinctUntilChangedByKey.K" class="extype">K</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Given a function that returns a key for each element emitted by
the source, suppress consecutive duplicate items.</p><div class="fullcomment"><div class="comment cmt"><p>Given a function that returns a key for each element emitted by
the source, suppress consecutive duplicate items.</p><p>Example:</p><pre><span class="cmt">// Needed to bring standard instances in scope:</span>
<span class="kw">import</span> cats.implicits._

<span class="cmt">// Yields 1, 2, 3, 4</span>
<span class="kw">val</span> stream = Observable(<span class="num">1</span>, <span class="num">3</span>, <span class="num">2</span>, <span class="num">4</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">5</span>, <span class="num">7</span>, <span class="num">4</span>)
  .distinctUntilChangedByKey(_ % <span class="num">2</span>)</pre><p>Duplication is detected by using the equality relationship
provided by the <a href="http://typelevel.org/cats/api/cats/index.html#Eq[A]=cats.kernel.Eq[A]" name="cats" id="cats" class="extype">cats.Eq</a> type class. This allows one to
override the equality operation being used (e.g. maybe the
default <code>.equals</code> is badly defined, or maybe you want reference
equality, so depending on use case).</p><h4>Cats Eq and Scala Interop</h4><p>        Monix prefers to work with <a href="http://typelevel.org/cats/api/cats/index.html#Eq[A]=cats.kernel.Eq[A]" name="cats" id="cats" class="extype">cats.Eq</a> for assessing the equality
        of elements that have an ordering defined, instead of
        <a href="https://www.scala-lang.org/api/2.13.3/scala/math/Equiv.html" name="scala.math.Equiv" id="scala.math.Equiv" class="extype">scala.math.Equiv</a>.</p><p>        We do this because Scala's <code>Equiv</code> has a default instance defined
        that's based on universal equality and that's a big problem, because
        when using the <code>Eq</code> type class, it is universal equality that we
        want to avoid and there have been countless of bugs in the ecosystem
        related to both universal equality and <code>Equiv</code>. Thankfully people
        are working to fix it.</p><p>        We also do this for consistency, as Monix is now building on top of
        Cats. This may change in the future, depending on what happens with
        <a href="https://github.com/typelevel/cats/issues/2455" target="_blank">typelevel/cats#2455</a>.</p><p>        Defining <code>Eq</code> instance is easy and we can use universal equality
        in our definitions as well:</p><pre><span class="kw">import</span> cats.Eq

<span class="kw">case</span> <span class="kw">class</span> Address(host: <span class="std">String</span>, port: <span class="std">Int</span>)

<span class="kw">implicit</span> <span class="kw">val</span> eqForAddress: Eq[Address] =
  Eq.fromUniversalEquals</pre></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>is a function that returns a <code>K</code> key for each element,
       a value that's then used to do the deduplication</p></dd><dt class="param">K</dt><dd class="cmt"><p>is the <a href="http://typelevel.org/cats/api/cats/index.html#Eq[A]=cats.kernel.Eq[A]" name="cats" id="cats" class="extype">cats.Eq</a> instance that defines equality for
       the key type <code>K</code></p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#doAfterSubscribe" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doAfterSubscribe(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]"></a><a id="doAfterSubscribe(Task[Unit]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#doAfterSubscribe(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doAfterSubscribe</span><span class="params">(<span name="task">task: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Executes the given callback just _after_ the subscription
happens.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the given callback just _after_ the subscription
happens.</p><p>The executed <code>Task</code> executes after the subscription happens
and it will delay the first event being emitted. For example
this would delay the emitting of the first event by 1 second:</p><pre><span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> scala.concurrent.duration._

Observable.range(<span class="num">0</span>, <span class="num">100</span>)
  .doAfterSubscribe(Task.sleep(<span class="num">1.</span>second))</pre></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#doOnSubscribe(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnSubscribe" id="monix.reactive.Observable#doOnSubscribe" class="extmbr">doOnSubscribe</a> for executing a callback just before
    a subscription happens.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#doAfterSubscribeF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doAfterSubscribeF[F[_]](task:F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]"></a><a id="doAfterSubscribeF[F[_]](F[Unit])(TaskLike[F]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#doAfterSubscribeF[F[_]](task:F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doAfterSubscribeF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span name="task">task: <span name="monix.reactive.Observable.doAfterSubscribeF.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.doAfterSubscribeF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Version of <a href="#doAfterSubscribe(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doAfterSubscribe" id="monix.reactive.Observable#doAfterSubscribe" class="extmbr">doAfterSubscribe</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#doAfterSubscribe(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doAfterSubscribe" id="monix.reactive.Observable#doAfterSubscribe" class="extmbr">doAfterSubscribe</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><p>So you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...</li></ul><pre><span class="kw">import</span> cats.effect._
<span class="kw">import</span> cats.effect.Timer
<span class="kw">import</span> scala.concurrent.duration._
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global
<span class="kw">import</span> monix.catnap.SchedulerEffect
<span class="cmt">// Needed for IO.sleep</span>
<span class="kw">implicit</span> <span class="kw">val</span> timer: Timer[IO] = SchedulerEffect.timerLiftIO[IO](global)

Observable.range(<span class="num">0</span>, <span class="num">100</span>)
  .doAfterSubscribeF(IO.sleep(<span class="num">1.</span>second))</pre></div></div></li><li class="indented0 " name="monix.reactive.Observable#doOnComplete" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnComplete(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]"></a><a id="doOnComplete(Task[Unit]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#doOnComplete(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnComplete</span><span class="params">(<span name="task">task: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Evaluates the given task when the stream has ended with an
<code>onComplete</code> event, but before the complete event is emitted.</p><div class="fullcomment"><div class="comment cmt"><p>Evaluates the given task when the stream has ended with an
<code>onComplete</code> event, but before the complete event is emitted.</p><p>The task gets evaluated and is finished *before* the <code>onComplete</code>
signal gets sent downstream.</p><pre><span class="kw">import</span> monix.eval.Task

Observable.range(<span class="num">0</span>, <span class="num">10</span>)
  .doOnComplete(Task(println(<span class="lit">"Completed!"</span>)))</pre><p>NOTE: in most cases what you want is <a href="#guaranteeCase(f:cats.effect.ExitCase[Throwable]=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#guaranteeCase" id="monix.reactive.Observable#guaranteeCase" class="extmbr">guaranteeCase</a>
or <a href="#bracketCase[B](use:A=&gt;monix.reactive.Observable[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[B]" name="monix.reactive.Observable#bracketCase" id="monix.reactive.Observable#bracketCase" class="extmbr">bracketCase</a>. This operator is available for
fine-grained control.
</p></div><dl class="paramcmts block"><dt class="param">task</dt><dd class="cmt"><p>the task to execute when the <code>onComplete</code>
       event gets emitted</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#doOnCompleteF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnCompleteF[F[_]](task:F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]"></a><a id="doOnCompleteF[F[_]](F[Unit])(TaskLike[F]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#doOnCompleteF[F[_]](task:F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnCompleteF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span name="task">task: <span name="monix.reactive.Observable.doOnCompleteF.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.doOnCompleteF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Version of <a href="#doOnComplete(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnComplete" id="monix.reactive.Observable#doOnComplete" class="extmbr">doOnComplete</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#doOnComplete(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnComplete" id="monix.reactive.Observable#doOnComplete" class="extmbr">doOnComplete</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><p>So you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...</li></ul><pre><span class="kw">import</span> cats.effect.IO

Observable.range(<span class="num">0</span>, <span class="num">10</span>)
  .doOnCompleteF(IO(println(<span class="lit">"Completed!"</span>)))</pre></div></div></li><li class="indented0 " name="monix.reactive.Observable#doOnEarlyStop" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnEarlyStop(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]"></a><a id="doOnEarlyStop(Task[Unit]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#doOnEarlyStop(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnEarlyStop</span><span class="params">(<span name="task">task: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Executes the given task when the streaming is stopped
due to a downstream <a href="../execution/Ack$$Stop$.html" name="monix.execution.Ack.Stop" id="monix.execution.Ack.Stop" class="extype">Stop</a> signal
returned by <a href="Observer.html#onNext(elem:A):scala.concurrent.Future[monix.execution.Ack]" name="monix.reactive.Observer#onNext" id="monix.reactive.Observer#onNext" class="extmbr">onNext</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the given task when the streaming is stopped
due to a downstream <a href="../execution/Ack$$Stop$.html" name="monix.execution.Ack.Stop" id="monix.execution.Ack.Stop" class="extype">Stop</a> signal
returned by <a href="Observer.html#onNext(elem:A):scala.concurrent.Future[monix.execution.Ack]" name="monix.reactive.Observer#onNext" id="monix.reactive.Observer#onNext" class="extmbr">onNext</a>.</p><p>The given <code>task</code> gets evaluated *before* the upstream
receives the <code>Stop</code> event (is back-pressured).</p><p>Example:</p><pre><span class="kw">import</span> monix.eval.Task

<span class="kw">val</span> stream = Observable.range(<span class="num">0</span>, <span class="std">Int</span>.MaxValue)
  .doOnEarlyStop(Task(println(<span class="lit">"Stopped early!"</span>)))
  .take(<span class="num">100</span>)</pre><p>NOTE: in most cases what you want is <a href="#guaranteeCase(f:cats.effect.ExitCase[Throwable]=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#guaranteeCase" id="monix.reactive.Observable#guaranteeCase" class="extmbr">guaranteeCase</a>
or <a href="#bracketCase[B](use:A=&gt;monix.reactive.Observable[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[B]" name="monix.reactive.Observable#bracketCase" id="monix.reactive.Observable#bracketCase" class="extmbr">bracketCase</a>. This operator is available for
fine-grained control.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#doOnEarlyStopF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnEarlyStopF[F[_]](task:F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]"></a><a id="doOnEarlyStopF[F[_]](F[Unit])(TaskLike[F]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#doOnEarlyStopF[F[_]](task:F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnEarlyStopF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span name="task">task: <span name="monix.reactive.Observable.doOnEarlyStopF.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.doOnEarlyStopF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Version of <a href="#doOnEarlyStop(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnEarlyStop" id="monix.reactive.Observable#doOnEarlyStop" class="extmbr">doOnEarlyStop</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#doOnEarlyStop(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnEarlyStop" id="monix.reactive.Observable#doOnEarlyStop" class="extmbr">doOnEarlyStop</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><p>So you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...</li></ul><p>Example:</p><pre><span class="kw">import</span> cats.effect.IO

<span class="kw">val</span> stream = Observable.range(<span class="num">0</span>, <span class="std">Int</span>.MaxValue)
  .doOnEarlyStopF(IO(println(<span class="lit">"Stopped early!"</span>)))
  .take(<span class="num">100</span>)</pre><p>NOTE: in most cases what you want is <a href="#guaranteeCase(f:cats.effect.ExitCase[Throwable]=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#guaranteeCase" id="monix.reactive.Observable#guaranteeCase" class="extmbr">guaranteeCase</a>
or <a href="#bracketCase[B](use:A=&gt;monix.reactive.Observable[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[B]" name="monix.reactive.Observable#bracketCase" id="monix.reactive.Observable#bracketCase" class="extmbr">bracketCase</a>. This operator is available for
fine-grained control.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#doOnError" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnError(cb:Throwable=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]"></a><a id="doOnError((Throwable)=&gt;Task[Unit]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#doOnError(cb:Throwable=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnError</span><span class="params">(<span name="cb">cb: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Executes the given task when the stream is interrupted with an
error, before the <code>onError</code> event is emitted downstream.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the given task when the stream is interrupted with an
error, before the <code>onError</code> event is emitted downstream.</p><p>Example:</p><pre><span class="kw">import</span> monix.eval.Task

<span class="kw">val</span> dummy = <span class="kw">new</span> RuntimeException(<span class="lit">"dummy"</span>)

(Observable.range(<span class="num">0</span>, <span class="num">10</span>) ++ Observable.raiseError(dummy))
  .doOnError { e <span class="kw">=&gt;</span>
    Task(println(s<span class="lit">"Triggered error: $$e"</span>))
  }</pre><p>NOTE: should protect the code in this callback, because if it
throws an exception the <code>onError</code> event will prefer signaling
the original exception and otherwise the behavior is undefined.</p><p>NOTE: in most cases what you want is <a href="#guaranteeCase(f:cats.effect.ExitCase[Throwable]=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#guaranteeCase" id="monix.reactive.Observable#guaranteeCase" class="extmbr">guaranteeCase</a>
or <a href="#bracketCase[B](use:A=&gt;monix.reactive.Observable[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[B]" name="monix.reactive.Observable#bracketCase" id="monix.reactive.Observable#bracketCase" class="extmbr">bracketCase</a>. This operator is available for
fine-grained control.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#doOnErrorF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnErrorF[F[_]](cb:Throwable=&gt;F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]"></a><a id="doOnErrorF[F[_]]((Throwable)=&gt;F[Unit])(TaskLike[F]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#doOnErrorF[F[_]](cb:Throwable=&gt;F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnErrorF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span name="cb">cb: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <span name="monix.reactive.Observable.doOnErrorF.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.doOnErrorF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Version of <a href="#doOnError(cb:Throwable=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnError" id="monix.reactive.Observable#doOnError" class="extmbr">doOnError</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#doOnError(cb:Throwable=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnError" id="monix.reactive.Observable#doOnError" class="extmbr">doOnError</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><p>So you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...</li></ul><pre><span class="kw">import</span> cats.effect.IO

<span class="kw">val</span> dummy = <span class="kw">new</span> RuntimeException(<span class="lit">"dummy"</span>)

(Observable.range(<span class="num">0</span>, <span class="num">10</span>) ++ Observable.raiseError(dummy))
  .doOnErrorF { e <span class="kw">=&gt;</span>
    IO(println(s<span class="lit">"Triggered error: $$e"</span>))
  }</pre></div></div></li><li class="indented0 " name="monix.reactive.Observable#doOnNext" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnNext(cb:A=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]"></a><a id="doOnNext((A)=&gt;Task[Unit]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#doOnNext(cb:A=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnNext</span><span class="params">(<span name="cb">cb: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Evaluates the given callback for each element generated by the
source Observable, useful for triggering async side-effects.</p><div class="fullcomment"><div class="comment cmt"><p>Evaluates the given callback for each element generated by the
source Observable, useful for triggering async side-effects.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a new Observable that executes the specified
        callback for each element</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#doOnNext(cb:A=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnNext" id="monix.reactive.Observable#doOnNext" class="extmbr">doOnNext</a> for a simpler version that doesn't allow
    asynchronous execution.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#doOnNextAck" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnNextAck(cb:(A,monix.execution.Ack)=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]"></a><a id="doOnNextAck((A,Ack)=&gt;Task[Unit]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#doOnNextAck(cb:(A,monix.execution.Ack)=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnNextAck</span><span class="params">(<span name="cb">cb: (<span name="monix.reactive.Observable.A" class="extype">A</span>, <a href="../execution/Ack.html" name="monix.execution.Ack" id="monix.execution.Ack" class="extype">Ack</a>) =&gt; <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Executes the given callback on each acknowledgement received from
the downstream subscriber, executing a generated
<a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> and back-pressuring until the task
is done.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the given callback on each acknowledgement received from
the downstream subscriber, executing a generated
<a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> and back-pressuring until the task
is done.</p><p>This method helps in executing logic after messages get
processed, for example when messages are polled from
some distributed message queue and an acknowledgement
needs to be sent after each message in order to mark it
as processed.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#doOnNextAckF[F[_]](cb:(A,monix.execution.Ack)=&gt;F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnNextAckF" id="monix.reactive.Observable#doOnNextAckF" class="extmbr">doOnNextAckF</a> for a version that can do evaluation with
     any data type via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a></p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#doOnNextAckF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnNextAckF[F[_]](cb:(A,monix.execution.Ack)=&gt;F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]"></a><a id="doOnNextAckF[F[_]]((A,Ack)=&gt;F[Unit])(TaskLike[F]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#doOnNextAckF[F[_]](cb:(A,monix.execution.Ack)=&gt;F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnNextAckF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span name="cb">cb: (<span name="monix.reactive.Observable.A" class="extype">A</span>, <a href="../execution/Ack.html" name="monix.execution.Ack" id="monix.execution.Ack" class="extype">Ack</a>) =&gt; <span name="monix.reactive.Observable.doOnNextAckF.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.doOnNextAckF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Version of <a href="#doOnNextAck(cb:(A,monix.execution.Ack)=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnNextAck" id="monix.reactive.Observable#doOnNextAck" class="extmbr">doOnNextAck</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#doOnNextAck(cb:(A,monix.execution.Ack)=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnNextAck" id="monix.reactive.Observable#doOnNextAck" class="extmbr">doOnNextAck</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><p>So you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...
</li></ul></div></div></li><li class="indented0 " name="monix.reactive.Observable#doOnNextF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnNextF[F[_]](cb:A=&gt;F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]"></a><a id="doOnNextF[F[_]]((A)=&gt;F[Unit])(TaskLike[F]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#doOnNextF[F[_]](cb:A=&gt;F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnNextF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span name="cb">cb: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.doOnNextF.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.doOnNextF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Version of <a href="#doOnNext(cb:A=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnNext" id="monix.reactive.Observable#doOnNext" class="extmbr">doOnNext</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#doOnNext(cb:A=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnNext" id="monix.reactive.Observable#doOnNext" class="extmbr">doOnNext</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><p>So you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...
</li></ul></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a new Observable that executes the specified
        callback for each element</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#doOnStart" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnStart(cb:A=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]"></a><a id="doOnStart((A)=&gt;Task[Unit]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#doOnStart(cb:A=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnStart</span><span class="params">(<span name="cb">cb: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Executes the given callback only for the first element generated
by the source Observable, useful for doing a piece of
computation only when the stream starts.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the given callback only for the first element generated
by the source Observable, useful for doing a piece of
computation only when the stream starts.</p><p>For example this observable will have a "delayed execution"
of 1 second, plus a delayed first element of another 1 second,
therefore it will take a total of 2 seconds for the first
element to be emitted:</p><pre><span class="kw">import</span> monix.eval._
<span class="kw">import</span> scala.concurrent.duration._

Observable.range(<span class="num">0</span>, <span class="num">100</span>)
  .delayExecution(<span class="num">1.</span>second)
  .doOnStart { a <span class="kw">=&gt;</span>
    <span class="kw">for</span> {
      _ <span class="kw">&lt;-</span> Task.sleep(<span class="num">1.</span>second)
      _ <span class="kw">&lt;-</span> Task(println(s<span class="lit">"Started with: $$a"</span>))
    } <span class="kw">yield</span> ()
  }</pre></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a new Observable that executes the specified task
        only for the first element</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#doOnStartF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnStartF[F[_]](cb:A=&gt;F[Unit])(implicitF:cats.effect.Effect[F]):monix.reactive.Observable[A]"></a><a id="doOnStartF[F[_]]((A)=&gt;F[Unit])(Effect[F]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#doOnStartF[F[_]](cb:A=&gt;F[Unit])(implicitF:cats.effect.Effect[F]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnStartF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span name="cb">cb: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.doOnStartF.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Effect" class="extype">Effect</span>[<span name="monix.reactive.Observable.doOnStartF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Version of <a href="#doOnStart(cb:A=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnStart" id="monix.reactive.Observable#doOnStart" class="extmbr">doOnStart</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#doOnStart(cb:A=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnStart" id="monix.reactive.Observable#doOnStart" class="extmbr">doOnStart</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><p>So you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...</li></ul><pre> <span class="kw">import</span> cats.implicits._
 <span class="kw">import</span> cats.effect._
 <span class="kw">import</span> cats.effect.Timer
 <span class="kw">import</span> scala.concurrent.duration._
 <span class="kw">import</span> monix.execution.Scheduler.Implicits.global
 <span class="kw">import</span> monix.catnap.SchedulerEffect
 <span class="cmt">// Needed for IO.sleep</span>
<span class="kw">implicit</span> <span class="kw">val</span> timer: Timer[IO] = SchedulerEffect.timerLiftIO[IO](global)

 Observable.range(<span class="num">0</span>, <span class="num">100</span>)
   .delayExecution(<span class="num">1.</span>second)
   .doOnStartF { a <span class="kw">=&gt;</span>
     <span class="kw">for</span> {
       _ <span class="kw">&lt;-</span> IO.sleep(<span class="num">1.</span>second)
       _ <span class="kw">&lt;-</span> IO(println(s<span class="lit">"Started with: $$a"</span>))
     } <span class="kw">yield</span> ()
   }</pre></div></div></li><li class="indented0 " name="monix.reactive.Observable#doOnSubscribe" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnSubscribe(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]"></a><a id="doOnSubscribe(Task[Unit]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#doOnSubscribe(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnSubscribe</span><span class="params">(<span name="task">task: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Executes the given callback just _before_ the subscription
to the source happens.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the given callback just _before_ the subscription
to the source happens.</p><p>For example this is equivalent with <a href="#delayExecution(timespan:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#delayExecution" id="monix.reactive.Observable#delayExecution" class="extmbr">delayExecution</a>:</p><pre><span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> scala.concurrent.duration._

Observable.range(<span class="num">0</span>, <span class="num">10</span>)
  .doOnSubscribe(Task.sleep(<span class="num">1.</span>second))</pre></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#doAfterSubscribe(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doAfterSubscribe" id="monix.reactive.Observable#doAfterSubscribe" class="extmbr">doAfterSubscribe</a> for executing a callback just after
    a subscription happens.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#doOnSubscribeF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnSubscribeF[F[_]](task:F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]"></a><a id="doOnSubscribeF[F[_]](F[Unit])(TaskLike[F]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#doOnSubscribeF[F[_]](task:F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnSubscribeF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span name="task">task: <span name="monix.reactive.Observable.doOnSubscribeF.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.doOnSubscribeF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Version of <a href="#doOnSubscribe(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnSubscribe" id="monix.reactive.Observable#doOnSubscribe" class="extmbr">doOnSubscribe</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#doOnSubscribe(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnSubscribe" id="monix.reactive.Observable#doOnSubscribe" class="extmbr">doOnSubscribe</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><p>So you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...</li></ul><p>For example this is equivalent with <a href="#delayExecution(timespan:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#delayExecution" id="monix.reactive.Observable#delayExecution" class="extmbr">delayExecution</a>:</p><pre> <span class="kw">import</span> cats.effect._
 <span class="kw">import</span> cats.effect.Timer
 <span class="kw">import</span> scala.concurrent.duration._
 <span class="kw">import</span> monix.execution.Scheduler.Implicits.global
 <span class="kw">import</span> monix.catnap.SchedulerEffect
 <span class="cmt">// Needed for IO.sleep</span>
<span class="kw">implicit</span> <span class="kw">val</span> timer: Timer[IO] = SchedulerEffect.timerLiftIO[IO](global)

 Observable.range(<span class="num">0</span>, <span class="num">10</span>)
   .doOnSubscribeF(IO.sleep(<span class="num">1.</span>second))</pre></div></div></li><li class="indented0 " name="monix.reactive.Observable#doOnSubscriptionCancel" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnSubscriptionCancel(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]"></a><a id="doOnSubscriptionCancel(Task[Unit]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#doOnSubscriptionCancel(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnSubscriptionCancel</span><span class="params">(<span name="task">task: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Executes the given callback when the connection is being cancelled,
via the <a href="../execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a> reference returned
on subscribing to the created observable.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the given callback when the connection is being cancelled,
via the <a href="../execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a> reference returned
on subscribing to the created observable.</p><p>Example:</p><pre><span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> monix.execution.Scheduler

<span class="kw">implicit</span> <span class="kw">val</span> s = Scheduler.global

<span class="kw">val</span> cancelable =
  Observable
    .range(<span class="num">0</span>, <span class="std">Int</span>.MaxValue)
    .doOnSubscriptionCancel(Task(println(<span class="lit">"Cancelled!"</span>)))
    .subscribe()

cancelable.cancel()</pre><p>NOTE: in most cases what you want is <a href="#guaranteeCase(f:cats.effect.ExitCase[Throwable]=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#guaranteeCase" id="monix.reactive.Observable#guaranteeCase" class="extmbr">guaranteeCase</a>
or <a href="#bracketCase[B](use:A=&gt;monix.reactive.Observable[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[B]" name="monix.reactive.Observable#bracketCase" id="monix.reactive.Observable#bracketCase" class="extmbr">bracketCase</a>. This operator is available for
fine-grained control.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#doOnSubscriptionCancelF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="doOnSubscriptionCancelF[F[_]](task:F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]"></a><a id="doOnSubscriptionCancelF[F[_]](F[Unit])(TaskLike[F]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#doOnSubscriptionCancelF[F[_]](task:F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">doOnSubscriptionCancelF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span name="task">task: <span name="monix.reactive.Observable.doOnSubscriptionCancelF.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.doOnSubscriptionCancelF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Version of <a href="#doOnSubscriptionCancel(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnSubscriptionCancel" id="monix.reactive.Observable#doOnSubscriptionCancel" class="extmbr">doOnSubscriptionCancel</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#doOnSubscriptionCancel(task:monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#doOnSubscriptionCancel" id="monix.reactive.Observable#doOnSubscriptionCancel" class="extmbr">doOnSubscriptionCancel</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><p>So you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...</li></ul><p>Example:</p><pre><span class="kw">import</span> cats.effect.IO
<span class="kw">import</span> monix.execution.Scheduler

<span class="kw">implicit</span> <span class="kw">val</span> s = Scheduler.global

<span class="kw">val</span> cancelable =
  Observable
    .range(<span class="num">0</span>, <span class="std">Int</span>.MaxValue)
    .doOnSubscriptionCancelF(IO(println(<span class="lit">"Cancelled!"</span>)))
    .subscribe()

cancelable.cancel()</pre><p>NOTE: in most cases what you want is <a href="#guaranteeCase(f:cats.effect.ExitCase[Throwable]=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#guaranteeCase" id="monix.reactive.Observable#guaranteeCase" class="extmbr">guaranteeCase</a>
or <a href="#bracketCase[B](use:A=&gt;monix.reactive.Observable[B])(release:(A,cats.effect.ExitCase[Throwable])=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[B]" name="monix.reactive.Observable#bracketCase" id="monix.reactive.Observable#bracketCase" class="extmbr">bracketCase</a>. This operator is available for
fine-grained control.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#drop" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="drop(n:Long):monix.reactive.Observable[A]"></a><a id="drop(Long):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#drop(n:Long):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">drop</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.3/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Drops the first <code>n</code> elements (from the start).</p><div class="fullcomment"><div class="comment cmt"><p>Drops the first <code>n</code> elements (from the start).
</p></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>the number (Long) of elements to drop</p></dd><dt>returns</dt><dd class="cmt"><p>a new Observable that drops the first <i>n</i> elements
        emitted by the source</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#drop" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="drop(n:Int):monix.reactive.Observable[A]"></a><a id="drop(Int):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#drop(n:Int):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">drop</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Overload of <a href="#drop(n:Long):monix.reactive.Observable[A]" name="monix.reactive.Observable#drop" id="monix.reactive.Observable#drop" class="extmbr">drop(Long)</a>.</p></li><li class="indented0 " name="monix.reactive.Observable#dropByTimespan" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dropByTimespan(timespan:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]"></a><a id="dropByTimespan(FiniteDuration):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#dropByTimespan(timespan:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">dropByTimespan</span><span class="params">(<span name="timespan">timespan: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new observable that drops the events of the source, only
for the specified <code>timestamp</code> window.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new observable that drops the events of the source, only
for the specified <code>timestamp</code> window.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>the window of time during which the new observable
       must drop events emitted by the source</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#dropLast" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dropLast(n:Int):monix.reactive.Observable[A]"></a><a id="dropLast(Int):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#dropLast(n:Int):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">dropLast</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Drops the last <code>n</code> elements (from the end).</p><div class="fullcomment"><div class="comment cmt"><p>Drops the last <code>n</code> elements (from the end).
</p></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>the number of elements to drop</p></dd><dt>returns</dt><dd class="cmt"><p>a new Observable that drops the first <i>n</i> elements
        emitted by the source</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#dropUntil" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dropUntil(trigger:monix.reactive.Observable[Any]):monix.reactive.Observable[A]"></a><a id="dropUntil(Observable[Any]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#dropUntil(trigger:monix.reactive.Observable[Any]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">dropUntil</span><span class="params">(<span name="trigger">trigger: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Discard items emitted by the source until a second
observable emits an item or completes.</p><div class="fullcomment"><div class="comment cmt"><p>Discard items emitted by the source until a second
observable emits an item or completes.</p><p>If the <code>trigger</code> observable completes in error, then the
resulting observable will also end in error when it notices
it (next time an element is emitted by the source).
</p></div><dl class="paramcmts block"><dt class="param">trigger</dt><dd class="cmt"><p>the observable that has to emit an item before the
       source begin to be mirrored by the resulting observable</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#dropWhile" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="dropWhile(p:A=&gt;Boolean):monix.reactive.Observable[A]"></a><a id="dropWhile((A)=&gt;Boolean):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#dropWhile(p:A=&gt;Boolean):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">dropWhile</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Drops the longest prefix of elements that satisfy the given
predicate and returns a new observable that emits the rest.</p></li><li class="indented0 " name="monix.reactive.Observable#dropWhileInclusive" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="dropWhileInclusive(p:A=&gt;Boolean):monix.reactive.Observable[A]"></a><a id="dropWhileInclusive((A)=&gt;Boolean):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#dropWhileInclusive(p:A=&gt;Boolean):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">dropWhileInclusive</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Drops the longest prefix of elements that satisfy the given
predicate, inclusive of the value that caused <code>predicate</code> to return <code>false</code> and
returns a new observable that emits the rest.</p></li><li class="indented0 " name="monix.reactive.Observable#dropWhileWithIndex" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dropWhileWithIndex(p:(A,Int)=&gt;Boolean):monix.reactive.Observable[A]"></a><a id="dropWhileWithIndex((A,Int)=&gt;Boolean):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#dropWhileWithIndex(p:(A,Int)=&gt;Boolean):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">dropWhileWithIndex</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>, <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Drops the longest prefix of elements that satisfy the given
function and returns a new observable that emits the rest.</p><div class="fullcomment"><div class="comment cmt"><p>Drops the longest prefix of elements that satisfy the given
function and returns a new observable that emits the rest. In
comparison with <a href="#dropWhile(p:A=&gt;Boolean):monix.reactive.Observable[A]" name="monix.reactive.Observable#dropWhile" id="monix.reactive.Observable#dropWhile" class="extmbr">dropWhile</a>, this version accepts a function
that takes an additional parameter: the zero-based index of the
element.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#dump" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="dump(prefix:String,out:java.io.PrintStream):monix.reactive.Observable[A]"></a><a id="dump(String,PrintStream):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#dump(prefix:String,out:java.io.PrintStream):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">dump</span><span class="params">(<span name="prefix">prefix: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="out">out: <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintStream.html#java.io.PrintStream" name="java.io.PrintStream" id="java.io.PrintStream" class="extype">PrintStream</a> = <span class="symbol">System.out</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Utility that can be used for debugging purposes.</p></li><li class="indented0 " name="monix.reactive.Observable#echoOnce" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="echoOnce(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]"></a><a id="echoOnce(FiniteDuration):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#echoOnce(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">echoOnce</span><span class="params">(<span name="timeout">timeout: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Mirror the source observable as long as the source keeps emitting
items, otherwise if <code>timeout</code> passes without the source emitting
anything new then the observable will emit the last item.</p><div class="fullcomment"><div class="comment cmt"><p>Mirror the source observable as long as the source keeps emitting
items, otherwise if <code>timeout</code> passes without the source emitting
anything new then the observable will emit the last item.</p><p>Note: If the source Observable keeps emitting items more
frequently than the length of the time window then the resulting
observable will mirror the source exactly.
</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>the window of silence that must pass in order for the
       observable to echo the last item</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#echoRepeated" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="echoRepeated(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]"></a><a id="echoRepeated(FiniteDuration):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#echoRepeated(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">echoRepeated</span><span class="params">(<span name="timeout">timeout: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Mirror the source observable as long as the source keeps emitting
items, otherwise if <code>timeout</code> passes without the source emitting
anything new then the observable will start emitting the last
item repeatedly.</p><div class="fullcomment"><div class="comment cmt"><p>Mirror the source observable as long as the source keeps emitting
items, otherwise if <code>timeout</code> passes without the source emitting
anything new then the observable will start emitting the last
item repeatedly.</p><p>Note: If the source Observable keeps emitting items more
frequently than the length of the time window then the resulting
observable will mirror the source exactly.
</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>the window of silence that must pass in order for the
       observable to start echoing the last item</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#endWith" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="endWith[B&gt;:A](elems:Seq[B]):monix.reactive.Observable[B]"></a><a id="endWith[B&gt;:A](Seq[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#endWith[B&gt;:A](elems:Seq[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">endWith</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="elems">elems: <span name="scala.Seq" class="extype">Seq</span>[<span name="monix.reactive.Observable.endWith.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.endWith.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new Observable that emits the events of the source and
then it also emits the given elements (appended to the stream).</p></li><li class="indented0 " name="monix.reactive.Observable#endWithError" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="endWithError(error:Throwable):monix.reactive.Observable[A]"></a><a id="endWithError(Throwable):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#endWithError(error:Throwable):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">endWithError</span><span class="params">(<span name="error">error: <span name="scala.Throwable" class="extype">Throwable</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Emits the given exception instead of <code>onComplete</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Emits the given exception instead of <code>onComplete</code>.
</p></div><dl class="paramcmts block"><dt class="param">error</dt><dd class="cmt"><p>the exception to emit onComplete</p></dd><dt>returns</dt><dd class="cmt"><p>a new Observable that emits an exception onComplete</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#equals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="equals(x$1:Object):Boolean"></a><a id="equals(AnyRef):Boolean"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#equals(x$1:Object):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#executeAsync" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="executeAsync:monix.reactive.Observable[A]"></a><a id="executeAsync:Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#executeAsync:monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">executeAsync</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Mirrors the source observable, but upon subscription ensure
that the evaluation forks into a separate (logical) thread.</p><div class="fullcomment"><div class="comment cmt"><p>Mirrors the source observable, but upon subscription ensure
that the evaluation forks into a separate (logical) thread.</p><p>The execution is managed by the injected
<a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">scheduler</a> in <code>subscribe()</code>.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#executeOn" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="executeOn(s:monix.execution.Scheduler,forceAsync:Boolean):monix.reactive.Observable[A]"></a><a id="executeOn(Scheduler,Boolean):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#executeOn(s:monix.execution.Scheduler,forceAsync:Boolean):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">executeOn</span><span class="params">(<span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>, <span name="forceAsync">forceAsync: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a> = <span class="symbol">true</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Overrides the default <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>,
possibly forcing an asynchronous boundary on subscription
(if <code>forceAsync</code> is set to <code>true</code>, the default).</p><div class="fullcomment"><div class="comment cmt"><p>Overrides the default <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>,
possibly forcing an asynchronous boundary on subscription
(if <code>forceAsync</code> is set to <code>true</code>, the default).</p><p>When an <code>Observable</code> is subscribed with
<a href="#subscribe(subscriber:monix.reactive.observers.Subscriber[A]):monix.execution.Cancelable" name="monix.reactive.Observable#subscribe" id="monix.reactive.Observable#subscribe" class="extmbr">subscribe</a>,
it needs a <code>Scheduler</code>, which is going to be injected in the
processing pipeline, to be used for managing asynchronous
boundaries, scheduling execution with delay, etc.</p><p>Normally the <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> gets injected
implicitly when doing <code>subscribe</code>, but this operator overrides
the injected subscriber for the given source. And if the source is
normally using that injected scheduler (given by <code>subscribe</code>),
then the effect will be that all processing will now happen
on the override.</p><p>To put it in other words, in Monix it's usually the consumer and
not the producer that specifies the scheduler and this operator
allows for a different behavior.</p><p>This operator also subsumes the effects of <a href="#subscribeOn(scheduler:monix.execution.Scheduler):monix.reactive.Observable[A]" name="monix.reactive.Observable#subscribeOn" id="monix.reactive.Observable#subscribeOn" class="extmbr">subscribeOn</a>,
meaning that the subscription logic itself will start on
the provided scheduler if <code>forceAsync = true</code> (the default).
</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>is the <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> to use
       for overriding the default scheduler and for forcing
       an asynchronous boundary if <code>forceAsync</code> is <code>true</code></p></dd><dt class="param">forceAsync</dt><dd class="cmt"><p>indicates whether an asynchronous boundary
       should be forced right before the subscription of the
       source <code>Observable</code>, managed by the provided <code>Scheduler</code></p></dd><dt>returns</dt><dd class="cmt"><p>a new <code>Observable</code> that mirrors the source on subscription,
        but that uses the provided scheduler for overriding
        the default and possibly force an extra asynchronous
        boundary on execution</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#observeOn(s:monix.execution.Scheduler):monix.reactive.Observable[A]" name="monix.reactive.Observable#observeOn" id="monix.reactive.Observable#observeOn" class="extmbr">observeOn</a>
     and <a href="#subscribeOn(scheduler:monix.execution.Scheduler):monix.reactive.Observable[A]" name="monix.reactive.Observable#subscribeOn" id="monix.reactive.Observable#subscribeOn" class="extmbr">subscribeOn</a>.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#executeWithModel" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="executeWithModel(em:monix.execution.ExecutionModel):monix.reactive.Observable[A]"></a><a id="executeWithModel(ExecutionModel):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#executeWithModel(em:monix.execution.ExecutionModel):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">executeWithModel</span><span class="params">(<span name="em">em: <a href="../execution/ExecutionModel.html" name="monix.execution.ExecutionModel" id="monix.execution.ExecutionModel" class="extype">ExecutionModel</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns a new observable that will execute the source with a different
<a href="../execution/ExecutionModel.html" name="monix.execution.ExecutionModel" id="monix.execution.ExecutionModel" class="extype">ExecutionModel</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new observable that will execute the source with a different
<a href="../execution/ExecutionModel.html" name="monix.execution.ExecutionModel" id="monix.execution.ExecutionModel" class="extype">ExecutionModel</a>.</p><p>This allows fine-tuning the options injected by the scheduler
locally. Example:</p><pre><span class="kw">import</span> monix.execution.ExecutionModel.AlwaysAsyncExecution

<span class="kw">val</span> stream = Observable(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>)
  .executeWithModel(AlwaysAsyncExecution)</pre></div><dl class="paramcmts block"><dt class="param">em</dt><dd class="cmt"><p>is the
       <a href="../execution/ExecutionModel.html" name="monix.execution.ExecutionModel" id="monix.execution.ExecutionModel" class="extype">ExecutionModel</a>
       that will be used when evaluating the source.</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#exists" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="exists(p:A=&gt;Boolean):monix.reactive.Observable[Boolean]"></a><a id="exists((A)=&gt;Boolean):Observable[Boolean]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#exists(p:A=&gt;Boolean):monix.reactive.Observable[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">exists</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Returns an Observable which emits a single value, either true, in
case the given predicate holds for at least one item, or false
otherwise.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable which emits a single value, either true, in
case the given predicate holds for at least one item, or false
otherwise.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is a function that evaluates the items emitted by the
       source Observable, returning <code>true</code> if they pass the
       filter</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits only true or false in case
        the given predicate holds or not for at least one item</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#existsL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="existsL(p:A=&gt;Boolean):monix.eval.Task[Boolean]"></a><a id="existsL((A)=&gt;Boolean):Task[Boolean]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#existsL(p:A=&gt;Boolean):monix.eval.Task[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">existsL</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Returns a <code>Task</code> which emits either <code>true</code>, in case the given predicate
holds for at least one item, or <code>false</code> otherwise.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <code>Task</code> which emits either <code>true</code>, in case the given predicate
holds for at least one item, or <code>false</code> otherwise.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is a function that evaluates the items emitted by the
       source, returning <code>true</code> if they pass the filter</p></dd><dt>returns</dt><dd class="cmt"><p>a task that emits <code>true</code> or <code>false</code> in case
        the given predicate holds or not for at least one item</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#failed" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="failed:monix.reactive.Observable[Throwable]"></a><a id="failed:Observable[Throwable]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#failed:monix.reactive.Observable[Throwable]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">failed</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="scala.Throwable" class="extype">Throwable</span>]</span></span><p class="shortcomment cmt">Returns an observable that emits a single Throwable, in case an
error was thrown by the source, otherwise it isn't going to emit
anything.</p></li><li class="indented0 " name="monix.reactive.Observable#filter" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="filter(p:A=&gt;Boolean):monix.reactive.Observable[A]"></a><a id="filter((A)=&gt;Boolean):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#filter(p:A=&gt;Boolean):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">filter</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Only emits those items for which the given predicate holds.</p><div class="fullcomment"><div class="comment cmt"><p>Only emits those items for which the given predicate holds.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>a function that evaluates the items emitted by the source
       returning <code>true</code> if they pass the filter</p></dd><dt>returns</dt><dd class="cmt"><p>a new observable that emits only those items in the source
        for which the filter evaluates as <code>true</code></p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#filterEval(p:A=&gt;monix.eval.Task[Boolean]):monix.reactive.Observable[A]" name="monix.reactive.Observable#filterEval" id="monix.reactive.Observable#filterEval" class="extmbr">filterEval</a> for a version that works with a <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">monix.eval.Task</a>.</p></span><span class="cmt"><p><a href="#filterEvalF[F[_]](p:A=&gt;F[Boolean])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]" name="monix.reactive.Observable#filterEvalF" id="monix.reactive.Observable#filterEvalF" class="extmbr">filterEvalF</a> for a version that works with a generic
     <code>F[_]</code> (e.g. <code>cats.effect.IO</code>, Scala's <code>Future</code>),
     powered by <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a></p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#filterEval" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="filterEval(p:A=&gt;monix.eval.Task[Boolean]):monix.reactive.Observable[A]"></a><a id="filterEval((A)=&gt;Task[Boolean]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#filterEval(p:A=&gt;monix.eval.Task[Boolean]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">filterEval</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Version of <a href="#filter(p:A=&gt;Boolean):monix.reactive.Observable[A]" name="monix.reactive.Observable#filter" id="monix.reactive.Observable#filter" class="extmbr">filter</a> that can work with a predicate expressed by
a <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">monix.eval.Task</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#filter(p:A=&gt;Boolean):monix.reactive.Observable[A]" name="monix.reactive.Observable#filter" id="monix.reactive.Observable#filter" class="extmbr">filter</a> that can work with a predicate expressed by
a <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">monix.eval.Task</a>.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#filterEvalF[F[_]](p:A=&gt;F[Boolean])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]" name="monix.reactive.Observable#filterEvalF" id="monix.reactive.Observable#filterEvalF" class="extmbr">filterEvalF</a> for a version that works with a generic
     <code>F[_]</code> (e.g. <code>cats.effect.IO</code>, Scala's <code>Future</code>),
     powered by <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a></p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#filterEvalF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="filterEvalF[F[_]](p:A=&gt;F[Boolean])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]"></a><a id="filterEvalF[F[_]]((A)=&gt;F[Boolean])(TaskLike[F]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#filterEvalF[F[_]](p:A=&gt;F[Boolean])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">filterEvalF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.filterEvalF.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.filterEvalF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Version of <a href="#filterEval(p:A=&gt;monix.eval.Task[Boolean]):monix.reactive.Observable[A]" name="monix.reactive.Observable#filterEval" id="monix.reactive.Observable#filterEval" class="extmbr">filterEval</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#filterEval(p:A=&gt;monix.eval.Task[Boolean]):monix.reactive.Observable[A]" name="monix.reactive.Observable#filterEval" id="monix.reactive.Observable#filterEval" class="extmbr">filterEval</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><p>So you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...
</li></ul></div></div></li><li class="indented0 " name="monix.reactive.Observable#filterNot" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="filterNot(p:A=&gt;Boolean):monix.reactive.Observable[A]"></a><a id="filterNot((A)=&gt;Boolean):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#filterNot(p:A=&gt;Boolean):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">filterNot</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Only emits those items for which the given predicate doesn't hold.</p><div class="fullcomment"><div class="comment cmt"><p>Only emits those items for which the given predicate doesn't hold.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>a function that evaluates the items emitted by the source
       returning <code>true</code> if they should be filtered out</p></dd><dt>returns</dt><dd class="cmt"><p>a new observable that emits only those items in the source
        for which the filter evaluates as <code>false</code></p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#find" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="find(p:A=&gt;Boolean):monix.reactive.Observable[A]"></a><a id="find((A)=&gt;Boolean):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#find(p:A=&gt;Boolean):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">find</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns an Observable which only emits the first item for which
the predicate holds.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable which only emits the first item for which
the predicate holds.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is a function that evaluates the items emitted by the
       source Observable, returning <code>true</code> if they pass the filter</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits only the first item in the original
        Observable for which the filter evaluates as <code>true</code></p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#findL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="findL(p:A=&gt;Boolean):monix.eval.Task[Option[A]]"></a><a id="findL((A)=&gt;Boolean):Task[Option[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#findL(p:A=&gt;Boolean):monix.eval.Task[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">findL</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Returns a task which emits the first item for which
the predicate holds.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a task which emits the first item for which
the predicate holds.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is a function that evaluates the items emitted by the
       source observable, returning <code>true</code> if they pass the filter</p></dd><dt>returns</dt><dd class="cmt"><p>a task that emits the first item in the source
        observable for which the filter evaluates as <code>true</code></p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#firstL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="firstL:monix.eval.Task[A]"></a><a id="firstL:Task[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#firstL:monix.eval.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">firstL</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> that upon execution
will signal the first generated element of the source observable.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> that upon execution
will signal the first generated element of the source observable.</p><p>In case the stream was empty, then the <code>Task</code> gets completed
in error with a <code>NoSuchElementException</code>.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#firstOptionL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="firstOptionL:monix.eval.Task[Option[A]]"></a><a id="firstOptionL:Task[Option[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#firstOptionL:monix.eval.Task[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">firstOptionL</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Creates a new <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> that upon execution
will signal the first generated element of the source observable.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> that upon execution
will signal the first generated element of the source observable.</p><p>Returns an <code>Option</code> because the source can be empty.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#firstOrElse" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="firstOrElse[B&gt;:A](default:=&gt;B):monix.reactive.Observable[B]"></a><a id="firstOrElse[B&gt;:A](=&gt;B):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#firstOrElse[B&gt;:A](default:=&gt;B):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">firstOrElse</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="default">default: =&gt; <span name="monix.reactive.Observable.firstOrElse.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.firstOrElse.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Alias for <a href="#headOrElse[B&gt;:A](default:=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#headOrElse" id="monix.reactive.Observable#headOrElse" class="extmbr">headOrElse</a>.</p></li><li class="indented0 " name="monix.reactive.Observable#firstOrElseL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="firstOrElseL[B&gt;:A](default:=&gt;B):monix.eval.Task[B]"></a><a id="firstOrElseL[B&gt;:A](=&gt;B):Task[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#firstOrElseL[B&gt;:A](default:=&gt;B):monix.eval.Task[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">firstOrElseL</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="default">default: =&gt; <span name="monix.reactive.Observable.firstOrElseL.B" class="extype">B</span></span>)</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="monix.reactive.Observable.firstOrElseL.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> that upon execution
will signal the first generated element of the source observable.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> that upon execution
will signal the first generated element of the source observable.</p><p>In case the stream was empty, then the given default
gets evaluated and emitted.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#flatMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="flatMap[B]((A)=&gt;Observable[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flatMap.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flatMap.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Alias for <a href="#concatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#concatMap" id="monix.reactive.Observable#concatMap" class="extmbr">concatMap</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Alias for <a href="#concatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#concatMap" id="monix.reactive.Observable#concatMap" class="extmbr">concatMap</a>.</p><p>NOTE: one primary difference between Monix and other Rx /
ReactiveX implementations is that in Monix <code>flatMap</code> is an alias
for <code>concatMap</code> and NOT <code>mergeMap</code>.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#flatMapDelayErrors" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="flatMapDelayErrors[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="flatMapDelayErrors[B]((A)=&gt;Observable[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#flatMapDelayErrors[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatMapDelayErrors</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flatMapDelayErrors.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flatMapDelayErrors.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Alias of <a href="#concatMapDelayErrors[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#concatMapDelayErrors" id="monix.reactive.Observable#concatMapDelayErrors" class="extmbr">concatMapDelayErrors</a>.</p></li><li class="indented0 " name="monix.reactive.Observable#flatMapIterable" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatMapIterable[B](f:A=&gt;scala.collection.immutable.Iterable[B]):monix.reactive.Observable[B]"></a><a id="flatMapIterable[B]((A)=&gt;Iterable[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#flatMapIterable[B](f:A=&gt;scala.collection.immutable.Iterable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatMapIterable</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/collection/immutable/Iterable.html#scala.collection.immutable.Iterable" name="scala.collection.immutable.Iterable" id="scala.collection.immutable.Iterable" class="extype">Iterable</a>[<span name="monix.reactive.Observable.flatMapIterable.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flatMapIterable.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Alias for <a href="#concatMapIterable[B](f:A=&gt;scala.collection.immutable.Iterable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#concatMapIterable" id="monix.reactive.Observable#concatMapIterable" class="extmbr">concatMapIterable</a></p><div class="fullcomment"><div class="comment cmt"><p>Alias for <a href="#concatMapIterable[B](f:A=&gt;scala.collection.immutable.Iterable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#concatMapIterable" id="monix.reactive.Observable#concatMapIterable" class="extmbr">concatMapIterable</a></p><p>NOTE: one primary difference between Monix and other Rx /
ReactiveX implementations is that in Monix <code>flatMap</code> is an alias
for <code>concatMap</code> and NOT <code>mergeMap</code>.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#flatMapLatest" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="flatMapLatest[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="flatMapLatest[B]((A)=&gt;Observable[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#flatMapLatest[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatMapLatest</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flatMapLatest.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flatMapLatest.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Alias of <a href="#switchMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#switchMap" id="monix.reactive.Observable#switchMap" class="extmbr">switchMap</a>.</p></li><li class="indented0 " name="monix.reactive.Observable#flatScan" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatScan[R](seed:=&gt;R)(op:(R,A)=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]"></a><a id="flatScan[R](=&gt;R)((R,A)=&gt;Observable[R]):Observable[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#flatScan[R](seed:=&gt;R)(op:(R,A)=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatScan</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="seed">seed: =&gt; <span name="monix.reactive.Observable.flatScan.R" class="extype">R</span></span>)</span><span class="params">(<span name="op">op: (<span name="monix.reactive.Observable.flatScan.R" class="extype">R</span>, <span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flatScan.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flatScan.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Applies a binary operator to a start value and to elements
produced by the source observable, going from left to right,
producing and concatenating observables along the way.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a binary operator to a start value and to elements
produced by the source observable, going from left to right,
producing and concatenating observables along the way.</p><p>It's the combination between <a href="#scan[S](seed:=&gt;S)(op:(S,A)=&gt;S):monix.reactive.Observable[S]" name="monix.reactive.Observable#scan" id="monix.reactive.Observable#scan" class="extmbr">scan</a> and <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a>.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#flatScan0[R](seed:=&gt;R)(op:(R,A)=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#flatScan0" id="monix.reactive.Observable#flatScan0" class="extmbr">flatScan0</a> for the version that emits seed element at the beginning</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#flatScan0" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatScan0[R](seed:=&gt;R)(op:(R,A)=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]"></a><a id="flatScan0[R](=&gt;R)((R,A)=&gt;Observable[R]):Observable[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#flatScan0[R](seed:=&gt;R)(op:(R,A)=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatScan0</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="seed">seed: =&gt; <span name="monix.reactive.Observable.flatScan0.R" class="extype">R</span></span>)</span><span class="params">(<span name="op">op: (<span name="monix.reactive.Observable.flatScan0.R" class="extype">R</span>, <span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flatScan0.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flatScan0.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Applies a binary operator to a start value and to elements
produced by the source observable, going from left to right,
producing and concatenating observables along the way.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a binary operator to a start value and to elements
produced by the source observable, going from left to right,
producing and concatenating observables along the way.</p><p>It's the combination between <a href="#scan0[S](seed:=&gt;S)(op:(S,A)=&gt;S):monix.reactive.Observable[S]" name="monix.reactive.Observable#scan0" id="monix.reactive.Observable#scan0" class="extmbr">scan0</a> and <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a>.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#flatScan0DelayErrors" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatScan0DelayErrors[R](seed:=&gt;R)(op:(R,A)=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]"></a><a id="flatScan0DelayErrors[R](=&gt;R)((R,A)=&gt;Observable[R]):Observable[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#flatScan0DelayErrors[R](seed:=&gt;R)(op:(R,A)=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatScan0DelayErrors</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="seed">seed: =&gt; <span name="monix.reactive.Observable.flatScan0DelayErrors.R" class="extype">R</span></span>)</span><span class="params">(<span name="op">op: (<span name="monix.reactive.Observable.flatScan0DelayErrors.R" class="extype">R</span>, <span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flatScan0DelayErrors.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flatScan0DelayErrors.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Version of <a href="#flatScan0[R](seed:=&gt;R)(op:(R,A)=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#flatScan0" id="monix.reactive.Observable#flatScan0" class="extmbr">flatScan0</a> that delays the errors from the emitted
streams until the source completes.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#flatScan0[R](seed:=&gt;R)(op:(R,A)=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#flatScan0" id="monix.reactive.Observable#flatScan0" class="extmbr">flatScan0</a> that delays the errors from the emitted
streams until the source completes.</p><h4>Delaying Errors</h4><p>        This version is reserving <code>onError</code> notifications until
        all of the observables complete and only then passing the
        issued errors(s) downstream. Note that the streamed error is a
        <a href="../execution/exceptions/CompositeException.html" name="monix.execution.exceptions.CompositeException" id="monix.execution.exceptions.CompositeException" class="extype">CompositeException</a>,
        since multiple errors from multiple streams can happen.</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#flatScan0[R](seed:=&gt;R)(op:(R,A)=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#flatScan0" id="monix.reactive.Observable#flatScan0" class="extmbr">flatScan0</a></p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#flatScanDelayErrors" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatScanDelayErrors[R](seed:=&gt;R)(op:(R,A)=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]"></a><a id="flatScanDelayErrors[R](=&gt;R)((R,A)=&gt;Observable[R]):Observable[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#flatScanDelayErrors[R](seed:=&gt;R)(op:(R,A)=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatScanDelayErrors</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="seed">seed: =&gt; <span name="monix.reactive.Observable.flatScanDelayErrors.R" class="extype">R</span></span>)</span><span class="params">(<span name="op">op: (<span name="monix.reactive.Observable.flatScanDelayErrors.R" class="extype">R</span>, <span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flatScanDelayErrors.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flatScanDelayErrors.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Version of <a href="#flatScan[R](seed:=&gt;R)(op:(R,A)=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#flatScan" id="monix.reactive.Observable#flatScan" class="extmbr">flatScan</a> that delays the errors from the emitted
streams until the source completes.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#flatScan[R](seed:=&gt;R)(op:(R,A)=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#flatScan" id="monix.reactive.Observable#flatScan" class="extmbr">flatScan</a> that delays the errors from the emitted
streams until the source completes.</p><h4>Delaying Errors</h4><p>        This version is reserving <code>onError</code> notifications until
        all of the observables complete and only then passing the
        issued errors(s) downstream. Note that the streamed error is a
        <a href="../execution/exceptions/CompositeException.html" name="monix.execution.exceptions.CompositeException" id="monix.execution.exceptions.CompositeException" class="extype">CompositeException</a>,
        since multiple errors from multiple streams can happen.</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#flatScan[R](seed:=&gt;R)(op:(R,A)=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#flatScan" id="monix.reactive.Observable#flatScan" class="extmbr">flatScan</a></p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#flatten" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatten[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="flatten[B](&lt;:&lt;[A,Observable[B]]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#flatten[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatten</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.3/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>, <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flatten.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flatten.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Concatenates the sequence of observables
        emitted by the source into one observable, without any
        transformation.</p><div class="fullcomment"><div class="comment cmt"><p>Concatenates the sequence of observables
        emitted by the source into one observable, without any
        transformation.</p><p>        You can combine the items emitted by multiple observables
        so that they act like a single sequence by using this
        operator.</p><p>        This operation is the "monadic bind", implementing the
        <code>flatMap</code> operation of <a href="http://typelevel.org/cats/api/cats/Monad.html" name="cats.Monad" id="cats.Monad" class="extype">cats.Monad</a>.</p><h4>Concat vs Merge</h4><p>        The difference between the <a href="#concat[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#concat" id="monix.reactive.Observable#concat" class="extmbr">concat</a>
        operation and <a href="#merge[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B],implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#merge" id="monix.reactive.Observable#merge" class="extmbr">merge</a> is that <code>concat</code>
        cares about the ordering of sequences (e.g. all items
        emitted by the first observable in the sequence will come
        before the elements emitted by the second observable),
        whereas <code>merge</code> doesn't care about that (elements get
        emitted as they come). Because of back-pressure applied to
        observables, <code>concat</code> is safe to use in all contexts,
        whereas <code>merge</code> requires buffering. Or in other words
        <code>concat</code> has deterministic, lawful behavior (being the
        "monadic bind"), whereas <code>merge</code> has non-deterministic
        behavior.</p><p>Alias for <a href="#concat[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#concat" id="monix.reactive.Observable#concat" class="extmbr">concat</a>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an observable that emits the merged events of all
        streams created by the source</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#flattenDelayErrors" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="flattenDelayErrors[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="flattenDelayErrors[B](&lt;:&lt;[A,Observable[B]]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#flattenDelayErrors[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flattenDelayErrors</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.3/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>, <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flattenDelayErrors.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flattenDelayErrors.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Alias for <a href="#concatDelayErrors[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#concatDelayErrors" id="monix.reactive.Observable#concatDelayErrors" class="extmbr">concatDelayErrors</a>.</p></li><li class="indented0 " name="monix.reactive.Observable#flattenLatest" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="flattenLatest[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="flattenLatest[B](&lt;:&lt;[A,Observable[B]]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#flattenLatest[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flattenLatest</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.3/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>, <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flattenLatest.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.flattenLatest.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Alias for <a href="#switch[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#switch" id="monix.reactive.Observable#switch" class="extmbr">switch</a>.</p></li><li class="indented0 " name="monix.reactive.Observable#fold" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="fold[AA&gt;:A](implicitA:cats.Monoid[AA]):monix.reactive.Observable[AA]"></a><a id="fold[AA&gt;:A](Monoid[AA]):Observable[AA]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#fold[AA&gt;:A](implicitA:cats.Monoid[AA]):monix.reactive.Observable[AA]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">fold</span><span class="tparams">[<span name="AA">AA &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="A">A: <span name="cats.Monoid" class="extype">Monoid</span>[<span name="monix.reactive.Observable.fold.AA" class="extype">AA</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.fold.AA" class="extype">AA</span>]</span></span><p class="shortcomment cmt">Given evidence that type <code>A</code> has a <code>cats.Monoid</code> implementation,
folds the stream with the provided monoid definition.</p><div class="fullcomment"><div class="comment cmt"><p>Given evidence that type <code>A</code> has a <code>cats.Monoid</code> implementation,
folds the stream with the provided monoid definition.</p><p>For streams emitting numbers, this effectively sums them up.
For strings, this concatenates them.</p><p>Example:</p><pre><span class="kw">import</span> cats.implicits._

<span class="cmt">// Yields 10</span>
<span class="kw">val</span> stream1 = Observable(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).fold

<span class="cmt">// Yields "1234"</span>
<span class="kw">val</span> stream2 = Observable(<span class="lit">"1"</span>, <span class="lit">"2"</span>, <span class="lit">"3"</span>, <span class="lit">"4"</span>).fold</pre><p>Note, in case you don't have a <code>Monoid</code> instance in scope,
but you feel like you should, try this import:</p><pre><span class="kw">import</span> cats.instances.all._</pre></div><dl class="paramcmts block"><dt class="param">A</dt><dd class="cmt"><p>is the <code>cats.Monoid</code> type class instance that's needed
         in scope for folding the source</p></dd><dt>returns</dt><dd class="cmt"><p>the result of combining all elements of the source,
        or the defined <code>Monoid.empty</code> element in case the
        stream is empty</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#foldL[AA&gt;:A](implicitA:cats.Monoid[AA]):monix.eval.Task[AA]" name="monix.reactive.Observable#foldL" id="monix.reactive.Observable#foldL" class="extmbr">foldL</a> for the version that returns a
     task instead of an observable.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#foldL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foldL[AA&gt;:A](implicitA:cats.Monoid[AA]):monix.eval.Task[AA]"></a><a id="foldL[AA&gt;:A](Monoid[AA]):Task[AA]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#foldL[AA&gt;:A](implicitA:cats.Monoid[AA]):monix.eval.Task[AA]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foldL</span><span class="tparams">[<span name="AA">AA &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="A">A: <span name="cats.Monoid" class="extype">Monoid</span>[<span name="monix.reactive.Observable.foldL.AA" class="extype">AA</span>]</span>)</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="monix.reactive.Observable.foldL.AA" class="extype">AA</span>]</span></span><p class="shortcomment cmt">Given evidence that type <code>A</code> has a <code>cats.Monoid</code> implementation,
folds the stream with the provided monoid definition.</p><div class="fullcomment"><div class="comment cmt"><p>Given evidence that type <code>A</code> has a <code>cats.Monoid</code> implementation,
folds the stream with the provided monoid definition.</p><p>For streams emitting numbers, this effectively sums them up.
For strings, this concatenates them.</p><p>Example:</p><pre><span class="kw">import</span> cats.implicits._

<span class="cmt">// Yields 10</span>
<span class="kw">val</span> stream1 = Observable(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).foldL

<span class="cmt">// Yields "1234"</span>
<span class="kw">val</span> stream2 = Observable(<span class="lit">"1"</span>, <span class="lit">"2"</span>, <span class="lit">"3"</span>, <span class="lit">"4"</span>).foldL</pre></div><dl class="paramcmts block"><dt class="param">A</dt><dd class="cmt"><p>is the <code>cats.Monoid</code> type class instance that's needed
         in scope for folding the source</p></dd><dt>returns</dt><dd class="cmt"><p>the result of combining all elements of the source,
        or the defined <code>Monoid.empty</code> element in case the
        stream is empty</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#fold[AA&gt;:A](implicitA:cats.Monoid[AA]):monix.reactive.Observable[AA]" name="monix.reactive.Observable#fold" id="monix.reactive.Observable#fold" class="extmbr">fold</a> for the version that returns an observable
     instead of a task.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#foldLeft" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foldLeft[R](seed:=&gt;R)(op:(R,A)=&gt;R):monix.reactive.Observable[R]"></a><a id="foldLeft[R](=&gt;R)((R,A)=&gt;R):Observable[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#foldLeft[R](seed:=&gt;R)(op:(R,A)=&gt;R):monix.reactive.Observable[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foldLeft</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="seed">seed: =&gt; <span name="monix.reactive.Observable.foldLeft.R" class="extype">R</span></span>)</span><span class="params">(<span name="op">op: (<span name="monix.reactive.Observable.foldLeft.R" class="extype">R</span>, <span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.foldLeft.R" class="extype">R</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.foldLeft.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Applies a binary operator to a start value and all elements of
this Observable, going left to right and returns a new
Observable that emits only one item before <code>onComplete</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a binary operator to a start value and all elements of
this Observable, going left to right and returns a new
Observable that emits only one item before <code>onComplete</code>.
</p></div><dl class="paramcmts block"><dt class="param">seed</dt><dd class="cmt"><p>is the initial state, specified as a possibly lazy value;
       it gets evaluated when the subscription happens and if it triggers
       an error then the subscriber will get immediately terminated
       with an error</p></dd><dt class="param">op</dt><dd class="cmt"><p>is an operator that will fold the signals of the source
       observable, returning the next state</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#foldLeftL" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="foldLeftL[R](seed:=&gt;R)(op:(R,A)=&gt;R):monix.eval.Task[R]"></a><a id="foldLeftL[R](=&gt;R)((R,A)=&gt;R):Task[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#foldLeftL[R](seed:=&gt;R)(op:(R,A)=&gt;R):monix.eval.Task[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foldLeftL</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="seed">seed: =&gt; <span name="monix.reactive.Observable.foldLeftL.R" class="extype">R</span></span>)</span><span class="params">(<span name="op">op: (<span name="monix.reactive.Observable.foldLeftL.R" class="extype">R</span>, <span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.foldLeftL.R" class="extype">R</span></span>)</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="monix.reactive.Observable.foldLeftL.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Applies a binary operator to a start value and all elements of
the source, going left to right and returns a new <code>Task</code> that
upon evaluation will eventually emit the final result.</p></li><li class="indented0 " name="monix.reactive.Observable#foldWhileLeft" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foldWhileLeft[S](seed:=&gt;S)(op:(S,A)=&gt;Either[S,S]):monix.reactive.Observable[S]"></a><a id="foldWhileLeft[S](=&gt;S)((S,A)=&gt;Either[S,S]):Observable[S]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#foldWhileLeft[S](seed:=&gt;S)(op:(S,A)=&gt;Either[S,S]):monix.reactive.Observable[S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foldWhileLeft</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: =&gt; <span name="monix.reactive.Observable.foldWhileLeft.S" class="extype">S</span></span>)</span><span class="params">(<span name="op">op: (<span name="monix.reactive.Observable.foldWhileLeft.S" class="extype">S</span>, <span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="scala.Either" class="extype">Either</span>[<span name="monix.reactive.Observable.foldWhileLeft.S" class="extype">S</span>, <span name="monix.reactive.Observable.foldWhileLeft.S" class="extype">S</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.foldWhileLeft.S" class="extype">S</span>]</span></span><p class="shortcomment cmt">Folds the source observable, from start to finish, until the
source completes, or until the operator short-circuits the
process by returning <code>false</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Folds the source observable, from start to finish, until the
source completes, or until the operator short-circuits the
process by returning <code>false</code>.</p><p>Note that a call to <a href="#foldLeft[R](seed:=&gt;R)(op:(R,A)=&gt;R):monix.reactive.Observable[R]" name="monix.reactive.Observable#foldLeft" id="monix.reactive.Observable#foldLeft" class="extmbr">foldLeft</a> is equivalent to this function
being called with an operator always returning <code>true</code> as the first
member of its result.</p><p>Example: </p><pre><span class="cmt">// Sums first 10 items</span>
<span class="kw">val</span> stream1 = Observable.range(<span class="num">0</span>, <span class="num">1000</span>).foldWhileLeft((<span class="num">0</span>L, <span class="num">0</span>)) {
  <span class="kw">case</span> ((sum, count), e) <span class="kw">=&gt;</span>
    <span class="kw">val</span> next = (sum + e, count + <span class="num">1</span>)
    <span class="kw">if</span> (count + <span class="num">1</span> &lt; <span class="num">10</span>) Left(next) <span class="kw">else</span> Right(next)
}

<span class="cmt">// Implements exists(predicate)</span>
<span class="kw">val</span> stream2 = Observable(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).foldWhileLeft(<span class="kw">false</span>) {
  (default, e) <span class="kw">=&gt;</span>
    <span class="kw">if</span> (e == <span class="num">3</span>) Right(<span class="kw">true</span>) <span class="kw">else</span> Left(default)
}

<span class="cmt">// Implements forall(predicate)</span>
<span class="kw">val</span> stream3 = Observable(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).foldWhileLeft(<span class="kw">true</span>) {
  (default, e) <span class="kw">=&gt;</span>
    <span class="kw">if</span> (e != <span class="num">3</span>) Right(<span class="kw">false</span>) <span class="kw">else</span> Left(default)
}</pre></div><dl class="paramcmts block"><dt class="param">seed</dt><dd class="cmt"><p>is the initial state, specified as a possibly lazy value;
       it gets evaluated when the subscription happens and if it
       triggers an error then the subscriber will get immediately
       terminated with an error</p></dd><dt class="param">op</dt><dd class="cmt"><p>is the binary operator returning either <code>Left</code>,
       signaling that the state should be evolved or a <code>Right</code>,
       signaling that the process can be short-circuited and
       the result returned immediately</p></dd><dt>returns</dt><dd class="cmt"><p>the result of inserting <code>op</code> between consecutive
        elements of this observable, going from left to right with
        the <code>seed</code> as the start value, or <code>seed</code> if the observable
        is empty</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#foldWhileLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;Either[S,S]):monix.eval.Task[S]" name="monix.reactive.Observable#foldWhileLeftL" id="monix.reactive.Observable#foldWhileLeftL" class="extmbr">foldWhileLeftL</a> for a version
     that returns a task instead of an observable.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#foldWhileLeftL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foldWhileLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;Either[S,S]):monix.eval.Task[S]"></a><a id="foldWhileLeftL[S](=&gt;S)((S,A)=&gt;Either[S,S]):Task[S]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#foldWhileLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;Either[S,S]):monix.eval.Task[S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foldWhileLeftL</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: =&gt; <span name="monix.reactive.Observable.foldWhileLeftL.S" class="extype">S</span></span>)</span><span class="params">(<span name="op">op: (<span name="monix.reactive.Observable.foldWhileLeftL.S" class="extype">S</span>, <span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="scala.Either" class="extype">Either</span>[<span name="monix.reactive.Observable.foldWhileLeftL.S" class="extype">S</span>, <span name="monix.reactive.Observable.foldWhileLeftL.S" class="extype">S</span>]</span>)</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="monix.reactive.Observable.foldWhileLeftL.S" class="extype">S</span>]</span></span><p class="shortcomment cmt">Folds the source observable, from start to finish, until the
source completes, or until the operator short-circuits the
process by returning <code>false</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Folds the source observable, from start to finish, until the
source completes, or until the operator short-circuits the
process by returning <code>false</code>.</p><p>Note that a call to <a href="#foldLeftL[R](seed:=&gt;R)(op:(R,A)=&gt;R):monix.eval.Task[R]" name="monix.reactive.Observable#foldLeftL" id="monix.reactive.Observable#foldLeftL" class="extmbr">foldLeftL</a> is equivalent to this function
being called with an operator always returning <code>Left</code> results.</p><p>Example: </p><pre><span class="cmt">// Sums first 10 items</span>
<span class="kw">val</span> stream1 = Observable.range(<span class="num">0</span>, <span class="num">1000</span>).foldWhileLeftL((<span class="num">0</span>L, <span class="num">0</span>)) {
  <span class="kw">case</span> ((sum, count), e) <span class="kw">=&gt;</span>
    <span class="kw">val</span> next = (sum + e, count + <span class="num">1</span>)
    <span class="kw">if</span> (count + <span class="num">1</span> &lt; <span class="num">10</span>) Left(next) <span class="kw">else</span> Right(next)
}

<span class="cmt">// Implements exists(predicate)</span>
<span class="kw">val</span> stream2 = Observable(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).foldWhileLeftL(<span class="kw">false</span>) {
  (default, e) <span class="kw">=&gt;</span>
    <span class="kw">if</span> (e == <span class="num">3</span>) Right(<span class="kw">true</span>) <span class="kw">else</span> Left(default)
}

<span class="cmt">// Implements forall(predicate)</span>
<span class="kw">val</span> stream3 = Observable(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).foldWhileLeftL(<span class="kw">true</span>) {
  (default, e) <span class="kw">=&gt;</span>
    <span class="kw">if</span> (e != <span class="num">3</span>) Right(<span class="kw">false</span>) <span class="kw">else</span> Left(default)
}</pre></div><dl class="paramcmts block"><dt class="param">seed</dt><dd class="cmt"><p>is the initial state, specified as a possibly lazy value;
       it gets evaluated when the subscription happens and if it
       triggers an error then the subscriber will get immediately
       terminated with an error</p></dd><dt class="param">op</dt><dd class="cmt"><p>is the binary operator returning either <code>Left</code>,
       signaling that the state should be evolved or a <code>Right</code>,
       signaling that the process can be short-circuited and
       the result returned immediately</p></dd><dt>returns</dt><dd class="cmt"><p>the result of inserting <code>op</code> between consecutive
        elements of this observable, going from left to right with
        the <code>seed</code> as the start value, or <code>seed</code> if the observable
        is empty</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#foldWhileLeft[S](seed:=&gt;S)(op:(S,A)=&gt;Either[S,S]):monix.reactive.Observable[S]" name="monix.reactive.Observable#foldWhileLeft" id="monix.reactive.Observable#foldWhileLeft" class="extmbr">foldWhileLeft</a> for a version that returns an observable
     instead of a task.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#forall" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="forall(p:A=&gt;Boolean):monix.reactive.Observable[Boolean]"></a><a id="forall((A)=&gt;Boolean):Observable[Boolean]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#forall(p:A=&gt;Boolean):monix.reactive.Observable[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">forall</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Returns an Observable that emits a single boolean, either true, in
case the given predicate holds for all the items emitted by the
source, or false in case at least one item is not verifying the
given predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits a single boolean, either true, in
case the given predicate holds for all the items emitted by the
source, or false in case at least one item is not verifying the
given predicate.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is a function that evaluates the items emitted by the source
       Observable, returning <code>true</code> if they pass the filter</p></dd><dt>returns</dt><dd class="cmt"><p>an Observable that emits only true or false in case the given
        predicate holds or not for all the items</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#forallL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="forallL(p:A=&gt;Boolean):monix.eval.Task[Boolean]"></a><a id="forallL((A)=&gt;Boolean):Task[Boolean]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#forallL(p:A=&gt;Boolean):monix.eval.Task[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">forallL</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Returns a <code>Task</code> that emits a single boolean, either true, in
case the given predicate holds for all the items emitted by the
source, or false in case at least one item is not verifying the
given predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <code>Task</code> that emits a single boolean, either true, in
case the given predicate holds for all the items emitted by the
source, or false in case at least one item is not verifying the
given predicate.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is a function that evaluates the items emitted by the source
       observable, returning <code>true</code> if they pass the filter</p></dd><dt>returns</dt><dd class="cmt"><p>a task that emits only true or false in case the given
        predicate holds or not for all the items</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#foreach" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foreach(cb:A=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.CancelableFuture[Unit]"></a><a id="foreach((A)=&gt;Unit)(Scheduler):CancelableFuture[Unit]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#foreach(cb:A=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.CancelableFuture[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foreach</span><span class="params">(<span name="cb">cb: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="../execution/CancelableFuture.html" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Subscribes to the source <code>Observable</code> and foreach element emitted
by the source it executes the given callback.</p><div class="fullcomment"><div class="comment cmt"><p>Subscribes to the source <code>Observable</code> and foreach element emitted
by the source it executes the given callback.
</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#foreachL" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="foreachL(cb:A=&gt;Unit):monix.eval.Task[Unit]"></a><a id="foreachL((A)=&gt;Unit):Task[Unit]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#foreachL(cb:A=&gt;Unit):monix.eval.Task[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foreachL</span><span class="params">(<span name="cb">cb: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Creates a new <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> that will consume the
source observable, executing the given callback for each element.</p></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]"></a><a id="getClass():Class[_&lt;:AnyRef]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html#java.lang.Class" name="java.lang.Class" id="java.lang.Class" class="extype">Class</a>[_ &lt;: <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#groupBy" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="groupBy[K](keySelector:A=&gt;K)(implicitos:monix.reactive.OverflowStrategy.Synchronous[Nothing]):monix.reactive.Observable[monix.reactive.observables.GroupedObservable[K,A]]"></a><a id="groupBy[K]((A)=&gt;K)(Synchronous[Nothing]):Observable[GroupedObservable[K,A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#groupBy[K](keySelector:A=&gt;K)(implicitos:monix.reactive.OverflowStrategy.Synchronous[Nothing]):monix.reactive.Observable[monix.reactive.observables.GroupedObservable[K,A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">groupBy</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="keySelector">keySelector: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.groupBy.K" class="extype">K</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="os">os: <a href="OverflowStrategy$$Synchronous.html" name="monix.reactive.OverflowStrategy.Synchronous" id="monix.reactive.OverflowStrategy.Synchronous" class="extype">Synchronous</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Nothing.html#scala.Nothing" name="scala.Nothing" id="scala.Nothing" class="extype">Nothing</a>] = <span class="symbol"><span class="name"><a href="OverflowStrategy$.html">OverflowStrategy.Unbounded</a></span></span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<a href="observables/GroupedObservable.html" name="monix.reactive.observables.GroupedObservable" id="monix.reactive.observables.GroupedObservable" class="extype">GroupedObservable</a>[<span name="monix.reactive.Observable.groupBy.K" class="extype">K</span>, <span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Groups the items emitted by an Observable according to a specified
criterion, and emits these grouped items as GroupedObservables,
one GroupedObservable per group.</p><div class="fullcomment"><div class="comment cmt"><p>Groups the items emitted by an Observable according to a specified
criterion, and emits these grouped items as GroupedObservables,
one GroupedObservable per group.</p><p>Note: A <a href="observables/GroupedObservable.html" name="monix.reactive.observables.GroupedObservable" id="monix.reactive.observables.GroupedObservable" class="extype">GroupedObservable</a>
will cache the items it is to emit until such time as it is
subscribed to. For this reason, in order to avoid memory leaks,
you should not simply ignore those GroupedObservables that do
not concern you. Instead, you can signal to them that they may
discard their buffers by doing something like <code>source.take(0)</code>.
</p></div><dl class="paramcmts block"><dt class="param">keySelector</dt><dd class="cmt"><p>a function that extracts the key for each item</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#guarantee" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="guarantee(f:monix.eval.Task[Unit]):monix.reactive.Observable[A]"></a><a id="guarantee(Task[Unit]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#guarantee(f:monix.eval.Task[Unit]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">guarantee</span><span class="params">(<span name="f">f: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Given a routine make sure to execute it whenever the current
stream reaches the end, successfully, in error, or canceled.</p><div class="fullcomment"><div class="comment cmt"><p>Given a routine make sure to execute it whenever the current
stream reaches the end, successfully, in error, or canceled.</p><p>Implements <code>cats.effect.Bracket.guarantee</code>.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

Observable.suspend(???).guarantee(Task.eval {
  println(<span class="lit">"Releasing resources!"</span>)
})</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the function to execute on early stop</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#guaranteeCase" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="guaranteeCase(f:cats.effect.ExitCase[Throwable]=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]"></a><a id="guaranteeCase((ExitCase[Throwable])=&gt;Task[Unit]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#guaranteeCase(f:cats.effect.ExitCase[Throwable]=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">guaranteeCase</span><span class="params">(<span name="f">f: (<span name="cats.effect.ExitCase" class="extype">ExitCase</span>[<span name="scala.Throwable" class="extype">Throwable</span>]) =&gt; <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns a new <code>Observable</code> in which <code>f</code> is scheduled to be executed
when the source is completed, in success, error or when cancelled.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new <code>Observable</code> in which <code>f</code> is scheduled to be executed
when the source is completed, in success, error or when cancelled.</p><p>Implements <code>cats.effect.Bracket.guaranteeCase</code>.</p><p>This would typically be used to ensure that a finalizer
will run at the end of the stream.</p><p>Example: </p><pre><span class="kw">import</span> cats.effect.ExitCase
<span class="kw">import</span> monix.eval.Task

<span class="kw">val</span> stream = Observable.suspend(???).guaranteeCase(err <span class="kw">=&gt;</span> Task {
  err <span class="kw">match</span> {
    <span class="kw">case</span> ExitCase.Completed <span class="kw">=&gt;</span>
      println(<span class="lit">"Completed successfully!"</span>)
    <span class="kw">case</span> ExitCase.Error(e) <span class="kw">=&gt;</span>
      e.printStackTrace()
    <span class="kw">case</span> ExitCase.Canceled <span class="kw">=&gt;</span>
      println(<span class="lit">"Was stopped early!"</span>)
  }
})</pre><p>NOTE this is using <code>cats.effect.ExitCase</code> to signal the termination
condition, like this:</p><ul><li>if completed via <code>onComplete</code> or via <code>Stop</code> signalled by the
    consumer, then the function receives <code>ExitCase.Completed</code></li><li>if completed via <code>onError</code> or in certain cases in which errors
    are detected (e.g. the consumer returns an error), then the function
    receives <code>ExitCase.Error(e)</code></li><li>if the subscription was cancelled, then the function receives
    <code>ExitCase.Canceled</code></li></ul><p>In other words <code>Completed</code> is for normal termination conditions,
<code>Error</code> is for exceptions being detected and <code>Canceled</code> is for
when the subscription gets canceled.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the finalizer to execute when streaming is terminated, by
       successful completion, error or cancellation; for specifying the
       side effects to use</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#guaranteeCaseF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="guaranteeCaseF[F[_]](f:cats.effect.ExitCase[Throwable]=&gt;F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]"></a><a id="guaranteeCaseF[F[_]]((ExitCase[Throwable])=&gt;F[Unit])(TaskLike[F]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#guaranteeCaseF[F[_]](f:cats.effect.ExitCase[Throwable]=&gt;F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">guaranteeCaseF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span name="f">f: (<span name="cats.effect.ExitCase" class="extype">ExitCase</span>[<span name="scala.Throwable" class="extype">Throwable</span>]) =&gt; <span name="monix.reactive.Observable.guaranteeCaseF.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.guaranteeCaseF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Version of <a href="#guaranteeCase(f:cats.effect.ExitCase[Throwable]=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#guaranteeCase" id="monix.reactive.Observable#guaranteeCase" class="extmbr">guaranteeCase</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#guaranteeCase(f:cats.effect.ExitCase[Throwable]=&gt;monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#guaranteeCase" id="monix.reactive.Observable#guaranteeCase" class="extmbr">guaranteeCase</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><p>So you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...
</li></ul></div></div></li><li class="indented0 " name="monix.reactive.Observable#guaranteeF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="guaranteeF[F[_]](f:F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]"></a><a id="guaranteeF[F[_]](F[Unit])(TaskLike[F]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#guaranteeF[F[_]](f:F[Unit])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">guaranteeF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span name="f">f: <span name="monix.reactive.Observable.guaranteeF.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.guaranteeF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Version of <a href="#guarantee(f:monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#guarantee" id="monix.reactive.Observable#guarantee" class="extmbr">guarantee</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#guarantee(f:monix.eval.Task[Unit]):monix.reactive.Observable[A]" name="monix.reactive.Observable#guarantee" id="monix.reactive.Observable#guarantee" class="extmbr">guarantee</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><p>So you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...
</li></ul></div></div></li><li class="indented0 " name="scala.AnyRef#hashCode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hashCode():Int"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#hashCode():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#head" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="head:monix.reactive.Observable[A]"></a><a id="head:Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#head:monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">head</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Only emits the first element emitted by the source observable,
after which it's completed immediately.</p></li><li class="indented0 " name="monix.reactive.Observable#headL" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="headL:monix.eval.Task[A]"></a><a id="headL:Task[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#headL:monix.eval.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">headL</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Alias for <a href="#firstL:monix.eval.Task[A]" name="monix.reactive.Observable#firstL" id="monix.reactive.Observable#firstL" class="extmbr">firstL</a>.</p></li><li class="indented0 " name="monix.reactive.Observable#headOptionL" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="headOptionL:monix.eval.Task[Option[A]]"></a><a id="headOptionL:Task[Option[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#headOptionL:monix.eval.Task[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">headOptionL</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Alias for <a href="#firstOptionL:monix.eval.Task[Option[A]]" name="monix.reactive.Observable#firstOptionL" id="monix.reactive.Observable#firstOptionL" class="extmbr">firstOptionL</a>.</p></li><li class="indented0 " name="monix.reactive.Observable#headOrElse" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="headOrElse[B&gt;:A](default:=&gt;B):monix.reactive.Observable[B]"></a><a id="headOrElse[B&gt;:A](=&gt;B):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#headOrElse[B&gt;:A](default:=&gt;B):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">headOrElse</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="default">default: =&gt; <span name="monix.reactive.Observable.headOrElse.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.headOrElse.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Emits the first element emitted by the source, or otherwise if the
source is completed without emitting anything, then the
<code>default</code> is emitted.</p></li><li class="indented0 " name="monix.reactive.Observable#headOrElseL" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="headOrElseL[B&gt;:A](default:=&gt;B):monix.eval.Task[B]"></a><a id="headOrElseL[B&gt;:A](=&gt;B):Task[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#headOrElseL[B&gt;:A](default:=&gt;B):monix.eval.Task[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">headOrElseL</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="default">default: =&gt; <span name="monix.reactive.Observable.headOrElseL.B" class="extype">B</span></span>)</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="monix.reactive.Observable.headOrElseL.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Alias for <a href="#firstOrElseL[B&gt;:A](default:=&gt;B):monix.eval.Task[B]" name="monix.reactive.Observable#firstOrElseL" id="monix.reactive.Observable#firstOrElseL" class="extmbr">firstOrElseL</a>.</p></li><li class="indented0 " name="monix.reactive.Observable#ignoreElements" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ignoreElements:monix.reactive.Observable[Nothing]"></a><a id="ignoreElements:Observable[Nothing]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#ignoreElements:monix.reactive.Observable[Nothing]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ignoreElements</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Nothing.html#scala.Nothing" name="scala.Nothing" id="scala.Nothing" class="extype">Nothing</a>]</span></span><p class="shortcomment cmt">Alias for <a href="#completed:monix.reactive.Observable[Nothing]" name="monix.reactive.Observable#completed" id="monix.reactive.Observable#completed" class="extmbr">completed</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Alias for <a href="#completed:monix.reactive.Observable[Nothing]" name="monix.reactive.Observable#completed" id="monix.reactive.Observable#completed" class="extmbr">completed</a>. Ignores all items emitted by
the source and only calls onCompleted or onError.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an empty sequence that only calls onCompleted or onError,
        based on which one is called by the source Observable</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#interleave" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="interleave[B&gt;:A](other:monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="interleave[B&gt;:A](Observable[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#interleave[B&gt;:A](other:monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">interleave</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="other">other: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.interleave.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.interleave.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new observable from this observable and another given
observable by interleaving their items into a strictly
alternating sequence.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new observable from this observable and another given
observable by interleaving their items into a strictly
alternating sequence.</p><p>So the first item emitted by the new observable will be the item
emitted by <code>self</code>, the second item will be emitted by the other
observable, and so forth; when either <code>self</code> or <code>other</code> calls
<code>onCompletes</code>, the items will then be directly coming from the
observable that has not completed; when <code>onError</code> is called by
either <code>self</code> or <code>other</code>, the new observable will call <code>onError</code>
and halt.</p><p>See <a href="#merge[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B],implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#merge" id="monix.reactive.Observable#merge" class="extmbr">merge</a> for a more relaxed alternative that doesn't emit
items in strict alternating sequence.
</p></div><dl class="paramcmts block"><dt class="param">other</dt><dd class="cmt"><p>is an observable that interleaves with the source</p></dd><dt>returns</dt><dd class="cmt"><p>a new observable sequence that alternates emission of
        the items from both child streams</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#intersperse" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="intersperse[B&gt;:A](start:B,separator:B,end:B):monix.reactive.Observable[B]"></a><a id="intersperse[B&gt;:A](B,B,B):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#intersperse[B&gt;:A](start:B,separator:B,end:B):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">intersperse</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="start">start: <span name="monix.reactive.Observable.intersperse.B" class="extype">B</span></span>, <span name="separator">separator: <span name="monix.reactive.Observable.intersperse.B" class="extype">B</span></span>, <span name="end">end: <span name="monix.reactive.Observable.intersperse.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.intersperse.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new observable from this observable that will emit the <code>start</code> element
followed by the upstream elements paired with the <code>separator</code>, and lastly the <code>end</code> element.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new observable from this observable that will emit the <code>start</code> element
followed by the upstream elements paired with the <code>separator</code>, and lastly the <code>end</code> element.</p><p>Usage sample:</p><pre><span class="cmt">// Yields "begin a : b : c : d end"</span>
Observable(<span class="lit">"a"</span>, <span class="lit">"b"</span>, <span class="lit">"c"</span>, <span class="lit">"d"</span>)
  .intersperse(<span class="lit">"begin "</span>, <span class="lit">" : "</span>, <span class="lit">" end"</span>)
  .foldLeftL(<span class="lit">""</span>)(_ ++ _)</pre></div><dl class="paramcmts block"><dt class="param">start</dt><dd class="cmt"><p>is the first element emitted</p></dd><dt class="param">separator</dt><dd class="cmt"><p>is the separator</p></dd><dt class="param">end</dt><dd class="cmt"><p>the last element emitted</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#intersperse" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="intersperse[B&gt;:A](separator:B):monix.reactive.Observable[B]"></a><a id="intersperse[B&gt;:A](B):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#intersperse[B&gt;:A](separator:B):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">intersperse</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="separator">separator: <span name="monix.reactive.Observable.intersperse.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.intersperse.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new observable from this observable that will emit a specific <code>separator</code>
between every pair of elements.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new observable from this observable that will emit a specific <code>separator</code>
between every pair of elements.</p><p>Usage sample:</p><pre><span class="cmt">// Yields "a : b : c : d"</span>
Observable(<span class="lit">"a"</span>, <span class="lit">"b"</span>, <span class="lit">"c"</span>, <span class="lit">"d"</span>)
  .intersperse(<span class="lit">" : "</span>)
  .foldLeftL(<span class="lit">""</span>)(_ ++ _)</pre></div><dl class="paramcmts block"><dt class="param">separator</dt><dd class="cmt"><p>is the separator</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#isEmpty" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="isEmpty:monix.reactive.Observable[Boolean]"></a><a id="isEmpty:Observable[Boolean]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#isEmpty:monix.reactive.Observable[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isEmpty</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Returns an Observable that emits true if the source Observable is
empty, otherwise false.</p></li><li class="indented0 " name="monix.reactive.Observable#isEmptyL" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="isEmptyL:monix.eval.Task[Boolean]"></a><a id="isEmptyL:Task[Boolean]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#isEmptyL:monix.eval.Task[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isEmptyL</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Returns a task that emits <code>true</code> if the source observable is
empty, otherwise <code>false</code>.</p></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#last" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="last:monix.reactive.Observable[A]"></a><a id="last:Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#last:monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">last</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Only emits the last element emitted by the source observable,
after which it's completed immediately.</p></li><li class="indented0 " name="monix.reactive.Observable#lastL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lastL:monix.eval.Task[A]"></a><a id="lastL:Task[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#lastL:monix.eval.Task[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lastL</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns a <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> that upon execution
will signal the last generated element of the source observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> that upon execution
will signal the last generated element of the source observable.</p><p>In case the stream was empty, then the <code>Task</code> gets completed
in error with a <code>NoSuchElementException</code>.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#lastOptionL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lastOptionL:monix.eval.Task[Option[A]]"></a><a id="lastOptionL:Task[Option[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#lastOptionL:monix.eval.Task[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lastOptionL</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Returns a <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> that upon execution
will signal the last generated element of the source observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> that upon execution
will signal the last generated element of the source observable.</p><p>Returns an <code>Option</code> because the source can be empty.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#lastOrElseL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lastOrElseL[B&gt;:A](default:=&gt;B):monix.eval.Task[B]"></a><a id="lastOrElseL[B&gt;:A](=&gt;B):Task[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#lastOrElseL[B&gt;:A](default:=&gt;B):monix.eval.Task[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lastOrElseL</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="default">default: =&gt; <span name="monix.reactive.Observable.lastOrElseL.B" class="extype">B</span></span>)</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="monix.reactive.Observable.lastOrElseL.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> that upon execution
will signal the last generated element of the source observable.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> that upon execution
will signal the last generated element of the source observable.</p><p>In case the stream was empty, then the given default gets
evaluated and emitted.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#liftByOperator" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="liftByOperator[B](operator:monix.reactive.Observable.Operator[A,B]):monix.reactive.Observable[B]"></a><a id="liftByOperator[B](Operator[A,B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#liftByOperator[B](operator:monix.reactive.Observable.Operator[A,B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">liftByOperator</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="operator">operator: <a href="Observable$.html#Operator[-I,+O]=monix.reactive.observers.Subscriber[O]=&gt;monix.reactive.observers.Subscriber[I]" name="monix.reactive.Observable.Operator" id="monix.reactive.Observable.Operator" class="extmbr">Operator</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>, <span name="monix.reactive.Observable.liftByOperator.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.liftByOperator.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Transforms the source using the given operator.</p></li><li class="indented0 " name="monix.reactive.Observable#map" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="map[B](f:A=&gt;B):monix.reactive.Observable[B]"></a><a id="map[B]((A)=&gt;B):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#map[B](f:A=&gt;B):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">map</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.map.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.map.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a new observable that applies the given function
to each item emitted by the source and emits the result.</p></li><li class="indented0 " name="monix.reactive.Observable#mapAccumulate" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mapAccumulate[S,R](seed:=&gt;S)(op:(S,A)=&gt;(S,R)):monix.reactive.Observable[R]"></a><a id="mapAccumulate[S,R](=&gt;S)((S,A)=&gt;(S,R)):Observable[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#mapAccumulate[S,R](seed:=&gt;S)(op:(S,A)=&gt;(S,R)):monix.reactive.Observable[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mapAccumulate</span><span class="tparams">[<span name="S">S</span>, <span name="R">R</span>]</span><span class="params">(<span name="seed">seed: =&gt; <span name="monix.reactive.Observable.mapAccumulate.S" class="extype">S</span></span>)</span><span class="params">(<span name="op">op: (<span name="monix.reactive.Observable.mapAccumulate.S" class="extype">S</span>, <span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; (<span name="monix.reactive.Observable.mapAccumulate.S" class="extype">S</span>, <span name="monix.reactive.Observable.mapAccumulate.R" class="extype">R</span>)</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.mapAccumulate.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Applies a binary operator to a start value and all elements of
this Observable, going left to right and returns a new
Observable that emits on each step the result element of
the applied function.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a binary operator to a start value and all elements of
this Observable, going left to right and returns a new
Observable that emits on each step the result element of
the applied function.</p><p>Similar to <a href="#scan[S](seed:=&gt;S)(op:(S,A)=&gt;S):monix.reactive.Observable[S]" name="monix.reactive.Observable#scan" id="monix.reactive.Observable#scan" class="extmbr">scan</a>, but the supplied function returns a tuple
of the next accumulator state and the result type emitted by
the returned observable.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#mapEval" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mapEval[B](f:A=&gt;monix.eval.Task[B]):monix.reactive.Observable[B]"></a><a id="mapEval[B]((A)=&gt;Task[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#mapEval[B](f:A=&gt;monix.eval.Task[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mapEval</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="monix.reactive.Observable.mapEval.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.mapEval.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Maps elements from the source using a function that can do
asynchronous processing by means of <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Maps elements from the source using a function that can do
asynchronous processing by means of <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>.</p><p>Example:</p><pre><span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> scala.concurrent.duration._

Observable.range(<span class="num">0</span>, <span class="num">100</span>)
  .mapEval(x <span class="kw">=&gt;</span> Task(x).delayExecution(<span class="num">1.</span>second))</pre></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#mapEvalF[F[_],B](f:A=&gt;F[B])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapEvalF" id="monix.reactive.Observable#mapEvalF" class="extmbr">mapEvalF</a> for a version that works with a generic
     <code>F[_]</code> (e.g. <code>cats.effect.IO</code>, Scala's <code>Future</code>),
     powered by <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a></p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#mapEvalF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mapEvalF[F[_],B](f:A=&gt;F[B])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[B]"></a><a id="mapEvalF[F[_],B]((A)=&gt;F[B])(TaskLike[F]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#mapEvalF[F[_],B](f:A=&gt;F[B])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mapEvalF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.mapEvalF.F" class="extype">F</span>[<span name="monix.reactive.Observable.mapEvalF.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.mapEvalF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.mapEvalF.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Version of <a href="#mapEval[B](f:A=&gt;monix.eval.Task[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapEval" id="monix.reactive.Observable#mapEval" class="extmbr">mapEval</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#mapEval[B](f:A=&gt;monix.eval.Task[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapEval" id="monix.reactive.Observable#mapEval" class="extmbr">mapEval</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><p>So you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...</li></ul><p>Example:</p><pre><span class="kw">import</span> cats.implicits._
<span class="kw">import</span> cats.effect.IO
<span class="kw">import</span> cats.effect.Timer
<span class="kw">import</span> scala.concurrent.duration._
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global
<span class="kw">import</span> monix.catnap.SchedulerEffect
<span class="cmt">// Needed for IO.sleep</span>
<span class="kw">implicit</span> <span class="kw">val</span> timer: Timer[IO] = SchedulerEffect.timerLiftIO[IO](global)

Observable.range(<span class="num">0</span>, <span class="num">100</span>).mapEvalF { x <span class="kw">=&gt;</span>
  IO.sleep(<span class="num">1.</span>second) *&gt; IO(x)
}</pre></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#mapEval[B](f:A=&gt;monix.eval.Task[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapEval" id="monix.reactive.Observable#mapEval" class="extmbr">mapEval</a> for a version specialized for
     <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a></p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#mapParallelOrdered" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mapParallelOrdered[B](parallelism:Int)(f:A=&gt;monix.eval.Task[B])(implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]"></a><a id="mapParallelOrdered[B](Int)((A)=&gt;Task[B])(OverflowStrategy[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#mapParallelOrdered[B](parallelism:Int)(f:A=&gt;monix.eval.Task[B])(implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mapParallelOrdered</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="parallelism">parallelism: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="monix.reactive.Observable.mapParallelOrdered.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="os">os: <a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a>[<span name="monix.reactive.Observable.mapParallelOrdered.B" class="extype">B</span>] = <span class="symbol"><span class="name"><a href="OverflowStrategy$.html">OverflowStrategy.Default</a></span></span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.mapParallelOrdered.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Given a mapping function that maps events to <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">tasks</a>,
applies it in parallel on the source, but with a specified
<code>parallelism</code>, which indicates the maximum number of tasks that
can be executed in parallel returning them preserving original order.</p><div class="fullcomment"><div class="comment cmt"><p>Given a mapping function that maps events to <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">tasks</a>,
applies it in parallel on the source, but with a specified
<code>parallelism</code>, which indicates the maximum number of tasks that
can be executed in parallel returning them preserving original order.</p><p>Similar in spirit with
<a href="Consumer$.html#loadBalance[A,R](parallelism:Int,consumer:monix.reactive.Consumer[A,R]):monix.reactive.Consumer[A,List[R]]" name="monix.reactive.Consumer#loadBalance" id="monix.reactive.Consumer#loadBalance" class="extmbr">Consumer.loadBalance</a>,
but expressed as an operator that executes <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>
instances in parallel.</p><p>Note that when the specified <code>parallelism</code> is 1, it has the same
behavior as <a href="#mapEval[B](f:A=&gt;monix.eval.Task[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapEval" id="monix.reactive.Observable#mapEval" class="extmbr">mapEval</a>.
</p></div><dl class="paramcmts block"><dt class="param">parallelism</dt><dd class="cmt"><p>is the maximum number of tasks that can be executed
       in parallel, over which the source starts being
       back-pressured</p></dd><dt class="param">f</dt><dd class="cmt"><p>is the mapping function that produces tasks to execute
       in parallel, which will eventually produce events for the
       resulting observable stream</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#mapParallelUnordered[B](parallelism:Int)(f:A=&gt;monix.eval.Task[B])(implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapParallelUnordered" id="monix.reactive.Observable#mapParallelUnordered" class="extmbr">mapParallelUnordered</a> for a variant that does not preserve order
    which may lead to faster execution times</p></span><span class="cmt"><p><a href="#mapEval[B](f:A=&gt;monix.eval.Task[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapEval" id="monix.reactive.Observable#mapEval" class="extmbr">mapEval</a> for serial execution</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#mapParallelOrderedF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mapParallelOrderedF[F[_],B](parallelism:Int)(f:A=&gt;F[B])(implicitos:monix.reactive.OverflowStrategy[B],implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[B]"></a><a id="mapParallelOrderedF[F[_],B](Int)((A)=&gt;F[B])(OverflowStrategy[B],TaskLike[F]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#mapParallelOrderedF[F[_],B](parallelism:Int)(f:A=&gt;F[B])(implicitos:monix.reactive.OverflowStrategy[B],implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mapParallelOrderedF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="B">B</span>]</span><span class="params">(<span name="parallelism">parallelism: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.mapParallelOrderedF.F" class="extype">F</span>[<span name="monix.reactive.Observable.mapParallelOrderedF.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="os">os: <a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a>[<span name="monix.reactive.Observable.mapParallelOrderedF.B" class="extype">B</span>] = <span class="symbol"><span class="name"><a href="OverflowStrategy$.html">OverflowStrategy.Default</a></span></span></span>, <span name="F">F: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.mapParallelOrderedF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.mapParallelOrderedF.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Version of <a href="#mapParallelOrderedF[F[_],B](parallelism:Int)(f:A=&gt;F[B])(implicitos:monix.reactive.OverflowStrategy[B],implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapParallelOrderedF" id="monix.reactive.Observable#mapParallelOrderedF" class="extmbr">mapParallelOrderedF</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#mapParallelOrderedF[F[_],B](parallelism:Int)(f:A=&gt;F[B])(implicitos:monix.reactive.OverflowStrategy[B],implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapParallelOrderedF" id="monix.reactive.Observable#mapParallelOrderedF" class="extmbr">mapParallelOrderedF</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><p>So you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...
</li></ul></div><dl class="paramcmts block"><dt class="param">parallelism</dt><dd class="cmt"><p>is the maximum number of tasks that can be executed
       in parallel, over which the source starts being
       back-pressured</p></dd><dt class="param">f</dt><dd class="cmt"><p>is the mapping function that produces tasks to execute
       in parallel, which will eventually produce events for the
       resulting observable stream</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#mapParallelUnorderedF[F[_],B](parallelism:Int)(f:A=&gt;F[B])(implicitos:monix.reactive.OverflowStrategy[B],implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapParallelUnorderedF" id="monix.reactive.Observable#mapParallelUnorderedF" class="extmbr">mapParallelUnorderedF</a> for a variant that does not preserve order
    which may lead to faster execution times</p></span><span class="cmt"><p><a href="#mapEvalF[F[_],B](f:A=&gt;F[B])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapEvalF" id="monix.reactive.Observable#mapEvalF" class="extmbr">mapEvalF</a> for serial execution</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#mapParallelUnordered" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mapParallelUnordered[B](parallelism:Int)(f:A=&gt;monix.eval.Task[B])(implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]"></a><a id="mapParallelUnordered[B](Int)((A)=&gt;Task[B])(OverflowStrategy[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#mapParallelUnordered[B](parallelism:Int)(f:A=&gt;monix.eval.Task[B])(implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mapParallelUnordered</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="parallelism">parallelism: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="monix.reactive.Observable.mapParallelUnordered.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="os">os: <a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a>[<span name="monix.reactive.Observable.mapParallelUnordered.B" class="extype">B</span>] = <span class="symbol"><span class="name"><a href="OverflowStrategy$.html">OverflowStrategy.Default</a></span></span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.mapParallelUnordered.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Given a mapping function that maps events to <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">tasks</a>,
applies it in parallel on the source, but with a specified
<code>parallelism</code>, which indicates the maximum number of tasks that
can be executed in parallel.</p><div class="fullcomment"><div class="comment cmt"><p>Given a mapping function that maps events to <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">tasks</a>,
applies it in parallel on the source, but with a specified
<code>parallelism</code>, which indicates the maximum number of tasks that
can be executed in parallel.</p><p>Similar in spirit with
<a href="Consumer$.html#loadBalance[A,R](parallelism:Int,consumer:monix.reactive.Consumer[A,R]):monix.reactive.Consumer[A,List[R]]" name="monix.reactive.Consumer#loadBalance" id="monix.reactive.Consumer#loadBalance" class="extmbr">Consumer.loadBalance</a>,
but expressed as an operator that executes <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>
instances in parallel.</p><p>Note that when the specified <code>parallelism</code> is 1, it has the same
behavior as <a href="#mapEval[B](f:A=&gt;monix.eval.Task[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapEval" id="monix.reactive.Observable#mapEval" class="extmbr">mapEval</a>.
</p></div><dl class="paramcmts block"><dt class="param">parallelism</dt><dd class="cmt"><p>is the maximum number of tasks that can be executed
       in parallel, over which the source starts being
       back-pressured</p></dd><dt class="param">f</dt><dd class="cmt"><p>is the mapping function that produces tasks to execute
       in parallel, which will eventually produce events for the
       resulting observable stream</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#mapParallelOrdered[B](parallelism:Int)(f:A=&gt;monix.eval.Task[B])(implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapParallelOrdered" id="monix.reactive.Observable#mapParallelOrdered" class="extmbr">mapParallelOrdered</a> for a variant that does preserve order</p></span><span class="cmt"><p><a href="#mapEval[B](f:A=&gt;monix.eval.Task[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapEval" id="monix.reactive.Observable#mapEval" class="extmbr">mapEval</a> for serial execution</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#mapParallelUnorderedF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mapParallelUnorderedF[F[_],B](parallelism:Int)(f:A=&gt;F[B])(implicitos:monix.reactive.OverflowStrategy[B],implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[B]"></a><a id="mapParallelUnorderedF[F[_],B](Int)((A)=&gt;F[B])(OverflowStrategy[B],TaskLike[F]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#mapParallelUnorderedF[F[_],B](parallelism:Int)(f:A=&gt;F[B])(implicitos:monix.reactive.OverflowStrategy[B],implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mapParallelUnorderedF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="B">B</span>]</span><span class="params">(<span name="parallelism">parallelism: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.mapParallelUnorderedF.F" class="extype">F</span>[<span name="monix.reactive.Observable.mapParallelUnorderedF.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="os">os: <a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a>[<span name="monix.reactive.Observable.mapParallelUnorderedF.B" class="extype">B</span>] = <span class="symbol"><span class="name"><a href="OverflowStrategy$.html">OverflowStrategy.Default</a></span></span></span>, <span name="F">F: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.mapParallelUnorderedF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.mapParallelUnorderedF.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Version of <a href="#mapParallelUnordered[B](parallelism:Int)(f:A=&gt;monix.eval.Task[B])(implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapParallelUnordered" id="monix.reactive.Observable#mapParallelUnordered" class="extmbr">mapParallelUnordered</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#mapParallelUnordered[B](parallelism:Int)(f:A=&gt;monix.eval.Task[B])(implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapParallelUnordered" id="monix.reactive.Observable#mapParallelUnordered" class="extmbr">mapParallelUnordered</a> that can work with generic
<code>F[_]</code> tasks, anything that's supported via <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>
conversions.</p><p>So you can work among others with:</p><ul><li><code>cats.effect.IO</code></li><li><code>monix.eval.Coeval</code></li><li><code>scala.concurrent.Future</code></li><li>...
Note that when the specified <code>parallelism</code> is 1, it has the same
behavior as <a href="#mapEval[B](f:A=&gt;monix.eval.Task[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapEval" id="monix.reactive.Observable#mapEval" class="extmbr">mapEval</a>.
</li></ul></div><dl class="paramcmts block"><dt class="param">parallelism</dt><dd class="cmt"><p>is the maximum number of tasks that can be executed
       in parallel, over which the source starts being
       back-pressured</p></dd><dt class="param">f</dt><dd class="cmt"><p>is the mapping function that produces tasks to execute
       in parallel, which will eventually produce events for the
       resulting observable stream</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#mapParallelOrdered[B](parallelism:Int)(f:A=&gt;monix.eval.Task[B])(implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapParallelOrdered" id="monix.reactive.Observable#mapParallelOrdered" class="extmbr">mapParallelOrdered</a> for a variant that does preserve order</p></span><span class="cmt"><p><a href="#mapEval[B](f:A=&gt;monix.eval.Task[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mapEval" id="monix.reactive.Observable#mapEval" class="extmbr">mapEval</a> for serial execution</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#materialize" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="materialize:monix.reactive.Observable[monix.reactive.Notification[A]]"></a><a id="materialize:Observable[Notification[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#materialize:monix.reactive.Observable[monix.reactive.Notification[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">materialize</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<a href="Notification.html" name="monix.reactive.Notification" id="monix.reactive.Notification" class="extype">Notification</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Converts the source Observable that emits <code>A</code> into an Observable
that emits <code>Notification[A]</code>.</p></li><li class="indented0 " name="monix.reactive.Observable#max" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="max[AA&gt;:A](implicitA:cats.Order[AA]):monix.reactive.Observable[AA]"></a><a id="max[AA&gt;:A](Order[AA]):Observable[AA]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#max[AA&gt;:A](implicitA:cats.Order[AA]):monix.reactive.Observable[AA]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">max</span><span class="tparams">[<span name="AA">AA &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="A">A: <span name="cats.Order" class="extype">Order</span>[<span name="monix.reactive.Observable.max.AA" class="extype">AA</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.max.AA" class="extype">AA</span>]</span></span><p class="shortcomment cmt">Given a <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> over the stream's elements, returns the
maximum element in the stream.</p><div class="fullcomment"><div class="comment cmt"><p>Given a <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> over the stream's elements, returns the
maximum element in the stream.</p><h4>Example</h4><pre><span class="cmt">// Needed to bring the standard Order instances in scope:</span>
<span class="kw">import</span> cats.implicits._

<span class="cmt">// Yields Observable(20)</span>
<span class="kw">val</span> stream1 = Observable(<span class="num">10</span>, <span class="num">7</span>, <span class="num">6</span>, <span class="num">8</span>, <span class="num">20</span>, <span class="num">3</span>, <span class="num">5</span>).max

<span class="cmt">// Yields Observable.empty</span>
<span class="kw">val</span> stream2 = Observable.empty[<span class="std">Int</span>].max</pre><h4>Cats Order and Scala Interop</h4><p>        Monix prefers to work with <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> for assessing the order
        of elements that have an ordering defined, instead of
        <a href="https://www.scala-lang.org/api/2.13.3/scala/math/Ordering.html" name="scala.math.Ordering" id="scala.math.Ordering" class="extype">scala.math.Ordering</a>.</p><p>        We do this for consistency, as Monix is now building on top of Cats.
        This may change in the future, depending on what happens with
        <a href="https://github.com/typelevel/cats/issues/2455" target="_blank">typelevel/cats#2455</a>.</p><p>        Building a <code>cats.Order</code> is easy to do if you already have a
        Scala <code>Ordering</code> instance:</p><pre><span class="kw">import</span> cats.Order

<span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Starting from a Scala Ordering</span>
<span class="kw">implicit</span> <span class="kw">val</span> scalaOrderingForPerson: Ordering[Person] =
  <span class="kw">new</span> Ordering[Person] {
    <span class="kw">def</span> compare(x: Person, y: Person): <span class="std">Int</span> =
      x.age.compareTo(y.age) <span class="kw">match</span> {
        <span class="kw">case</span> <span class="num">0</span> <span class="kw">=&gt;</span> x.name.compareTo(y.name)
        <span class="kw">case</span> o <span class="kw">=&gt;</span> o
      }
  }

<span class="cmt">// Building a cats.Order from it</span>
<span class="kw">implicit</span> <span class="kw">val</span> catsOrderForPerson: Order[Person] =
  Order.fromOrdering</pre><p>        You can also do that in reverse, so you can prefer <code>cats.Order</code>
        (due to Cats also exposing laws and tests for free) and build a
        Scala <code>Ordering</code> when needed:</p><pre><span class="kw">val</span> scalaOrdering = catsOrderForPerson.toOrdering</pre></div><dl class="paramcmts block"><dt class="param">A</dt><dd class="cmt"><p>is the <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> type class instance that's going
         to be used for comparing elements</p></dd><dt>returns</dt><dd class="cmt"><p>the maximum element of the source stream, relative
        to the defined <code>Order</code></p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#maxL[AA&gt;:A](implicitA:cats.Order[AA]):monix.eval.Task[Option[AA]]" name="monix.reactive.Observable#maxL" id="monix.reactive.Observable#maxL" class="extmbr">maxL</a> for the version that returns a
     <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> instead of an observable.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#maxBy" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="maxBy[K](key:A=&gt;K)(implicitK:cats.Order[K]):monix.reactive.Observable[A]"></a><a id="maxBy[K]((A)=&gt;K)(Order[K]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#maxBy[K](key:A=&gt;K)(implicitK:cats.Order[K]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">maxBy</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="key">key: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.maxBy.K" class="extype">K</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="K">K: <span name="cats.Order" class="extype">Order</span>[<span name="monix.reactive.Observable.maxBy.K" class="extype">K</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Takes the elements of the source observable and emits the
element that has the maximum key value, where the key is
generated by the given function.</p><div class="fullcomment"><div class="comment cmt"><p>Takes the elements of the source observable and emits the
element that has the maximum key value, where the key is
generated by the given function.</p><h4>Example</h4><pre><span class="cmt">// Needed to bring the standard Order instances in scope:</span>
<span class="kw">import</span> cats.implicits._

<span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Yields Observable(Person("Alex", 34))</span>
Observable(Person(<span class="lit">"Alex"</span>, <span class="num">34</span>), Person(<span class="lit">"Alice"</span>, <span class="num">27</span>))
  .maxBy(_.age)</pre><h4>Cats Order and Scala Interop</h4><p>        Monix prefers to work with <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> for assessing the order
        of elements that have an ordering defined, instead of
        <a href="https://www.scala-lang.org/api/2.13.3/scala/math/Ordering.html" name="scala.math.Ordering" id="scala.math.Ordering" class="extype">scala.math.Ordering</a>.</p><p>        We do this for consistency, as Monix is now building on top of Cats.
        This may change in the future, depending on what happens with
        <a href="https://github.com/typelevel/cats/issues/2455" target="_blank">typelevel/cats#2455</a>.</p><p>        Building a <code>cats.Order</code> is easy to do if you already have a
        Scala <code>Ordering</code> instance:</p><pre><span class="kw">import</span> cats.Order

<span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Starting from a Scala Ordering</span>
<span class="kw">implicit</span> <span class="kw">val</span> scalaOrderingForPerson: Ordering[Person] =
  <span class="kw">new</span> Ordering[Person] {
    <span class="kw">def</span> compare(x: Person, y: Person): <span class="std">Int</span> =
      x.age.compareTo(y.age) <span class="kw">match</span> {
        <span class="kw">case</span> <span class="num">0</span> <span class="kw">=&gt;</span> x.name.compareTo(y.name)
        <span class="kw">case</span> o <span class="kw">=&gt;</span> o
      }
  }

<span class="cmt">// Building a cats.Order from it</span>
<span class="kw">implicit</span> <span class="kw">val</span> catsOrderForPerson: Order[Person] =
  Order.fromOrdering</pre><p>        You can also do that in reverse, so you can prefer <code>cats.Order</code>
        (due to Cats also exposing laws and tests for free) and build a
        Scala <code>Ordering</code> when needed:</p><pre><span class="kw">val</span> scalaOrdering = catsOrderForPerson.toOrdering</pre></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>is the function that returns the key for which the
       given ordering is defined</p></dd><dt class="param">K</dt><dd class="cmt"><p>is the <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> type class instance that's going
         to be used for comparing elements</p></dd><dt>returns</dt><dd class="cmt"><p>the maximum element of the source stream, relative
        to its key generated by the given function and the
        given ordering</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#maxByL[K](key:A=&gt;K)(implicitK:cats.Order[K]):monix.eval.Task[Option[A]]" name="monix.reactive.Observable#maxByL" id="monix.reactive.Observable#maxByL" class="extmbr">maxByL</a> for the version that returns a
     <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> instead of an observable.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#maxByL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="maxByL[K](key:A=&gt;K)(implicitK:cats.Order[K]):monix.eval.Task[Option[A]]"></a><a id="maxByL[K]((A)=&gt;K)(Order[K]):Task[Option[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#maxByL[K](key:A=&gt;K)(implicitK:cats.Order[K]):monix.eval.Task[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">maxByL</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="key">key: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.maxByL.K" class="extype">K</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="K">K: <span name="cats.Order" class="extype">Order</span>[<span name="monix.reactive.Observable.maxByL.K" class="extype">K</span>]</span>)</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Takes the elements of the source observable and emits the
element that has the maximum key value, where the key is
generated by the given function.</p><div class="fullcomment"><div class="comment cmt"><p>Takes the elements of the source observable and emits the
element that has the maximum key value, where the key is
generated by the given function.</p><h4>Example</h4><pre><span class="cmt">// Needed to bring the standard Order instances in scope:</span>
<span class="kw">import</span> cats.implicits._

<span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Yields Some(Person("Alex", 34))</span>
Observable(Person(<span class="lit">"Alex"</span>, <span class="num">34</span>), Person(<span class="lit">"Alice"</span>, <span class="num">27</span>))
  .maxByL(_.age)</pre><h4>Cats Order and Scala Interop</h4><p>        Monix prefers to work with <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> for assessing the order
        of elements that have an ordering defined, instead of
        <a href="https://www.scala-lang.org/api/2.13.3/scala/math/Ordering.html" name="scala.math.Ordering" id="scala.math.Ordering" class="extype">scala.math.Ordering</a>.</p><p>        We do this for consistency, as Monix is now building on top of Cats.
        This may change in the future, depending on what happens with
        <a href="https://github.com/typelevel/cats/issues/2455" target="_blank">typelevel/cats#2455</a>.</p><p>        Building a <code>cats.Order</code> is easy to do if you already have a
        Scala <code>Ordering</code> instance:</p><pre><span class="kw">import</span> cats.Order

<span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Starting from a Scala Ordering</span>
<span class="kw">implicit</span> <span class="kw">val</span> scalaOrderingForPerson: Ordering[Person] =
  <span class="kw">new</span> Ordering[Person] {
    <span class="kw">def</span> compare(x: Person, y: Person): <span class="std">Int</span> =
      x.age.compareTo(y.age) <span class="kw">match</span> {
        <span class="kw">case</span> <span class="num">0</span> <span class="kw">=&gt;</span> x.name.compareTo(y.name)
        <span class="kw">case</span> o <span class="kw">=&gt;</span> o
      }
  }

<span class="cmt">// Building a cats.Order from it</span>
<span class="kw">implicit</span> <span class="kw">val</span> catsOrderForPerson: Order[Person] =
  Order.fromOrdering</pre><p>        You can also do that in reverse, so you can prefer <code>cats.Order</code>
        (due to Cats also exposing laws and tests for free) and build a
        Scala <code>Ordering</code> when needed:</p><pre><span class="kw">val</span> scalaOrdering = catsOrderForPerson.toOrdering</pre></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>is the function that returns the key for which the
       given ordering is defined</p></dd><dt class="param">K</dt><dd class="cmt"><p>is the <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> type class instance that's going
         to be used for comparing elements</p></dd><dt>returns</dt><dd class="cmt"><p>the maximum element of the source stream, relative
        to its key generated by the given function and the
        given ordering</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#maxBy[K](key:A=&gt;K)(implicitK:cats.Order[K]):monix.reactive.Observable[A]" name="monix.reactive.Observable#maxBy" id="monix.reactive.Observable#maxBy" class="extmbr">maxBy</a> for the version that returns an
     observable instead of a <code>Task</code>.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#maxL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="maxL[AA&gt;:A](implicitA:cats.Order[AA]):monix.eval.Task[Option[AA]]"></a><a id="maxL[AA&gt;:A](Order[AA]):Task[Option[AA]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#maxL[AA&gt;:A](implicitA:cats.Order[AA]):monix.eval.Task[Option[AA]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">maxL</span><span class="tparams">[<span name="AA">AA &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="A">A: <span name="cats.Order" class="extype">Order</span>[<span name="monix.reactive.Observable.maxL.AA" class="extype">AA</span>]</span>)</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.reactive.Observable.maxL.AA" class="extype">AA</span>]]</span></span><p class="shortcomment cmt">Given a <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> over the stream's elements, returns the
maximum element in the stream.</p><div class="fullcomment"><div class="comment cmt"><p>Given a <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> over the stream's elements, returns the
maximum element in the stream.</p><h4>Example</h4><pre><span class="cmt">// Needed to bring the standard Order instances in scope:</span>
<span class="kw">import</span> cats.implicits._

<span class="cmt">// Yields Some(20)</span>
<span class="kw">val</span> stream1 = Observable(<span class="num">10</span>, <span class="num">7</span>, <span class="num">6</span>, <span class="num">8</span>, <span class="num">20</span>, <span class="num">3</span>, <span class="num">5</span>).maxL

<span class="cmt">// Yields Observable.empty</span>
<span class="kw">val</span> stream2 = Observable.empty[<span class="std">Int</span>].maxL</pre><h4>Cats Order and Scala Interop</h4><p>        Monix prefers to work with <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> for assessing the order
        of elements that have an ordering defined, instead of
        <a href="https://www.scala-lang.org/api/2.13.3/scala/math/Ordering.html" name="scala.math.Ordering" id="scala.math.Ordering" class="extype">scala.math.Ordering</a>.</p><p>        We do this for consistency, as Monix is now building on top of Cats.
        This may change in the future, depending on what happens with
        <a href="https://github.com/typelevel/cats/issues/2455" target="_blank">typelevel/cats#2455</a>.</p><p>        Building a <code>cats.Order</code> is easy to do if you already have a
        Scala <code>Ordering</code> instance:</p><pre><span class="kw">import</span> cats.Order

<span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Starting from a Scala Ordering</span>
<span class="kw">implicit</span> <span class="kw">val</span> scalaOrderingForPerson: Ordering[Person] =
  <span class="kw">new</span> Ordering[Person] {
    <span class="kw">def</span> compare(x: Person, y: Person): <span class="std">Int</span> =
      x.age.compareTo(y.age) <span class="kw">match</span> {
        <span class="kw">case</span> <span class="num">0</span> <span class="kw">=&gt;</span> x.name.compareTo(y.name)
        <span class="kw">case</span> o <span class="kw">=&gt;</span> o
      }
  }

<span class="cmt">// Building a cats.Order from it</span>
<span class="kw">implicit</span> <span class="kw">val</span> catsOrderForPerson: Order[Person] =
  Order.fromOrdering</pre><p>        You can also do that in reverse, so you can prefer <code>cats.Order</code>
        (due to Cats also exposing laws and tests for free) and build a
        Scala <code>Ordering</code> when needed:</p><pre><span class="kw">val</span> scalaOrdering = catsOrderForPerson.toOrdering</pre></div><dl class="paramcmts block"><dt class="param">A</dt><dd class="cmt"><p>is the <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> type class instance that's
         going to be used for comparing elements</p></dd><dt>returns</dt><dd class="cmt"><p>the maximum element of the source stream, relative
        to the defined <code>Order</code></p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#max[AA&gt;:A](implicitA:cats.Order[AA]):monix.reactive.Observable[AA]" name="monix.reactive.Observable#max" id="monix.reactive.Observable#max" class="extmbr">maxF</a> for the version that returns an
     observable instead of a <code>Task</code>.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#merge" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="merge[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B],implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]"></a><a id="merge[B](&lt;:&lt;[A,Observable[B]],OverflowStrategy[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#merge[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B],implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">merge</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.3/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>, <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.merge.B" class="extype">B</span>]]</span>, <span name="os">os: <a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a>[<span name="monix.reactive.Observable.merge.B" class="extype">B</span>] = <span class="symbol"><span class="name"><a href="OverflowStrategy$.html">OverflowStrategy.Default[B]</a></span></span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.merge.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Concurrently merges the observables emitted by the source, into
a single observable.</p><div class="fullcomment"><div class="comment cmt"><p>Concurrently merges the observables emitted by the source, into
a single observable.</p><h4>Equivalence with mergeMap</h4><p>The <code>merge</code> operation is <a href="#mergeMap[B](f:A=&gt;monix.reactive.Observable[B])(implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#mergeMap" id="monix.reactive.Observable#mergeMap" class="extmbr">mergeMap</a> with the identity
function:</p><p><code>stream.merge &lt;-&gt; stream.mergeMap(x =&gt; x)</code></p><h4>Concat vs Merge</h4><p>        The difference between the <a href="#concat[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#concat" id="monix.reactive.Observable#concat" class="extmbr">concat</a>
        operation and <a href="#merge[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B],implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#merge" id="monix.reactive.Observable#merge" class="extmbr">merge</a> is that <code>concat</code>
        cares about the ordering of sequences (e.g. all items
        emitted by the first observable in the sequence will come
        before the elements emitted by the second observable),
        whereas <code>merge</code> doesn't care about that (elements get
        emitted as they come). Because of back-pressure applied to
        observables, <code>concat</code> is safe to use in all contexts,
        whereas <code>merge</code> requires buffering. Or in other words
        <code>concat</code> has deterministic, lawful behavior (being the
        "monadic bind"), whereas <code>merge</code> has non-deterministic
        behavior.</p><h4> Visual Example </h4><p><pre>
streamA: a1 -- -- a2 -- -- a3 -- a4 -- --
streamB: b1 -- -- b2 -- b3 -- -- -- -- b4

result: a1, b1, a2, b2, b3, a3, a4, b4
</pre>
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an observable containing the merged events of all
        streams created by the source</p></dd></dl><dl class="attributes block"><dt>Note</dt><dd><span class="cmt"><p>this operation needs to do buffering
        and by not specifying an <a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a>, the
        <a href="OverflowStrategy$.html#Default[A]:monix.reactive.OverflowStrategy[A]" name="monix.reactive.OverflowStrategy#Default" id="monix.reactive.OverflowStrategy#Default" class="extmbr">default strategy</a> is being
        used.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#mergeDelayErrors" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mergeDelayErrors[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B],implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]"></a><a id="mergeDelayErrors[B](&lt;:&lt;[A,Observable[B]],OverflowStrategy[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#mergeDelayErrors[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B],implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mergeDelayErrors</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.3/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>, <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.mergeDelayErrors.B" class="extype">B</span>]]</span>, <span name="os">os: <a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a>[<span name="monix.reactive.Observable.mergeDelayErrors.B" class="extype">B</span>] = <span class="symbol"><span class="name"><a href="OverflowStrategy$.html">OverflowStrategy.Default</a></span></span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.mergeDelayErrors.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">        This version is reserving <code>onError</code> notifications until
        all of the observables complete and only then passing the
        issued errors(s) downstream.</p><div class="fullcomment"><div class="comment cmt"><h4>Delaying Errors</h4><p>        This version is reserving <code>onError</code> notifications until
        all of the observables complete and only then passing the
        issued errors(s) downstream. Note that the streamed error is a
        <a href="../execution/exceptions/CompositeException.html" name="monix.execution.exceptions.CompositeException" id="monix.execution.exceptions.CompositeException" class="extype">CompositeException</a>,
        since multiple errors from multiple streams can happen.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an observable containing the merged events of all
        streams created by the source</p></dd></dl><dl class="attributes block"><dt>Note</dt><dd><span class="cmt"><p>this operation needs to do buffering
        and by not specifying an <a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a>, the
        <a href="OverflowStrategy$.html#Default[A]:monix.reactive.OverflowStrategy[A]" name="monix.reactive.OverflowStrategy#Default" id="monix.reactive.OverflowStrategy#Default" class="extmbr">default strategy</a> is being
        used.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#mergeMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mergeMap[B](f:A=&gt;monix.reactive.Observable[B])(implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]"></a><a id="mergeMap[B]((A)=&gt;Observable[B])(OverflowStrategy[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#mergeMap[B](f:A=&gt;monix.reactive.Observable[B])(implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mergeMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.mergeMap.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="os">os: <a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a>[<span name="monix.reactive.Observable.mergeMap.B" class="extype">B</span>] = <span class="symbol"><span class="name"><a href="OverflowStrategy$.html">OverflowStrategy.Default</a></span></span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.mergeMap.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Concurrently merges the observables emitted by the source with
the given generator function into a single observable.</p><div class="fullcomment"><div class="comment cmt"><p>Concurrently merges the observables emitted by the source with
the given generator function into a single observable.</p><h4>Concat vs Merge</h4><p>        The difference between the <a href="#concat[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#concat" id="monix.reactive.Observable#concat" class="extmbr">concat</a>
        operation and <a href="#merge[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B],implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#merge" id="monix.reactive.Observable#merge" class="extmbr">merge</a> is that <code>concat</code>
        cares about the ordering of sequences (e.g. all items
        emitted by the first observable in the sequence will come
        before the elements emitted by the second observable),
        whereas <code>merge</code> doesn't care about that (elements get
        emitted as they come). Because of back-pressure applied to
        observables, <code>concat</code> is safe to use in all contexts,
        whereas <code>merge</code> requires buffering. Or in other words
        <code>concat</code> has deterministic, lawful behavior (being the
        "monadic bind"), whereas <code>merge</code> has non-deterministic
        behavior.</p><h4>Example</h4><pre>Observable(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>).mergeMap { x <span class="kw">=&gt;</span>
  Observable.eval(println(s<span class="lit">"Processing $$x"</span>))
    .executeAsync
    .flatMap(_ <span class="kw">=&gt;</span> Observable(x, x))
}</pre><p>In this example the source will yield 3 streams and those 3
streams are being subscribed immediately, therefore the order of
the events will be non-deterministic, as the streams will be
evaluated concurrently.</p><h4> Visual Example </h4><p><pre>
streamA: a1 -- -- a2 -- -- a3 -- a4 -- --
streamB: b1 -- -- b2 -- b3 -- -- -- -- b4

result: a1, b1, a2, b2, b3, a3, a4, b4
</pre></p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is a generator for the streams that will get merged</p></dd><dt>returns</dt><dd class="cmt"><p>an observable that emits the result of applying the
        transformation function to each item emitted by the source
        observable and merging the results of the observables
        obtained from this transformation.</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#mergeMapDelayErrors" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mergeMapDelayErrors[B](f:A=&gt;monix.reactive.Observable[B])(implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]"></a><a id="mergeMapDelayErrors[B]((A)=&gt;Observable[B])(OverflowStrategy[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#mergeMapDelayErrors[B](f:A=&gt;monix.reactive.Observable[B])(implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mergeMapDelayErrors</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.mergeMapDelayErrors.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="os">os: <a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a>[<span name="monix.reactive.Observable.mergeMapDelayErrors.B" class="extype">B</span>] = <span class="symbol"><span class="name"><a href="OverflowStrategy$.html">OverflowStrategy.Default</a></span></span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.mergeMapDelayErrors.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new observable by applying a
        function that you supply to each item emitted by the
        source observable, where that function returns an
        observable, and then merging those resulting observable
        and emitting the results of this merger.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new observable by applying a
        function that you supply to each item emitted by the
        source observable, where that function returns an
        observable, and then merging those resulting observable
        and emitting the results of this merger.</p><h4>Concat vs Merge</h4><p>        The difference between the <a href="#concat[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#concat" id="monix.reactive.Observable#concat" class="extmbr">concat</a>
        operation and <a href="#merge[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B],implicitos:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#merge" id="monix.reactive.Observable#merge" class="extmbr">merge</a> is that <code>concat</code>
        cares about the ordering of sequences (e.g. all items
        emitted by the first observable in the sequence will come
        before the elements emitted by the second observable),
        whereas <code>merge</code> doesn't care about that (elements get
        emitted as they come). Because of back-pressure applied to
        observables, <code>concat</code> is safe to use in all contexts,
        whereas <code>merge</code> requires buffering. Or in other words
        <code>concat</code> has deterministic, lawful behavior (being the
        "monadic bind"), whereas <code>merge</code> has non-deterministic
        behavior.</p><h4>Delaying Errors</h4><p>        This version is reserving <code>onError</code> notifications until
        all of the observables complete and only then passing the
        issued errors(s) downstream. Note that the streamed error is a
        <a href="../execution/exceptions/CompositeException.html" name="monix.execution.exceptions.CompositeException" id="monix.execution.exceptions.CompositeException" class="extype">CompositeException</a>,
        since multiple errors from multiple streams can happen.</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is a generator for the streams that will get merged</p></dd><dt>returns</dt><dd class="cmt"><p>an observable that emits the result of applying the
        transformation function to each item emitted by the source
        observable and merging the results of the observables
        obtained from this transformation.</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#min" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="min[AA&gt;:A](implicitA:cats.Order[AA]):monix.reactive.Observable[AA]"></a><a id="min[AA&gt;:A](Order[AA]):Observable[AA]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#min[AA&gt;:A](implicitA:cats.Order[AA]):monix.reactive.Observable[AA]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">min</span><span class="tparams">[<span name="AA">AA &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="A">A: <span name="cats.Order" class="extype">Order</span>[<span name="monix.reactive.Observable.min.AA" class="extype">AA</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.min.AA" class="extype">AA</span>]</span></span><p class="shortcomment cmt">Given a <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> over the stream's elements, returns the
minimum element in the stream.</p><div class="fullcomment"><div class="comment cmt"><p>Given a <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> over the stream's elements, returns the
minimum element in the stream.</p><h4>Example</h4><pre><span class="cmt">// Needed to bring the standard Order instances in scope:</span>
<span class="kw">import</span> cats.implicits._

<span class="cmt">// Yields Observable(3)</span>
<span class="kw">val</span> stream1 =
  Observable(<span class="num">10</span>, <span class="num">7</span>, <span class="num">6</span>, <span class="num">8</span>, <span class="num">20</span>, <span class="num">3</span>, <span class="num">5</span>).min

<span class="cmt">// Yields Observable.empty</span>
<span class="kw">val</span> stream2 =
  Observable.empty[<span class="std">Int</span>].min</pre><h4>Cats Order and Scala Interop</h4><p>        Monix prefers to work with <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> for assessing the order
        of elements that have an ordering defined, instead of
        <a href="https://www.scala-lang.org/api/2.13.3/scala/math/Ordering.html" name="scala.math.Ordering" id="scala.math.Ordering" class="extype">scala.math.Ordering</a>.</p><p>        We do this for consistency, as Monix is now building on top of Cats.
        This may change in the future, depending on what happens with
        <a href="https://github.com/typelevel/cats/issues/2455" target="_blank">typelevel/cats#2455</a>.</p><p>        Building a <code>cats.Order</code> is easy to do if you already have a
        Scala <code>Ordering</code> instance:</p><pre><span class="kw">import</span> cats.Order

<span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Starting from a Scala Ordering</span>
<span class="kw">implicit</span> <span class="kw">val</span> scalaOrderingForPerson: Ordering[Person] =
  <span class="kw">new</span> Ordering[Person] {
    <span class="kw">def</span> compare(x: Person, y: Person): <span class="std">Int</span> =
      x.age.compareTo(y.age) <span class="kw">match</span> {
        <span class="kw">case</span> <span class="num">0</span> <span class="kw">=&gt;</span> x.name.compareTo(y.name)
        <span class="kw">case</span> o <span class="kw">=&gt;</span> o
      }
  }

<span class="cmt">// Building a cats.Order from it</span>
<span class="kw">implicit</span> <span class="kw">val</span> catsOrderForPerson: Order[Person] =
  Order.fromOrdering</pre><p>        You can also do that in reverse, so you can prefer <code>cats.Order</code>
        (due to Cats also exposing laws and tests for free) and build a
        Scala <code>Ordering</code> when needed:</p><pre><span class="kw">val</span> scalaOrdering = catsOrderForPerson.toOrdering</pre></div><dl class="paramcmts block"><dt class="param">A</dt><dd class="cmt"><p>is the <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> type class instance that's going
         to be used for comparing elements</p></dd><dt>returns</dt><dd class="cmt"><p>the minimum element of the source stream, relative
        to the defined <code>Order</code></p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#minL[AA&gt;:A](implicitA:cats.Order[AA]):monix.eval.Task[Option[AA]]" name="monix.reactive.Observable#minL" id="monix.reactive.Observable#minL" class="extmbr">minL</a> for the version that returns a
     <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> instead of an observable.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#minBy" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="minBy[K](key:A=&gt;K)(implicitK:cats.Order[K]):monix.reactive.Observable[A]"></a><a id="minBy[K]((A)=&gt;K)(Order[K]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#minBy[K](key:A=&gt;K)(implicitK:cats.Order[K]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">minBy</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="key">key: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.minBy.K" class="extype">K</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="K">K: <span name="cats.Order" class="extype">Order</span>[<span name="monix.reactive.Observable.minBy.K" class="extype">K</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Takes the elements of the source observable and emits the
element that has the minimum key value, where the key is
generated by the given function.</p><div class="fullcomment"><div class="comment cmt"><p>Takes the elements of the source observable and emits the
element that has the minimum key value, where the key is
generated by the given function.</p><p>Example:</p><pre><span class="cmt">// Needed to bring the standard Order instances in scope:</span>
<span class="kw">import</span> cats.implicits._

<span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Yields Observable(Person("Alice", 27))</span>
<span class="kw">val</span> stream = Observable(Person(<span class="lit">"Alex"</span>, <span class="num">34</span>), Person(<span class="lit">"Alice"</span>, <span class="num">27</span>))
  .minBy(_.age)</pre><h4>Cats Order and Scala Interop</h4><p>        Monix prefers to work with <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> for assessing the order
        of elements that have an ordering defined, instead of
        <a href="https://www.scala-lang.org/api/2.13.3/scala/math/Ordering.html" name="scala.math.Ordering" id="scala.math.Ordering" class="extype">scala.math.Ordering</a>.</p><p>        We do this for consistency, as Monix is now building on top of Cats.
        This may change in the future, depending on what happens with
        <a href="https://github.com/typelevel/cats/issues/2455" target="_blank">typelevel/cats#2455</a>.</p><p>        Building a <code>cats.Order</code> is easy to do if you already have a
        Scala <code>Ordering</code> instance:</p><pre><span class="kw">import</span> cats.Order

<span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Starting from a Scala Ordering</span>
<span class="kw">implicit</span> <span class="kw">val</span> scalaOrderingForPerson: Ordering[Person] =
  <span class="kw">new</span> Ordering[Person] {
    <span class="kw">def</span> compare(x: Person, y: Person): <span class="std">Int</span> =
      x.age.compareTo(y.age) <span class="kw">match</span> {
        <span class="kw">case</span> <span class="num">0</span> <span class="kw">=&gt;</span> x.name.compareTo(y.name)
        <span class="kw">case</span> o <span class="kw">=&gt;</span> o
      }
  }

<span class="cmt">// Building a cats.Order from it</span>
<span class="kw">implicit</span> <span class="kw">val</span> catsOrderForPerson: Order[Person] =
  Order.fromOrdering</pre><p>        You can also do that in reverse, so you can prefer <code>cats.Order</code>
        (due to Cats also exposing laws and tests for free) and build a
        Scala <code>Ordering</code> when needed:</p><pre><span class="kw">val</span> scalaOrdering = catsOrderForPerson.toOrdering</pre></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>is the function that returns the key for which the
       given ordering is defined</p></dd><dt class="param">K</dt><dd class="cmt"><p>is the <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> type class instance that's
         going to be used for comparing elements</p></dd><dt>returns</dt><dd class="cmt"><p>the minimum element of the source stream, relative
        to its key generated by the given function and the
        given ordering</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#minByL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="minByL[K](key:A=&gt;K)(implicitK:cats.Order[K]):monix.eval.Task[Option[A]]"></a><a id="minByL[K]((A)=&gt;K)(Order[K]):Task[Option[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#minByL[K](key:A=&gt;K)(implicitK:cats.Order[K]):monix.eval.Task[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">minByL</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="key">key: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.minByL.K" class="extype">K</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="K">K: <span name="cats.Order" class="extype">Order</span>[<span name="monix.reactive.Observable.minByL.K" class="extype">K</span>]</span>)</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Takes the elements of the source observable and emits the
element that has the minimum key value, where the key is
generated by the given function.</p><div class="fullcomment"><div class="comment cmt"><p>Takes the elements of the source observable and emits the
element that has the minimum key value, where the key is
generated by the given function.</p><h4>Example</h4><pre><span class="cmt">// Needed to bring the standard Order instances in scope:</span>
<span class="kw">import</span> cats.implicits._

<span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Yields Some(Person("Alice", 27))</span>
Observable(Person(<span class="lit">"Alex"</span>, <span class="num">34</span>), Person(<span class="lit">"Alice"</span>, <span class="num">27</span>))
  .minByL(_.age)</pre><h4>Cats Order and Scala Interop</h4><p>        Monix prefers to work with <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> for assessing the order
        of elements that have an ordering defined, instead of
        <a href="https://www.scala-lang.org/api/2.13.3/scala/math/Ordering.html" name="scala.math.Ordering" id="scala.math.Ordering" class="extype">scala.math.Ordering</a>.</p><p>        We do this for consistency, as Monix is now building on top of Cats.
        This may change in the future, depending on what happens with
        <a href="https://github.com/typelevel/cats/issues/2455" target="_blank">typelevel/cats#2455</a>.</p><p>        Building a <code>cats.Order</code> is easy to do if you already have a
        Scala <code>Ordering</code> instance:</p><pre><span class="kw">import</span> cats.Order

<span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Starting from a Scala Ordering</span>
<span class="kw">implicit</span> <span class="kw">val</span> scalaOrderingForPerson: Ordering[Person] =
  <span class="kw">new</span> Ordering[Person] {
    <span class="kw">def</span> compare(x: Person, y: Person): <span class="std">Int</span> =
      x.age.compareTo(y.age) <span class="kw">match</span> {
        <span class="kw">case</span> <span class="num">0</span> <span class="kw">=&gt;</span> x.name.compareTo(y.name)
        <span class="kw">case</span> o <span class="kw">=&gt;</span> o
      }
  }

<span class="cmt">// Building a cats.Order from it</span>
<span class="kw">implicit</span> <span class="kw">val</span> catsOrderForPerson: Order[Person] =
  Order.fromOrdering</pre><p>        You can also do that in reverse, so you can prefer <code>cats.Order</code>
        (due to Cats also exposing laws and tests for free) and build a
        Scala <code>Ordering</code> when needed:</p><pre><span class="kw">val</span> scalaOrdering = catsOrderForPerson.toOrdering</pre></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>is the function that returns the key for which the
       given ordering is defined</p></dd><dt class="param">K</dt><dd class="cmt"><p>is the <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> type class instance that's going
         to be used for comparing elements</p></dd><dt>returns</dt><dd class="cmt"><p>the minimum element of the source stream, relative
        to its key generated by the given function and the
        given ordering</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#minL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="minL[AA&gt;:A](implicitA:cats.Order[AA]):monix.eval.Task[Option[AA]]"></a><a id="minL[AA&gt;:A](Order[AA]):Task[Option[AA]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#minL[AA&gt;:A](implicitA:cats.Order[AA]):monix.eval.Task[Option[AA]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">minL</span><span class="tparams">[<span name="AA">AA &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="A">A: <span name="cats.Order" class="extype">Order</span>[<span name="monix.reactive.Observable.minL.AA" class="extype">AA</span>]</span>)</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.reactive.Observable.minL.AA" class="extype">AA</span>]]</span></span><p class="shortcomment cmt">Given a <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> over the stream's elements, returns the
minimum element in the stream.</p><div class="fullcomment"><div class="comment cmt"><p>Given a <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> over the stream's elements, returns the
minimum element in the stream.</p><h4>Example</h4><pre><span class="cmt">// Needed to bring the standard Order instances in scope:</span>
<span class="kw">import</span> cats.implicits._

<span class="cmt">// Yields Some(3)</span>
<span class="kw">val</span> stream1 =
  Observable(<span class="num">10</span>, <span class="num">7</span>, <span class="num">6</span>, <span class="num">8</span>, <span class="num">20</span>, <span class="num">3</span>, <span class="num">5</span>).minL

<span class="cmt">// Yields None</span>
<span class="kw">val</span> stream2 =
  Observable.empty[<span class="std">Int</span>].minL</pre><h4>Cats Order and Scala Interop</h4><p>        Monix prefers to work with <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> for assessing the order
        of elements that have an ordering defined, instead of
        <a href="https://www.scala-lang.org/api/2.13.3/scala/math/Ordering.html" name="scala.math.Ordering" id="scala.math.Ordering" class="extype">scala.math.Ordering</a>.</p><p>        We do this for consistency, as Monix is now building on top of Cats.
        This may change in the future, depending on what happens with
        <a href="https://github.com/typelevel/cats/issues/2455" target="_blank">typelevel/cats#2455</a>.</p><p>        Building a <code>cats.Order</code> is easy to do if you already have a
        Scala <code>Ordering</code> instance:</p><pre><span class="kw">import</span> cats.Order

<span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Starting from a Scala Ordering</span>
<span class="kw">implicit</span> <span class="kw">val</span> scalaOrderingForPerson: Ordering[Person] =
  <span class="kw">new</span> Ordering[Person] {
    <span class="kw">def</span> compare(x: Person, y: Person): <span class="std">Int</span> =
      x.age.compareTo(y.age) <span class="kw">match</span> {
        <span class="kw">case</span> <span class="num">0</span> <span class="kw">=&gt;</span> x.name.compareTo(y.name)
        <span class="kw">case</span> o <span class="kw">=&gt;</span> o
      }
  }

<span class="cmt">// Building a cats.Order from it</span>
<span class="kw">implicit</span> <span class="kw">val</span> catsOrderForPerson: Order[Person] =
  Order.fromOrdering</pre><p>        You can also do that in reverse, so you can prefer <code>cats.Order</code>
        (due to Cats also exposing laws and tests for free) and build a
        Scala <code>Ordering</code> when needed:</p><pre><span class="kw">val</span> scalaOrdering = catsOrderForPerson.toOrdering</pre></div><dl class="paramcmts block"><dt class="param">A</dt><dd class="cmt"><p>is the <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> type class instance that's going
         to be used for comparing elements</p></dd><dt>returns</dt><dd class="cmt"><p>the minimum element of the source stream, relative
        to the defined <code>Order</code></p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#min[AA&gt;:A](implicitA:cats.Order[AA]):monix.reactive.Observable[AA]" name="monix.reactive.Observable#min" id="monix.reactive.Observable#min" class="extmbr">minF</a> for the version that returns an
     observable instead of a <code>Task</code>.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#multicast" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="multicast[B&gt;:A,R](pipe:monix.reactive.Pipe[B,R])(implicits:monix.execution.Scheduler):monix.reactive.observables.ConnectableObservable[R]"></a><a id="multicast[B&gt;:A,R](Pipe[B,R])(Scheduler):ConnectableObservable[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#multicast[B&gt;:A,R](pipe:monix.reactive.Pipe[B,R])(implicits:monix.execution.Scheduler):monix.reactive.observables.ConnectableObservable[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">multicast</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>, <span name="R">R</span>]</span><span class="params">(<span name="pipe">pipe: <a href="Pipe.html" name="monix.reactive.Pipe" id="monix.reactive.Pipe" class="extype">Pipe</a>[<span name="monix.reactive.Observable.multicast.B" class="extype">B</span>, <span name="monix.reactive.Observable.multicast.R" class="extype">R</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="observables/ConnectableObservable.html" name="monix.reactive.observables.ConnectableObservable" id="monix.reactive.observables.ConnectableObservable" class="extype">ConnectableObservable</a>[<span name="monix.reactive.Observable.multicast.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Converts this observable into a multicast observable, useful for
turning a cold observable into a hot one (i.e.</p><div class="fullcomment"><div class="comment cmt"><p>Converts this observable into a multicast observable, useful for
turning a cold observable into a hot one (i.e. whose source is
shared by all observers).</p><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#nonEmpty" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="nonEmpty:monix.reactive.Observable[Boolean]"></a><a id="nonEmpty:Observable[Boolean]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#nonEmpty:monix.reactive.Observable[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">nonEmpty</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Returns an Observable that emits false if the source Observable is
empty, otherwise true.</p></li><li class="indented0 " name="monix.reactive.Observable#nonEmptyL" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="nonEmptyL:monix.eval.Task[Boolean]"></a><a id="nonEmptyL:Task[Boolean]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#nonEmptyL:monix.eval.Task[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">nonEmptyL</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Returns a task that emits <code>false</code> if the source observable is
empty, otherwise <code>true</code>.</p></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#observeOn" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="observeOn[B&gt;:A](s:monix.execution.Scheduler,os:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]"></a><a id="observeOn[B&gt;:A](Scheduler,OverflowStrategy[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#observeOn[B&gt;:A](s:monix.execution.Scheduler,os:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">observeOn</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>, <span name="os">os: <a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a>[<span name="monix.reactive.Observable.observeOn.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.observeOn.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Operator that specifies a different
<a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>, on which subscribers
will observe events, instead of the default one.</p><div class="fullcomment"><div class="comment cmt"><p>Operator that specifies a different
<a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>, on which subscribers
will observe events, instead of the default one.</p><p>This overloaded version of <code>observeOn</code> takes an extra
<a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a>
parameter specifying the behavior of the underlying buffer.
</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>is the alternative <code>Scheduler</code> reference to use
       for observing events</p></dd><dt class="param">os</dt><dd class="cmt"><p>is the <a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a>
       to apply to the underlying buffer</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#observeOn(s:monix.execution.Scheduler):monix.reactive.Observable[A]" name="monix.reactive.Observable#observeOn" id="monix.reactive.Observable#observeOn" class="extmbr">observeOn(Scheduler)</a> for
     the version that does not take an <code>OverflowStrategy</code> parameter.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#observeOn" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="observeOn(s:monix.execution.Scheduler):monix.reactive.Observable[A]"></a><a id="observeOn(Scheduler):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#observeOn(s:monix.execution.Scheduler):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">observeOn</span><span class="params">(<span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Operator that specifies a different
<a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>, on which subscribers
will observe events, instead of the default one.</p><div class="fullcomment"><div class="comment cmt"><p>Operator that specifies a different
<a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>, on which subscribers
will observe events, instead of the default one.</p><p>An <code>Observable</code> with an applied <code>observeOn</code> call will forward
events into a buffer that uses the specified <code>Scheduler</code>
reference to cycle through events and to make <code>onNext</code> calls to
downstream listeners.</p><p>Example:</p><pre><span class="kw">import</span> monix.execution.Scheduler
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global
<span class="kw">val</span> io = Scheduler.io(<span class="lit">"my-io"</span>)

Observable(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>).map(_ + <span class="num">1</span>)
  .observeOn(io)
  .foreach(x <span class="kw">=&gt;</span> println(x))</pre><p>In the above example the first <code>map</code> (whatever comes before the
<code>observeOn</code> call) gets executed using the default <code>Scheduler</code>
(might execute on the current thread even), however the
<code>foreach</code> that's specified after <code>observeOn</code> will get executed
on the indicated <code>Scheduler</code>.</p><p>NOTE: this operator does not guarantee that downstream listeners
will actually use the specified <code>Scheduler</code> to process events,
because this depends on the rest of the pipeline. E.g. this will
not work OK:</p><pre><span class="kw">import</span> monix.reactive.OverflowStrategy.Unbounded

Observable.suspend(???)
  .observeOn(io).asyncBoundary(Unbounded)</pre><p>This sample might not do what a user of <code>observeOn</code> would
want. Indeed the implementation will use the provided <code>io</code>
reference for calling <code>onNext</code> / <code>onComplete</code> / <code>onError</code>
events, however because of the following asynchronous boundary
created the actual listeners will probably end up being execute
on a different <code>Scheduler</code>.</p><p>The underlying implementation uses
<a href="observers/BufferedSubscriber.html" name="monix.reactive.observers.BufferedSubscriber" id="monix.reactive.observers.BufferedSubscriber" class="extype">a buffer</a>
to forward events. The
<a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a>
being applied is the
<a href="OverflowStrategy$.html#Default[A]:monix.reactive.OverflowStrategy[A]" name="monix.reactive.OverflowStrategy#Default" id="monix.reactive.OverflowStrategy#Default" class="extmbr">default one</a>.
</p></div><dl class="paramcmts block"><dt class="param">s</dt><dd class="cmt"><p>is the alternative <code>Scheduler</code> reference to use
       for observing events</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#observeOn[B&gt;:A](s:monix.execution.Scheduler,os:monix.reactive.OverflowStrategy[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#observeOn" id="monix.reactive.Observable#observeOn" class="extmbr">observeOn(Scheduler, OverflowStrategy)</a>
     for the version that allows customizing the
     <a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a>
     being used by the underlying buffer.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#onCancelTriggerError" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onCancelTriggerError:monix.reactive.Observable[A]"></a><a id="onCancelTriggerError:Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#onCancelTriggerError:monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onCancelTriggerError</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">If the connection is <a href="../execution/Cancelable.html#cancel():Unit" name="monix.execution.Cancelable#cancel" id="monix.execution.Cancelable#cancel" class="extmbr">cancelled</a>
then trigger a <code>CancellationException</code>.</p><div class="fullcomment"><div class="comment cmt"><p>If the connection is <a href="../execution/Cancelable.html#cancel():Unit" name="monix.execution.Cancelable#cancel" id="monix.execution.Cancelable#cancel" class="extmbr">cancelled</a>
then trigger a <code>CancellationException</code>.</p><p>A connection can be cancelled with the help of the
<a href="../execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a>
returned on <a href="#subscribe(subscriber:monix.reactive.observers.Subscriber[A]):monix.execution.Cancelable" name="monix.reactive.Observable#subscribe" id="monix.reactive.Observable#subscribe" class="extmbr">subscribe</a>.</p><p>Because the cancellation is effectively concurrent with the
signals the <a href="Observer.html" name="monix.reactive.Observer" id="monix.reactive.Observer" class="extype">Observer</a> receives and because
we need to uphold the contract, this operator will effectively
synchronize access to <a href="Observer.html#onNext(elem:A):scala.concurrent.Future[monix.execution.Ack]" name="monix.reactive.Observer#onNext" id="monix.reactive.Observer#onNext" class="extmbr">onNext</a>,
<a href="Observer.html#onComplete():Unit" name="monix.reactive.Observer#onComplete" id="monix.reactive.Observer#onComplete" class="extmbr">onComplete</a> and
<a href="Observer.html#onError(ex:Throwable):Unit" name="monix.reactive.Observer#onError" id="monix.reactive.Observer#onError" class="extmbr">onError</a>. It will also watch
out for asynchronous <a href="../execution/Ack$$Stop$.html" name="monix.execution.Ack.Stop" id="monix.execution.Ack.Stop" class="extype">Stop</a> events.</p><p>In other words, this operator does heavy synchronization, can
prove to be inefficient and you should avoid using it because
the signaled error can interfere with functionality from other
operators that use cancellation internally and cancellation in
general is a side-effecting operation that should be avoided,
unless it's necessary.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#onErrorFallbackTo" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorFallbackTo[B&gt;:A](that:monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="onErrorFallbackTo[B&gt;:A](Observable[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#onErrorFallbackTo[B&gt;:A](that:monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorFallbackTo</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="that">that: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.onErrorFallbackTo.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.onErrorFallbackTo.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns an Observable that mirrors the behavior of the source,
unless the source is terminated with an <code>onError</code>, in which case
the streaming of events continues with the specified backup
sequence.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that mirrors the behavior of the source,
unless the source is terminated with an <code>onError</code>, in which case
the streaming of events continues with the specified backup
sequence.</p><p>The created Observable mirrors the behavior of the source in
case the source does not end with an error.</p><p>NOTE that compared with <code>onErrorResumeNext</code> from Rx.NET, the
streaming is not resumed in case the source is terminated
normally with an <code>onComplete</code>.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>is a backup sequence that's being subscribed
       in case the source terminates with an error.</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#onErrorHandle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorHandle[B&gt;:A](f:Throwable=&gt;B):monix.reactive.Observable[B]"></a><a id="onErrorHandle[B&gt;:A]((Throwable)=&gt;B):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#onErrorHandle[B&gt;:A](f:Throwable=&gt;B):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorHandle</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="f">f: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <span name="monix.reactive.Observable.onErrorHandle.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.onErrorHandle.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns an observable that mirrors the behavior of the source,
unless the source is terminated with an <code>onError</code>, in which
case the streaming of events fallbacks to an observable
emitting a single element generated by the backup function.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an observable that mirrors the behavior of the source,
unless the source is terminated with an <code>onError</code>, in which
case the streaming of events fallbacks to an observable
emitting a single element generated by the backup function.</p><p>See <a href="#onErrorRecover[B&gt;:A](pf:PartialFunction[Throwable,B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#onErrorRecover" id="monix.reactive.Observable#onErrorRecover" class="extmbr">onErrorRecover</a> for the version that takes a
partial function as a parameter.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>- a function that matches errors with a
       backup element that is emitted when the source
       throws an error.</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#onErrorHandleWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorHandleWith[B&gt;:A](f:Throwable=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="onErrorHandleWith[B&gt;:A]((Throwable)=&gt;Observable[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#onErrorHandleWith[B&gt;:A](f:Throwable=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorHandleWith</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="f">f: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.onErrorHandleWith.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.onErrorHandleWith.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns an Observable that mirrors the behavior of the source,
unless the source is terminated with an <code>onError</code>, in which case
the streaming of events continues with the specified backup
sequence generated by the given function.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that mirrors the behavior of the source,
unless the source is terminated with an <code>onError</code>, in which case
the streaming of events continues with the specified backup
sequence generated by the given function.</p><p>See <a href="#onErrorRecoverWith[B&gt;:A](pf:PartialFunction[Throwable,monix.reactive.Observable[B]]):monix.reactive.Observable[B]" name="monix.reactive.Observable#onErrorRecoverWith" id="monix.reactive.Observable#onErrorRecoverWith" class="extmbr">onErrorRecoverWith</a> for the version that takes a
partial function as a parameter.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is a function that matches errors with a
       backup throwable that is subscribed when the source
       throws an error.</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#onErrorRecover" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRecover[B&gt;:A](pf:PartialFunction[Throwable,B]):monix.reactive.Observable[B]"></a><a id="onErrorRecover[B&gt;:A](PartialFunction[Throwable,B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#onErrorRecover[B&gt;:A](pf:PartialFunction[Throwable,B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRecover</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="pf">pf: <a href="https://www.scala-lang.org/api/2.13.3/scala/PartialFunction.html#scala.PartialFunction" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<span name="scala.Throwable" class="extype">Throwable</span>, <span name="monix.reactive.Observable.onErrorRecover.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.onErrorRecover.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns an observable that mirrors the behavior of the source,
unless the source is terminated with an <code>onError</code>, in which
case the streaming of events fallbacks to an observable
emitting a single element generated by the backup function.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an observable that mirrors the behavior of the source,
unless the source is terminated with an <code>onError</code>, in which
case the streaming of events fallbacks to an observable
emitting a single element generated by the backup function.</p><p>The created Observable mirrors the behavior of the source
in case the source does not end with an error or if the
thrown <code>Throwable</code> is not matched.</p><p>See <a href="#onErrorHandle[B&gt;:A](f:Throwable=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#onErrorHandle" id="monix.reactive.Observable#onErrorHandle" class="extmbr">onErrorHandle</a> for the version that takes a
total function as a parameter.
</p></div><dl class="paramcmts block"><dt class="param">pf</dt><dd class="cmt"><p>is a function that matches errors with a
       backup element that is emitted when the source
       throws an error.</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#onErrorRecoverWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRecoverWith[B&gt;:A](pf:PartialFunction[Throwable,monix.reactive.Observable[B]]):monix.reactive.Observable[B]"></a><a id="onErrorRecoverWith[B&gt;:A](PartialFunction[Throwable,Observable[B]]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#onErrorRecoverWith[B&gt;:A](pf:PartialFunction[Throwable,monix.reactive.Observable[B]]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRecoverWith</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="pf">pf: <a href="https://www.scala-lang.org/api/2.13.3/scala/PartialFunction.html#scala.PartialFunction" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<span name="scala.Throwable" class="extype">Throwable</span>, <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.onErrorRecoverWith.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.onErrorRecoverWith.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns an Observable that mirrors the behavior of the source,
unless the source is terminated with an <code>onError</code>, in which case
the streaming of events continues with the specified backup
sequence generated by the given function.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that mirrors the behavior of the source,
unless the source is terminated with an <code>onError</code>, in which case
the streaming of events continues with the specified backup
sequence generated by the given function.</p><p>The created Observable mirrors the behavior of the source in
case the source does not end with an error or if the thrown
<code>Throwable</code> is not matched.</p><p>See <a href="#onErrorHandleWith[B&gt;:A](f:Throwable=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#onErrorHandleWith" id="monix.reactive.Observable#onErrorHandleWith" class="extmbr">onErrorHandleWith</a> for the version that takes a
total function as a parameter.
</p></div><dl class="paramcmts block"><dt class="param">pf</dt><dd class="cmt"><p>is a function that matches errors with a
       backup throwable that is subscribed when the source
       throws an error.</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#onErrorRestart" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRestart(maxRetries:Long):monix.reactive.Observable[A]"></a><a id="onErrorRestart(Long):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#onErrorRestart(maxRetries:Long):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRestart</span><span class="params">(<span name="maxRetries">maxRetries: <a href="https://www.scala-lang.org/api/2.13.3/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns an Observable that mirrors the behavior of the source,
unless the source is terminated with an <code>onError</code>, in which case
it tries subscribing to the source again in the hope that it
will complete without an error.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that mirrors the behavior of the source,
unless the source is terminated with an <code>onError</code>, in which case
it tries subscribing to the source again in the hope that it
will complete without an error.</p><p>The number of retries is limited by the specified <code>maxRetries</code>
parameter, so for an Observable that always ends in error the
total number of subscriptions that will eventually happen is
<code>maxRetries + 1</code>.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#onErrorRestartIf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRestartIf(p:Throwable=&gt;Boolean):monix.reactive.Observable[A]"></a><a id="onErrorRestartIf((Throwable)=&gt;Boolean):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#onErrorRestartIf(p:Throwable=&gt;Boolean):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRestartIf</span><span class="params">(<span name="p">p: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns an Observable that mirrors the behavior of the source,
unless the source is terminated with an <code>onError</code>, in which case
it tries subscribing to the source again in the hope that it
will complete without an error.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that mirrors the behavior of the source,
unless the source is terminated with an <code>onError</code>, in which case
it tries subscribing to the source again in the hope that it
will complete without an error.</p><p>The given predicate establishes if the subscription should be
retried or not.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#onErrorRestartUnlimited" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRestartUnlimited:monix.reactive.Observable[A]"></a><a id="onErrorRestartUnlimited:Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#onErrorRestartUnlimited:monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRestartUnlimited</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns an Observable that mirrors the behavior of the source,
unless the source is terminated with an <code>onError</code>, in which case
it tries subscribing to the source again in the hope that it
will complete without an error.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that mirrors the behavior of the source,
unless the source is terminated with an <code>onError</code>, in which case
it tries subscribing to the source again in the hope that it
will complete without an error.</p><p>NOTE: The number of retries is unlimited, so something like
<code>Observable.error(new RuntimeException).onErrorRestartUnlimited</code>
will loop forever.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#pipeThrough" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="pipeThrough[I&gt;:A,B](pipe:monix.reactive.Pipe[I,B]):monix.reactive.Observable[B]"></a><a id="pipeThrough[I&gt;:A,B](Pipe[I,B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#pipeThrough[I&gt;:A,B](pipe:monix.reactive.Pipe[I,B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">pipeThrough</span><span class="tparams">[<span name="I">I &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>, <span name="B">B</span>]</span><span class="params">(<span name="pipe">pipe: <a href="Pipe.html" name="monix.reactive.Pipe" id="monix.reactive.Pipe" class="extype">Pipe</a>[<span name="monix.reactive.Observable.pipeThrough.I" class="extype">I</span>, <span name="monix.reactive.Observable.pipeThrough.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.pipeThrough.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Given a <a href="Pipe.html" name="monix.reactive.Pipe" id="monix.reactive.Pipe" class="extype">Pipe</a>, transform
the source observable with it.</p></li><li class="indented0 " name="monix.reactive.Observable#pipeThroughSelector" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="pipeThroughSelector[S&gt;:A,B,R](pipe:monix.reactive.Pipe[S,B],f:monix.reactive.Observable[B]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]"></a><a id="pipeThroughSelector[S&gt;:A,B,R](Pipe[S,B],(Observable[B])=&gt;Observable[R]):Observable[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#pipeThroughSelector[S&gt;:A,B,R](pipe:monix.reactive.Pipe[S,B],f:monix.reactive.Observable[B]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">pipeThroughSelector</span><span class="tparams">[<span name="S">S &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>, <span name="B">B</span>, <span name="R">R</span>]</span><span class="params">(<span name="pipe">pipe: <a href="Pipe.html" name="monix.reactive.Pipe" id="monix.reactive.Pipe" class="extype">Pipe</a>[<span name="monix.reactive.Observable.pipeThroughSelector.S" class="extype">S</span>, <span name="monix.reactive.Observable.pipeThroughSelector.B" class="extype">B</span>]</span>, <span name="f">f: (<a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.pipeThroughSelector.B" class="extype">B</span>]) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.pipeThroughSelector.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.pipeThroughSelector.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Returns an observable that emits the results of invoking a
specified selector on items emitted by a
<a href="observables/ConnectableObservable.html" name="monix.reactive.observables.ConnectableObservable" id="monix.reactive.observables.ConnectableObservable" class="extype">ConnectableObservable</a>,
which shares a single subscription to the underlying sequence.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an observable that emits the results of invoking a
specified selector on items emitted by a
<a href="observables/ConnectableObservable.html" name="monix.reactive.observables.ConnectableObservable" id="monix.reactive.observables.ConnectableObservable" class="extype">ConnectableObservable</a>,
which shares a single subscription to the underlying sequence.</p><p>This operators takes a possibly pure Observable, transforms it to
Hot Observable in the scope of supplied function and then returns
a pure Observable again. The function allows specyfing underlying
<a href="subjects/Subject.html" name="monix.reactive.subjects.Subject" id="monix.reactive.subjects.Subject" class="extype">monix.reactive.subjects.Subject</a> by means of <a href="Pipe.html" name="monix.reactive.Pipe" id="monix.reactive.Pipe" class="extype">monix.reactive.Pipe</a>.</p><h4>Example</h4><pre><span class="kw">import</span> monix.reactive._
<span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> scala.concurrent.duration._
<span class="kw">implicit</span> <span class="kw">val</span> os: OverflowStrategy[<span class="std">Nothing</span>] = OverflowStrategy.Default

<span class="kw">val</span> obs = Observable(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>)
  .doOnNext(i <span class="kw">=&gt;</span> Task(println(s<span class="lit">"Produced $$i"</span>)).delayExecution(<span class="num">1.</span>second))

<span class="kw">def</span> consume(name: <span class="std">String</span>, obs: Observable[<span class="std">Int</span>]): Observable[<span class="std">Unit</span>] =
  obs.mapEval(i <span class="kw">=&gt;</span> Task(println(s<span class="lit">"$$name: got $$i"</span>)))

obs.pipeThroughSelector(Pipe.replay[<span class="std">Int</span>], { (hot: Observable[<span class="std">Int</span>]) <span class="kw">=&gt;</span>
  Observable(
    consume(<span class="lit">"Consumer 1"</span>, hot),
    consume(<span class="lit">"Consumer 2"</span>, hot).delayExecution(<span class="num">2.</span>second)
  ).merge
})</pre><h4>Output</h4><p>  Produced 1
  Consumer 1: got 1
  Consumer 2: got 1
  Produced 2
  Consumer 1: got 2
  Consumer 2: got 2
  Produced 3
  Consumer 1: got 3
  Consumer 2: got 3</p><p>  Note how Consumer 2 received the same amount of elements as
  Consumer 1 despite subscribing later because of underlying ReplaySubject.
</p></div><dl class="paramcmts block"><dt class="param">pipe</dt><dd class="cmt"><p>is the <a href="Pipe.html" name="monix.reactive.Pipe" id="monix.reactive.Pipe" class="extype">Pipe</a> used to transform the source into a multicast
       (hot) observable that can be shared in the selector function</p></dd><dt class="param">f</dt><dd class="cmt"><p>is a selector function that can use the multicasted source sequence
       as many times as needed, without causing multiple subscriptions
       to the source sequence. Observers to the given source will
       receive all notifications of the source from the time of the
       subscription forward.</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#prepend" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="prepend[B&gt;:A](elem:B):monix.reactive.Observable[B]"></a><a id="prepend[B&gt;:A](B):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#prepend[B&gt;:A](elem:B):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">prepend</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="elem">elem: <span name="monix.reactive.Observable.prepend.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.prepend.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new Observable that emits the given element and then it
also emits the events of the source (prepend operation).</p></li><li class="indented0 " name="monix.reactive.Observable#publish" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="publish(implicits:monix.execution.Scheduler):monix.reactive.observables.ConnectableObservable[A]"></a><a id="publish(Scheduler):ConnectableObservable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#publish(implicits:monix.execution.Scheduler):monix.reactive.observables.ConnectableObservable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">publish</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="observables/ConnectableObservable.html" name="monix.reactive.observables.ConnectableObservable" id="monix.reactive.observables.ConnectableObservable" class="extype">ConnectableObservable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Converts this observable into a multicast observable, useful for
turning a cold observable into a hot one (i.e.</p><div class="fullcomment"><div class="comment cmt"><p>Converts this observable into a multicast observable, useful for
turning a cold observable into a hot one (i.e. whose source is
shared by all observers). The underlying subject used is a
<a href="subjects/PublishSubject.html" name="monix.reactive.subjects.PublishSubject" id="monix.reactive.subjects.PublishSubject" class="extype">PublishSubject</a>.</p><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#publishLast" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="publishLast(implicits:monix.execution.Scheduler):monix.reactive.observables.ConnectableObservable[A]"></a><a id="publishLast(Scheduler):ConnectableObservable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#publishLast(implicits:monix.execution.Scheduler):monix.reactive.observables.ConnectableObservable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">publishLast</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="observables/ConnectableObservable.html" name="monix.reactive.observables.ConnectableObservable" id="monix.reactive.observables.ConnectableObservable" class="extype">ConnectableObservable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Converts this observable into a multicast observable, useful for
turning a cold observable into a hot one (i.e.</p><div class="fullcomment"><div class="comment cmt"><p>Converts this observable into a multicast observable, useful for
turning a cold observable into a hot one (i.e. whose source is
shared by all observers). The underlying subject used is a
<a href="subjects/AsyncSubject.html" name="monix.reactive.subjects.AsyncSubject" id="monix.reactive.subjects.AsyncSubject" class="extype">AsyncSubject</a>.</p><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#publishSelector" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]"></a><a id="publishSelector[R]((Observable[A])=&gt;Observable[R]):Observable[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">publishSelector</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="f">f: (<a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.publishSelector.R" class="extype">R</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.publishSelector.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Returns an observable that emits the results of invoking a
specified selector on items emitted by a
<a href="observables/ConnectableObservable.html" name="monix.reactive.observables.ConnectableObservable" id="monix.reactive.observables.ConnectableObservable" class="extype">ConnectableObservable</a>
backed by <a href="subjects/PublishSubject.html" name="monix.reactive.subjects.PublishSubject" id="monix.reactive.subjects.PublishSubject" class="extype">PublishSubject</a>
which shares a single subscription to the underlying sequence.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an observable that emits the results of invoking a
specified selector on items emitted by a
<a href="observables/ConnectableObservable.html" name="monix.reactive.observables.ConnectableObservable" id="monix.reactive.observables.ConnectableObservable" class="extype">ConnectableObservable</a>
backed by <a href="subjects/PublishSubject.html" name="monix.reactive.subjects.PublishSubject" id="monix.reactive.subjects.PublishSubject" class="extype">PublishSubject</a>
which shares a single subscription to the underlying sequence.</p><p>This operators takes a possibly pure Observable, transforms it to
Hot Observable in the scope of supplied function and then returns
a pure Observable again.</p><h4>Example</h4><pre><span class="kw">import</span> monix.reactive._
<span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> scala.concurrent.duration._
<span class="kw">implicit</span> <span class="kw">val</span> os: OverflowStrategy[<span class="std">Nothing</span>] = OverflowStrategy.Default

<span class="kw">val</span> obs = Observable(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>)
  .doOnNext(i <span class="kw">=&gt;</span> Task(println(s<span class="lit">"Produced $$i"</span>)).delayExecution(<span class="num">1.</span>second))

<span class="kw">def</span> consume(name: <span class="std">String</span>, obs: Observable[<span class="std">Int</span>]): Observable[<span class="std">Unit</span>] =
  obs.mapEval(i <span class="kw">=&gt;</span> Task(println(s<span class="lit">"$$name: got $$i"</span>)))

obs.publishSelector { hot <span class="kw">=&gt;</span>
  Observable(
    consume(<span class="lit">"Consumer 1"</span>, hot),
    consume(<span class="lit">"Consumer 2"</span>, hot).delayExecution(<span class="num">2.</span>second)
  ).merge
}</pre><h4>Output</h4><p>  Produced 1
  Consumer 1: got 1
  Produced 2
  Consumer 1: got 2
  Consumer 2: got 2
  Produced 3
  Consumer 1: got 3
  Consumer 2: got 3</p><p>  Note how Consumer 2 received less elements because it subscribed later.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is a selector function that can use the multicasted source sequence
       as many times as needed, without causing multiple subscriptions
       to the source sequence. Observers to the given source will
       receive all notifications of the source from the time of the
       subscription forward.</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#pipeThroughSelector[S&gt;:A,B,R](pipe:monix.reactive.Pipe[S,B],f:monix.reactive.Observable[B]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#pipeThroughSelector" id="monix.reactive.Observable#pipeThroughSelector" class="extmbr">pipeThroughSelector</a> for a version that allows specifying a type of underlying Subject.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#reduce" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="reduce[B&gt;:A](op:(B,B)=&gt;B):monix.reactive.Observable[B]"></a><a id="reduce[B&gt;:A]((B,B)=&gt;B):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#reduce[B&gt;:A](op:(B,B)=&gt;B):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">reduce</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="op">op: (<span name="monix.reactive.Observable.reduce.B" class="extype">B</span>, <span name="monix.reactive.Observable.reduce.B" class="extype">B</span>) =&gt; <span name="monix.reactive.Observable.reduce.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.reduce.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Applies a binary operator to a start value and all elements of
this Observable, going left to right and returns a new
Observable that emits only one item before <code>onComplete</code>.</p></li><li class="indented0 " name="monix.reactive.Observable#repeat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="repeat:monix.reactive.Observable[A]"></a><a id="repeat:Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#repeat:monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">repeat</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Repeats the items emitted by the source continuously.</p><div class="fullcomment"><div class="comment cmt"><p>Repeats the items emitted by the source continuously. It
caches the generated items until <code>onComplete</code> and repeats them
forever.</p><p>It terminates either on error or if the source is empty.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#replay" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="replay(bufferSize:Int)(implicits:monix.execution.Scheduler):monix.reactive.observables.ConnectableObservable[A]"></a><a id="replay(Int)(Scheduler):ConnectableObservable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#replay(bufferSize:Int)(implicits:monix.execution.Scheduler):monix.reactive.observables.ConnectableObservable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">replay</span><span class="params">(<span name="bufferSize">bufferSize: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="observables/ConnectableObservable.html" name="monix.reactive.observables.ConnectableObservable" id="monix.reactive.observables.ConnectableObservable" class="extype">ConnectableObservable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Converts this observable into a multicast observable, useful for
turning a cold observable into a hot one (i.e.</p><div class="fullcomment"><div class="comment cmt"><p>Converts this observable into a multicast observable, useful for
turning a cold observable into a hot one (i.e. whose source is
shared by all observers). The underlying subject used is a
<a href="subjects/ReplaySubject.html" name="monix.reactive.subjects.ReplaySubject" id="monix.reactive.subjects.ReplaySubject" class="extype">ReplaySubject</a>.</p><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="paramcmts block"><dt class="param">bufferSize</dt><dd class="cmt"><p>is the size of the buffer limiting the number
       of items that can be replayed (on overflow the head
       starts being dropped)</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#replay" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="replay(implicits:monix.execution.Scheduler):monix.reactive.observables.ConnectableObservable[A]"></a><a id="replay(Scheduler):ConnectableObservable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#replay(implicits:monix.execution.Scheduler):monix.reactive.observables.ConnectableObservable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">replay</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="observables/ConnectableObservable.html" name="monix.reactive.observables.ConnectableObservable" id="monix.reactive.observables.ConnectableObservable" class="extype">ConnectableObservable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Converts this observable into a multicast observable, useful for
turning a cold observable into a hot one (i.e.</p><div class="fullcomment"><div class="comment cmt"><p>Converts this observable into a multicast observable, useful for
turning a cold observable into a hot one (i.e. whose source is
shared by all observers). The underlying subject used is a
<a href="subjects/ReplaySubject.html" name="monix.reactive.subjects.ReplaySubject" id="monix.reactive.subjects.ReplaySubject" class="extype">ReplaySubject</a>.</p><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#restartUntil" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="restartUntil(p:A=&gt;Boolean):monix.reactive.Observable[A]"></a><a id="restartUntil((A)=&gt;Boolean):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#restartUntil(p:A=&gt;Boolean):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">restartUntil</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Keeps restarting / resubscribing the source until the predicate
returns <code>true</code> for the the first emitted element, after which
it starts mirroring the source.</p></li><li class="indented0 " name="monix.reactive.Observable#runAsyncGetFirst" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runAsyncGetFirst(implicits:monix.execution.Scheduler,implicitopts:monix.eval.Task.Options):monix.execution.CancelableFuture[Option[A]]"></a><a id="runAsyncGetFirst(Scheduler,Options):CancelableFuture[Option[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#runAsyncGetFirst(implicits:monix.execution.Scheduler,implicitopts:monix.eval.Task.Options):monix.execution.CancelableFuture[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runAsyncGetFirst</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>, <span name="opts">opts: <a href="../eval/Task$$Options.html" name="monix.eval.Task.Options" id="monix.eval.Task.Options" class="extype">Options</a> = <span class="symbol"><span class="name"><a href="../index.html">defaultOptions</a></span></span></span>)</span><span class="result">: <a href="../execution/CancelableFuture.html" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Creates a new <a href="../execution/CancelableFuture.html" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a>
that upon execution will signal the first generated element of the
source observable.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new <a href="../execution/CancelableFuture.html" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a>
that upon execution will signal the first generated element of the
source observable. Returns an <code>Option</code> because the source can be empty.</p><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#runAsyncGetLast" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="runAsyncGetLast(implicits:monix.execution.Scheduler,implicitopts:monix.eval.Task.Options):monix.execution.CancelableFuture[Option[A]]"></a><a id="runAsyncGetLast(Scheduler,Options):CancelableFuture[Option[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#runAsyncGetLast(implicits:monix.execution.Scheduler,implicitopts:monix.eval.Task.Options):monix.execution.CancelableFuture[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">runAsyncGetLast</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>, <span name="opts">opts: <a href="../eval/Task$$Options.html" name="monix.eval.Task.Options" id="monix.eval.Task.Options" class="extype">Options</a> = <span class="symbol"><span class="name"><a href="../index.html">defaultOptions</a></span></span></span>)</span><span class="result">: <a href="../execution/CancelableFuture.html" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Creates a new <a href="../execution/CancelableFuture.html" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a>
that upon execution will signal the last generated element of the
source observable.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new <a href="../execution/CancelableFuture.html" name="monix.execution.CancelableFuture" id="monix.execution.CancelableFuture" class="extype">CancelableFuture</a>
that upon execution will signal the last generated element of the
source observable. Returns an <code>Option</code> because the source can be empty.</p><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#sample" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sample(period:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]"></a><a id="sample(FiniteDuration):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#sample(period:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sample</span><span class="params">(<span name="period">period: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Emit the most recent items emitted by the source within
periodic time intervals.</p><div class="fullcomment"><div class="comment cmt"><p>Emit the most recent items emitted by the source within
periodic time intervals.</p><p>Use the <code>sample</code> operator to periodically look at an observable
to see what item it has most recently emitted since the previous
sampling. Note that if the source observable has emitted no
items since the last time it was sampled, the observable that
results from the <code>sample</code> operator will emit no item for that
sampling period.</p><p>Usage:</p><pre><span class="kw">import</span> scala.concurrent.duration._

<span class="cmt">// emits 3, 8, 10 in 1 second intervals</span>
Observable.fromIterable(<span class="num">0</span> to <span class="num">10</span>)
  <span class="cmt">// without delay, it would return only 10</span>
  .delayOnNext(<span class="num">200.</span>millis)
  .sample(<span class="num">1.</span>second)</pre></div><dl class="paramcmts block"><dt class="param">period</dt><dd class="cmt"><p>the timespan at which sampling occurs</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#sampleBy[B](sampler:monix.reactive.Observable[B]):monix.reactive.Observable[A]" name="monix.reactive.Observable#sampleBy" id="monix.reactive.Observable#sampleBy" class="extmbr">sampleBy</a> for fine control</p></span><span class="cmt"><p><a href="#sampleRepeated(period:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#sampleRepeated" id="monix.reactive.Observable#sampleRepeated" class="extmbr">sampleRepeated</a> for repeating the last value on silence</p></span><span class="cmt"><p><a href="#throttle(period:scala.concurrent.duration.FiniteDuration,n:Int):monix.reactive.Observable[A]" name="monix.reactive.Observable#throttle" id="monix.reactive.Observable#throttle" class="extmbr">throttle</a> for a version that allows to specify number
     of elements processed by a period and does not drop any elements</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#sampleBy" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sampleBy[B](sampler:monix.reactive.Observable[B]):monix.reactive.Observable[A]"></a><a id="sampleBy[B](Observable[B]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#sampleBy[B](sampler:monix.reactive.Observable[B]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sampleBy</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="sampler">sampler: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.sampleBy.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns an observable that, when the specified sampler
emits an item or completes, emits the most recently emitted item
(if any) emitted by the source since the previous
emission from the sampler.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an observable that, when the specified sampler
emits an item or completes, emits the most recently emitted item
(if any) emitted by the source since the previous
emission from the sampler.</p><p>Use the <code>sampleBy</code> operator to periodically look at an observable
to see what item it has most recently emitted since the previous
sampling. Note that if the source observable has emitted no
items since the last time it was sampled, the observable that
results from the <code>sampleBy</code> operator will emit no item.
</p></div><dl class="paramcmts block"><dt class="param">sampler</dt><dd class="cmt"><p>- the observable to use for sampling the source</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#sample(period:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#sample" id="monix.reactive.Observable#sample" class="extmbr">sample</a> for periodic sampling</p></span><span class="cmt"><p><a href="#sampleRepeatedBy[B](sampler:monix.reactive.Observable[B]):monix.reactive.Observable[A]" name="monix.reactive.Observable#sampleRepeatedBy" id="monix.reactive.Observable#sampleRepeatedBy" class="extmbr">sampleRepeatedBy</a> for repeating the last value on silence</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#sampleRepeated" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sampleRepeated(period:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]"></a><a id="sampleRepeated(FiniteDuration):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#sampleRepeated(period:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sampleRepeated</span><span class="params">(<span name="period">period: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Emit the most recent items emitted by an observable within
periodic time intervals.</p><div class="fullcomment"><div class="comment cmt"><p>Emit the most recent items emitted by an observable within
periodic time intervals. If no new value has been emitted since
the last time it was sampled, it signals the last emitted value
anyway.
</p></div><dl class="paramcmts block"><dt class="param">period</dt><dd class="cmt"><p>the timespan at which sampling occurs</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#sample(period:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#sample" id="monix.reactive.Observable#sample" class="extmbr">sample</a> for a variant that doesn't repeat the last value on silence</p></span><span class="cmt"><p><a href="#sampleRepeatedBy[B](sampler:monix.reactive.Observable[B]):monix.reactive.Observable[A]" name="monix.reactive.Observable#sampleRepeatedBy" id="monix.reactive.Observable#sampleRepeatedBy" class="extmbr">sampleRepeatedBy</a> for fine control</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#sampleRepeatedBy" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sampleRepeatedBy[B](sampler:monix.reactive.Observable[B]):monix.reactive.Observable[A]"></a><a id="sampleRepeatedBy[B](Observable[B]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#sampleRepeatedBy[B](sampler:monix.reactive.Observable[B]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sampleRepeatedBy</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="sampler">sampler: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.sampleRepeatedBy.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns an observable that, when the specified sampler observable
emits an item or completes, emits the most recently emitted item
(if any) emitted by the source Observable since the previous
emission from the sampler observable.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an observable that, when the specified sampler observable
emits an item or completes, emits the most recently emitted item
(if any) emitted by the source Observable since the previous
emission from the sampler observable. If no new value has been
emitted since the last time it was sampled, it signals the last
emitted value anyway.
</p></div><dl class="paramcmts block"><dt class="param">sampler</dt><dd class="cmt"><p>- the Observable to use for sampling the source Observable</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#sampleBy[B](sampler:monix.reactive.Observable[B]):monix.reactive.Observable[A]" name="monix.reactive.Observable#sampleBy" id="monix.reactive.Observable#sampleBy" class="extmbr">sampleBy</a> for a variant that doesn't repeat the last value on silence</p></span><span class="cmt"><p><a href="#sampleRepeated(period:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#sampleRepeated" id="monix.reactive.Observable#sampleRepeated" class="extmbr">sampleRepeated</a> for a periodic sampling</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#scan" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scan[S](seed:=&gt;S)(op:(S,A)=&gt;S):monix.reactive.Observable[S]"></a><a id="scan[S](=&gt;S)((S,A)=&gt;S):Observable[S]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#scan[S](seed:=&gt;S)(op:(S,A)=&gt;S):monix.reactive.Observable[S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scan</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: =&gt; <span name="monix.reactive.Observable.scan.S" class="extype">S</span></span>)</span><span class="params">(<span name="op">op: (<span name="monix.reactive.Observable.scan.S" class="extype">S</span>, <span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.scan.S" class="extype">S</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.scan.S" class="extype">S</span>]</span></span><p class="shortcomment cmt">Applies a binary operator to a start value and all elements of
this Observable, going left to right and returns a new
Observable that emits on each step the result of the applied
function.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a binary operator to a start value and all elements of
this Observable, going left to right and returns a new
Observable that emits on each step the result of the applied
function.</p><p>Similar to <a href="#foldLeft[R](seed:=&gt;R)(op:(R,A)=&gt;R):monix.reactive.Observable[R]" name="monix.reactive.Observable#foldLeft" id="monix.reactive.Observable#foldLeft" class="extmbr">foldLeft</a>, but emits the state on each
step. Useful for modeling finite state machines.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#scan0[S](seed:=&gt;S)(op:(S,A)=&gt;S):monix.reactive.Observable[S]" name="monix.reactive.Observable#scan0" id="monix.reactive.Observable#scan0" class="extmbr">scan0</a> for the version that emits seed element at the beginning</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#scan0" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scan0[S](seed:=&gt;S)(op:(S,A)=&gt;S):monix.reactive.Observable[S]"></a><a id="scan0[S](=&gt;S)((S,A)=&gt;S):Observable[S]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#scan0[S](seed:=&gt;S)(op:(S,A)=&gt;S):monix.reactive.Observable[S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scan0</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: =&gt; <span name="monix.reactive.Observable.scan0.S" class="extype">S</span></span>)</span><span class="params">(<span name="op">op: (<span name="monix.reactive.Observable.scan0.S" class="extype">S</span>, <span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.scan0.S" class="extype">S</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.scan0.S" class="extype">S</span>]</span></span><p class="shortcomment cmt">Applies a binary operator to a start value and all elements of
this Observable, going left to right and returns a new
Observable that emits on each step the result of the applied
function.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a binary operator to a start value and all elements of
this Observable, going left to right and returns a new
Observable that emits on each step the result of the applied
function.</p><p>This is a version of <a href="#scan[S](seed:=&gt;S)(op:(S,A)=&gt;S):monix.reactive.Observable[S]" name="monix.reactive.Observable#scan" id="monix.reactive.Observable#scan" class="extmbr">scan</a> that emits seed element at the beginning,
similar to <code>scanLeft</code> on Scala collections
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#scanEval" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scanEval[S](seed:monix.eval.Task[S])(op:(S,A)=&gt;monix.eval.Task[S]):monix.reactive.Observable[S]"></a><a id="scanEval[S](Task[S])((S,A)=&gt;Task[S]):Observable[S]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#scanEval[S](seed:monix.eval.Task[S])(op:(S,A)=&gt;monix.eval.Task[S]):monix.reactive.Observable[S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scanEval</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="monix.reactive.Observable.scanEval.S" class="extype">S</span>]</span>)</span><span class="params">(<span name="op">op: (<span name="monix.reactive.Observable.scanEval.S" class="extype">S</span>, <span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="monix.reactive.Observable.scanEval.S" class="extype">S</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.scanEval.S" class="extype">S</span>]</span></span><p class="shortcomment cmt">Applies a binary operator to a start value and all elements of
this stream, going left to right and returns a new stream that
emits on each step the result of the applied function.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a binary operator to a start value and all elements of
this stream, going left to right and returns a new stream that
emits on each step the result of the applied function.</p><p>Similar with <a href="#scan[S](seed:=&gt;S)(op:(S,A)=&gt;S):monix.reactive.Observable[S]" name="monix.reactive.Observable#scan" id="monix.reactive.Observable#scan" class="extmbr">scan</a>, but this can suspend and evaluate
side effects with <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>, thus allowing for
asynchronous data processing.</p><p>Similar to <a href="#foldLeft[R](seed:=&gt;R)(op:(R,A)=&gt;R):monix.reactive.Observable[R]" name="monix.reactive.Observable#foldLeft" id="monix.reactive.Observable#foldLeft" class="extmbr">foldLeft</a> and <a href="#foldWhileLeft[S](seed:=&gt;S)(op:(S,A)=&gt;Either[S,S]):monix.reactive.Observable[S]" name="monix.reactive.Observable#foldWhileLeft" id="monix.reactive.Observable#foldWhileLeft" class="extmbr">foldWhileLeft</a>, but emits the
state on each step. Useful for modeling finite state machines.</p><p>Example showing how state can be evolved and acted upon:</p><pre><span class="kw">import</span> monix.eval.Task

<span class="kw">sealed</span> <span class="kw">trait</span> State[+A] { <span class="kw">def</span> count: <span class="std">Int</span> }
<span class="kw">case</span> <span class="kw">object</span> Init <span class="kw">extends</span> State[<span class="std">Nothing</span>] { <span class="kw">def</span> count = <span class="num">0</span> }
<span class="kw">case</span> <span class="kw">class</span> Current[A](current: <span class="std">Option</span>[A], count: <span class="std">Int</span>)
  <span class="kw">extends</span> State[A]

<span class="kw">case</span> <span class="kw">class</span> Person(id: <span class="std">Int</span>, name: <span class="std">String</span>)

<span class="cmt">// TODO: to implement!</span>
<span class="kw">def</span> requestPersonDetails(id: <span class="std">Int</span>): Task[<span class="std">Option</span>[Person]] =
  Task.raiseError(<span class="kw">new</span> NotImplementedError)

<span class="cmt">// TODO: to implement</span>
<span class="kw">val</span> source: Observable[<span class="std">Int</span>] =
  Observable.raiseError(<span class="kw">new</span> NotImplementedError)

<span class="cmt">// Initial state</span>
<span class="kw">val</span> seed = Task.pure(Init : State[Person])

<span class="kw">val</span> scanned = source.scanEval(seed) { (state, id) <span class="kw">=&gt;</span>
  requestPersonDetails(id).map { person <span class="kw">=&gt;</span>
    state <span class="kw">match</span> {
      <span class="kw">case</span> Init <span class="kw">=&gt;</span>
        Current(person, <span class="num">1</span>)
      <span class="kw">case</span> Current(_, count) <span class="kw">=&gt;</span>
        Current(person, count + <span class="num">1</span>)
    }
  }
}

<span class="kw">val</span> filtered = scanned
  .takeWhile(_.count &lt; <span class="num">10</span>)
  .collect { <span class="kw">case</span> Current(a, _) <span class="kw">=&gt;</span> a }</pre></div><dl class="paramcmts block"><dt class="param">seed</dt><dd class="cmt"><p>is the initial state</p></dd><dt class="param">op</dt><dd class="cmt"><p>is the function that evolves the current state</p></dd><dt>returns</dt><dd class="cmt"><p>a new observable that emits all intermediate states being
        resulted from applying the given function</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#scanEval0[S](seed:monix.eval.Task[S])(op:(S,A)=&gt;monix.eval.Task[S]):monix.reactive.Observable[S]" name="monix.reactive.Observable#scanEval0" id="monix.reactive.Observable#scanEval0" class="extmbr">scanEval0</a> for the version that emits seed element at the beginning</p></span><span class="cmt"><p><a href="#scan[S](seed:=&gt;S)(op:(S,A)=&gt;S):monix.reactive.Observable[S]" name="monix.reactive.Observable#scan" id="monix.reactive.Observable#scan" class="extmbr">scan</a> for the version that does not require using <code>Task</code>
     in the provided operator</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#scanEval0" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scanEval0[S](seed:monix.eval.Task[S])(op:(S,A)=&gt;monix.eval.Task[S]):monix.reactive.Observable[S]"></a><a id="scanEval0[S](Task[S])((S,A)=&gt;Task[S]):Observable[S]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#scanEval0[S](seed:monix.eval.Task[S])(op:(S,A)=&gt;monix.eval.Task[S]):monix.reactive.Observable[S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scanEval0</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="monix.reactive.Observable.scanEval0.S" class="extype">S</span>]</span>)</span><span class="params">(<span name="op">op: (<span name="monix.reactive.Observable.scanEval0.S" class="extype">S</span>, <span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="monix.reactive.Observable.scanEval0.S" class="extype">S</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.scanEval0.S" class="extype">S</span>]</span></span><p class="shortcomment cmt">Applies a binary operator to a start value and all elements of
this stream, going left to right and returns a new stream that
emits on each step the result of the applied function.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a binary operator to a start value and all elements of
this stream, going left to right and returns a new stream that
emits on each step the result of the applied function.</p><p>This is a version of <a href="#scanEval[S](seed:monix.eval.Task[S])(op:(S,A)=&gt;monix.eval.Task[S]):monix.reactive.Observable[S]" name="monix.reactive.Observable#scanEval" id="monix.reactive.Observable#scanEval" class="extmbr">scanEval</a> that emits seed element at the beginning.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#scanEval0F" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scanEval0F[F[_],S](seed:F[S])(op:(S,A)=&gt;F[S])(implicitF:monix.eval.TaskLike[F],implicitA:cats.Applicative[F]):monix.reactive.Observable[S]"></a><a id="scanEval0F[F[_],S](F[S])((S,A)=&gt;F[S])(TaskLike[F],Applicative[F]):Observable[S]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#scanEval0F[F[_],S](seed:F[S])(op:(S,A)=&gt;F[S])(implicitF:monix.eval.TaskLike[F],implicitA:cats.Applicative[F]):monix.reactive.Observable[S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scanEval0F</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="S">S</span>]</span><span class="params">(<span name="seed">seed: <span name="monix.reactive.Observable.scanEval0F.F" class="extype">F</span>[<span name="monix.reactive.Observable.scanEval0F.S" class="extype">S</span>]</span>)</span><span class="params">(<span name="op">op: (<span name="monix.reactive.Observable.scanEval0F.S" class="extype">S</span>, <span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.scanEval0F.F" class="extype">F</span>[<span name="monix.reactive.Observable.scanEval0F.S" class="extype">S</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.scanEval0F.F" class="extype">F</span>]</span>, <span name="A">A: <a href="http://typelevel.org/cats/api/cats/Applicative.html#cats.Applicative" name="cats.Applicative" id="cats.Applicative" class="extype">Applicative</a>[<span name="monix.reactive.Observable.scanEval0F.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.scanEval0F.S" class="extype">S</span>]</span></span><p class="shortcomment cmt">Applies a binary operator to a start value and all elements of
this stream, going left to right and returns a new stream that
emits on each step the result of the applied function.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a binary operator to a start value and all elements of
this stream, going left to right and returns a new stream that
emits on each step the result of the applied function.</p><p>This is a version of <a href="#scanEvalF[F[_],S](seed:F[S])(op:(S,A)=&gt;F[S])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[S]" name="monix.reactive.Observable#scanEvalF" id="monix.reactive.Observable#scanEvalF" class="extmbr">scanEvalF</a> that emits seed element at the beginning,
similar to <code>scanLeft</code> on Scala collections
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#scanEvalF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scanEvalF[F[_],S](seed:F[S])(op:(S,A)=&gt;F[S])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[S]"></a><a id="scanEvalF[F[_],S](F[S])((S,A)=&gt;F[S])(TaskLike[F]):Observable[S]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#scanEvalF[F[_],S](seed:F[S])(op:(S,A)=&gt;F[S])(implicitF:monix.eval.TaskLike[F]):monix.reactive.Observable[S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scanEvalF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="S">S</span>]</span><span class="params">(<span name="seed">seed: <span name="monix.reactive.Observable.scanEvalF.F" class="extype">F</span>[<span name="monix.reactive.Observable.scanEvalF.S" class="extype">S</span>]</span>)</span><span class="params">(<span name="op">op: (<span name="monix.reactive.Observable.scanEvalF.S" class="extype">S</span>, <span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.scanEvalF.F" class="extype">F</span>[<span name="monix.reactive.Observable.scanEvalF.S" class="extype">S</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.scanEvalF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.scanEvalF.S" class="extype">S</span>]</span></span><p class="shortcomment cmt">Applies a binary operator to a start value and all elements of
this stream, going left to right and returns a new stream that
emits on each step the result of the applied function.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a binary operator to a start value and all elements of
this stream, going left to right and returns a new stream that
emits on each step the result of the applied function.</p><p>Similar with <a href="#scan[S](seed:=&gt;S)(op:(S,A)=&gt;S):monix.reactive.Observable[S]" name="monix.reactive.Observable#scan" id="monix.reactive.Observable#scan" class="extmbr">scan</a>, but this can suspend and evaluate
side effects with an <code>F[_]</code> data type that implements the
<code>cats.effect.Effect</code> type class, thus allowing for lazy or
asynchronous data processing.</p><p>Similar to <a href="#foldLeft[R](seed:=&gt;R)(op:(R,A)=&gt;R):monix.reactive.Observable[R]" name="monix.reactive.Observable#foldLeft" id="monix.reactive.Observable#foldLeft" class="extmbr">foldLeft</a> and <a href="#foldWhileLeft[S](seed:=&gt;S)(op:(S,A)=&gt;Either[S,S]):monix.reactive.Observable[S]" name="monix.reactive.Observable#foldWhileLeft" id="monix.reactive.Observable#foldWhileLeft" class="extmbr">foldWhileLeft</a>, but emits the
state on each step. Useful for modeling finite state machines.</p><p>Example showing how state can be evolved and acted upon:</p><pre><span class="cmt">// Using cats.effect.IO for evaluating our side effects</span>
<span class="kw">import</span> cats.effect.IO

<span class="kw">sealed</span> <span class="kw">trait</span> State[+A] { <span class="kw">def</span> count: <span class="std">Int</span> }
<span class="kw">case</span> <span class="kw">object</span> Init <span class="kw">extends</span> State[<span class="std">Nothing</span>] { <span class="kw">def</span> count = <span class="num">0</span> }
<span class="kw">case</span> <span class="kw">class</span> Current[A](current: <span class="std">Option</span>[A], count: <span class="std">Int</span>)
  <span class="kw">extends</span> State[A]

<span class="kw">case</span> <span class="kw">class</span> Person(id: <span class="std">Int</span>, name: <span class="std">String</span>)

<span class="cmt">// TODO: to implement!</span>
<span class="kw">def</span> requestPersonDetails(id: <span class="std">Int</span>): IO[<span class="std">Option</span>[Person]] =
  IO.raiseError(<span class="kw">new</span> NotImplementedError)

<span class="cmt">// TODO: to implement</span>
<span class="kw">val</span> source: Observable[<span class="std">Int</span>] =
  Observable.raiseError(<span class="kw">new</span> NotImplementedError)

<span class="cmt">// Initial state</span>
<span class="kw">val</span> seed = IO.pure(Init : State[Person])

<span class="kw">val</span> scanned = source.scanEvalF(seed) { (state, id) <span class="kw">=&gt;</span>
  requestPersonDetails(id).map { person <span class="kw">=&gt;</span>
    state <span class="kw">match</span> {
      <span class="kw">case</span> Init <span class="kw">=&gt;</span>
        Current(person, <span class="num">1</span>)
      <span class="kw">case</span> Current(_, count) <span class="kw">=&gt;</span>
        Current(person, count + <span class="num">1</span>)
    }
  }
}

<span class="kw">val</span> filtered = scanned
  .takeWhile(_.count &lt; <span class="num">10</span>)
  .collect { <span class="kw">case</span> Current(a, _) <span class="kw">=&gt;</span> a }</pre></div><dl class="paramcmts block"><dt class="param">seed</dt><dd class="cmt"><p>is the initial state</p></dd><dt class="param">op</dt><dd class="cmt"><p>is the function that evolves the current state</p></dd><dt class="param">F</dt><dd class="cmt"><p>is the <code>cats.effect.Effect</code> type class implementation
       for type <code>F</code>, which controls the evaluation. <code>F</code> can be
       a data type such as <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">monix.eval.Task</a> or <code>cats.effect.IO</code>,
       which implement <code>Effect</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>a new observable that emits all intermediate states being
        resulted from applying the given function</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#scanEval0F[F[_],S](seed:F[S])(op:(S,A)=&gt;F[S])(implicitF:monix.eval.TaskLike[F],implicitA:cats.Applicative[F]):monix.reactive.Observable[S]" name="monix.reactive.Observable#scanEval0F" id="monix.reactive.Observable#scanEval0F" class="extmbr">scanEval0F</a> for the version that emits seed element at the beginning</p></span><span class="cmt"><p><a href="#scan[S](seed:=&gt;S)(op:(S,A)=&gt;S):monix.reactive.Observable[S]" name="monix.reactive.Observable#scan" id="monix.reactive.Observable#scan" class="extmbr">scan</a> for the synchronous, non-lazy version, or
     <a href="#scanEval[S](seed:monix.eval.Task[S])(op:(S,A)=&gt;monix.eval.Task[S]):monix.reactive.Observable[S]" name="monix.reactive.Observable#scanEval" id="monix.reactive.Observable#scanEval" class="extmbr">scanEval</a> for the <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>-specialized
     version.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#scanMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scanMap[B](f:A=&gt;B)(implicitB:cats.Monoid[B]):monix.reactive.Observable[B]"></a><a id="scanMap[B]((A)=&gt;B)(Monoid[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#scanMap[B](f:A=&gt;B)(implicitB:cats.Monoid[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scanMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.scanMap.B" class="extype">B</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="B">B: <span name="cats.Monoid" class="extype">Monoid</span>[<span name="monix.reactive.Observable.scanMap.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.scanMap.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Given a mapping function that returns a <code>B</code> type for which we have
a <a href="http://typelevel.org/cats/api/cats/index.html#Monoid[A]=cats.kernel.Monoid[A]" name="cats" id="cats" class="extype">cats.Monoid</a> instance, returns a new stream that folds the incoming
elements of the sources using the provided <code>Monoid[B].combine</code>, with the
initial seed being the <code>Monoid[B].empty</code> value, emitting the generated values
at each step.</p><div class="fullcomment"><div class="comment cmt"><p>Given a mapping function that returns a <code>B</code> type for which we have
a <a href="http://typelevel.org/cats/api/cats/index.html#Monoid[A]=cats.kernel.Monoid[A]" name="cats" id="cats" class="extype">cats.Monoid</a> instance, returns a new stream that folds the incoming
elements of the sources using the provided <code>Monoid[B].combine</code>, with the
initial seed being the <code>Monoid[B].empty</code> value, emitting the generated values
at each step.</p><p>Equivalent with <a href="#scan[S](seed:=&gt;S)(op:(S,A)=&gt;S):monix.reactive.Observable[S]" name="monix.reactive.Observable#scan" id="monix.reactive.Observable#scan" class="extmbr">scan</a> applied with the given <a href="http://typelevel.org/cats/api/cats/index.html#Monoid[A]=cats.kernel.Monoid[A]" name="cats" id="cats" class="extype">cats.Monoid</a>, so given
our <code>f</code> mapping function returns a <code>B</code>, this law holds:</p><p><pre>
val B = implicitly[Monoid[B]]

stream.scanMap(f) <-> stream.scan(B.empty)(B.combine)
</pre></p><p>Example:</p><pre><span class="kw">import</span> cats.implicits._

<span class="cmt">// Yields 2, 6, 12, 20, 30, 42</span>
<span class="kw">val</span> stream = Observable(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).scanMap(x <span class="kw">=&gt;</span> x * <span class="num">2</span>)</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the mapping function applied to every incoming element of this <code>Observable</code>
         before folding using <code>Monoid[B].combine</code></p></dd><dt>returns</dt><dd class="cmt"><p>a new <code>Observable</code> that emits all intermediate states being
        resulted from applying <code>Monoid[B].combine</code> function</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#scanMap0" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scanMap0[B](f:A=&gt;B)(implicitB:cats.Monoid[B]):monix.reactive.Observable[B]"></a><a id="scanMap0[B]((A)=&gt;B)(Monoid[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#scanMap0[B](f:A=&gt;B)(implicitB:cats.Monoid[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scanMap0</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.scanMap0.B" class="extype">B</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="B">B: <span name="cats.Monoid" class="extype">Monoid</span>[<span name="monix.reactive.Observable.scanMap0.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.scanMap0.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Given a mapping function that returns a <code>B</code> type for which we have
a <a href="http://typelevel.org/cats/api/cats/index.html#Monoid[A]=cats.kernel.Monoid[A]" name="cats" id="cats" class="extype">cats.Monoid</a> instance, returns a new stream that folds the incoming
elements of the sources using the provided <code>Monoid[B].combine</code>, with the
initial seed being the <code>Monoid[B].empty</code> value, emitting the generated values
at each step.</p><div class="fullcomment"><div class="comment cmt"><p>Given a mapping function that returns a <code>B</code> type for which we have
a <a href="http://typelevel.org/cats/api/cats/index.html#Monoid[A]=cats.kernel.Monoid[A]" name="cats" id="cats" class="extype">cats.Monoid</a> instance, returns a new stream that folds the incoming
elements of the sources using the provided <code>Monoid[B].combine</code>, with the
initial seed being the <code>Monoid[B].empty</code> value, emitting the generated values
at each step.</p><p>This is a version of <a href="#scanMap[B](f:A=&gt;B)(implicitB:cats.Monoid[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#scanMap" id="monix.reactive.Observable#scanMap" class="extmbr">scanMap</a> that emits seed element at the beginning.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#share" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="share(implicits:monix.execution.Scheduler):monix.reactive.Observable[A]"></a><a id="share(Scheduler):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#share(implicits:monix.execution.Scheduler):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">share</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns a new Observable that multi-casts (shares) the original Observable
between multiple consumers.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new Observable that multi-casts (shares) the original Observable
between multiple consumers.</p><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#startWith" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="startWith[B&gt;:A](elems:Seq[B]):monix.reactive.Observable[B]"></a><a id="startWith[B&gt;:A](Seq[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#startWith[B&gt;:A](elems:Seq[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">startWith</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="elems">elems: <span name="scala.Seq" class="extype">Seq</span>[<span name="monix.reactive.Observable.startWith.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.startWith.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Creates a new Observable that emits the given elements and then
it also emits the events of the source (prepend operation).</p></li><li class="indented0 " name="monix.reactive.Observable#subscribe" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="subscribe(nextFn:A=&gt;scala.concurrent.Future[monix.execution.Ack],errorFn:Throwable=&gt;Unit,completedFn:()=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable"></a><a id="subscribe((A)=&gt;Future[Ack],(Throwable)=&gt;Unit,()=&gt;Unit)(Scheduler):Cancelable"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#subscribe(nextFn:A=&gt;scala.concurrent.Future[monix.execution.Ack],errorFn:Throwable=&gt;Unit,completedFn:()=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">subscribe</span><span class="params">(<span name="nextFn">nextFn: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="../execution/Ack.html" name="monix.execution.Ack" id="monix.execution.Ack" class="extype">Ack</a>]</span>, <span name="errorFn">errorFn: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>, <span name="completedFn">completedFn: () =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="../execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a></span></span><p class="shortcomment cmt">Subscribes to the stream.</p><div class="fullcomment"><div class="comment cmt"><p>Subscribes to the stream.</p><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a subscription that can be used to cancel the streaming.</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd><dt>See also</dt><dd><span class="cmt"><p><a href="#consumeWith[R](f:monix.reactive.Consumer[A,R]):monix.eval.Task[R]" name="monix.reactive.Observable#consumeWith" id="monix.reactive.Observable#consumeWith" class="extmbr">consumeWith</a> for another way of consuming observables</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#subscribe" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="subscribe(nextFn:A=&gt;scala.concurrent.Future[monix.execution.Ack])(implicits:monix.execution.Scheduler):monix.execution.Cancelable"></a><a id="subscribe((A)=&gt;Future[Ack])(Scheduler):Cancelable"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#subscribe(nextFn:A=&gt;scala.concurrent.Future[monix.execution.Ack])(implicits:monix.execution.Scheduler):monix.execution.Cancelable" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">subscribe</span><span class="params">(<span name="nextFn">nextFn: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="../execution/Ack.html" name="monix.execution.Ack" id="monix.execution.Ack" class="extype">Ack</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="../execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a></span></span><p class="shortcomment cmt">Subscribes to the stream.</p><div class="fullcomment"><div class="comment cmt"><p>Subscribes to the stream.</p><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a subscription that can be used to cancel the streaming.</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd><dt>See also</dt><dd><span class="cmt"><p><a href="#consumeWith[R](f:monix.reactive.Consumer[A,R]):monix.eval.Task[R]" name="monix.reactive.Observable#consumeWith" id="monix.reactive.Observable#consumeWith" class="extmbr">consumeWith</a> for another way of consuming observables</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#subscribe" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="subscribe()(implicits:monix.execution.Scheduler):monix.execution.Cancelable"></a><a id="subscribe()(Scheduler):Cancelable"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#subscribe()(implicits:monix.execution.Scheduler):monix.execution.Cancelable" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">subscribe</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="../execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a></span></span><p class="shortcomment cmt">Subscribes to the stream.</p><div class="fullcomment"><div class="comment cmt"><p>Subscribes to the stream.</p><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a subscription that can be used to cancel the streaming.</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd><dt>See also</dt><dd><span class="cmt"><p><a href="#consumeWith[R](f:monix.reactive.Consumer[A,R]):monix.eval.Task[R]" name="monix.reactive.Observable#consumeWith" id="monix.reactive.Observable#consumeWith" class="extmbr">consumeWith</a> for another way of consuming observables</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#subscribe" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="subscribe(nextFn:A=&gt;scala.concurrent.Future[monix.execution.Ack],errorFn:Throwable=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable"></a><a id="subscribe((A)=&gt;Future[Ack],(Throwable)=&gt;Unit)(Scheduler):Cancelable"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#subscribe(nextFn:A=&gt;scala.concurrent.Future[monix.execution.Ack],errorFn:Throwable=&gt;Unit)(implicits:monix.execution.Scheduler):monix.execution.Cancelable" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">subscribe</span><span class="params">(<span name="nextFn">nextFn: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/Future.html#scala.concurrent.Future" name="scala.concurrent.Future" id="scala.concurrent.Future" class="extype">Future</a>[<a href="../execution/Ack.html" name="monix.execution.Ack" id="monix.execution.Ack" class="extype">Ack</a>]</span>, <span name="errorFn">errorFn: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="../execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a></span></span><p class="shortcomment cmt">Subscribes to the stream.</p><div class="fullcomment"><div class="comment cmt"><p>Subscribes to the stream.</p><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a subscription that can be used to cancel the streaming.</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd><dt>See also</dt><dd><span class="cmt"><p><a href="#consumeWith[R](f:monix.reactive.Consumer[A,R]):monix.eval.Task[R]" name="monix.reactive.Observable#consumeWith" id="monix.reactive.Observable#consumeWith" class="extmbr">consumeWith</a> for another way of consuming observables</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#subscribe" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="subscribe(subscriber:monix.reactive.observers.Subscriber[A]):monix.execution.Cancelable"></a><a id="subscribe(Subscriber[A]):Cancelable"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#subscribe(subscriber:monix.reactive.observers.Subscriber[A]):monix.execution.Cancelable" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">subscribe</span><span class="params">(<span name="subscriber">subscriber: <a href="observers/Subscriber.html" name="monix.reactive.observers.Subscriber" id="monix.reactive.observers.Subscriber" class="extype">Subscriber</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="../execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a></span></span><p class="shortcomment cmt">Subscribes to the stream.</p><div class="fullcomment"><div class="comment cmt"><p>Subscribes to the stream.</p><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a subscription that can be used to cancel the streaming.</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd><dt>See also</dt><dd><span class="cmt"><p><a href="#consumeWith[R](f:monix.reactive.Consumer[A,R]):monix.eval.Task[R]" name="monix.reactive.Observable#consumeWith" id="monix.reactive.Observable#consumeWith" class="extmbr">consumeWith</a> for another way of consuming observables</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#subscribe" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="subscribe(observer:monix.reactive.Observer[A])(implicits:monix.execution.Scheduler):monix.execution.Cancelable"></a><a id="subscribe(Observer[A])(Scheduler):Cancelable"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#subscribe(observer:monix.reactive.Observer[A])(implicits:monix.execution.Scheduler):monix.execution.Cancelable" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">subscribe</span><span class="params">(<span name="observer">observer: <a href="Observer.html" name="monix.reactive.Observer" id="monix.reactive.Observer" class="extype">Observer</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="../execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a></span></span><p class="shortcomment cmt">Subscribes to the stream.</p><div class="fullcomment"><div class="comment cmt"><p>Subscribes to the stream.</p><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a subscription that can be used to cancel the streaming.</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd><dt>See also</dt><dd><span class="cmt"><p><a href="#consumeWith[R](f:monix.reactive.Consumer[A,R]):monix.eval.Task[R]" name="monix.reactive.Observable#consumeWith" id="monix.reactive.Observable#consumeWith" class="extmbr">consumeWith</a> for another way of consuming observables</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#subscribeOn" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="subscribeOn(scheduler:monix.execution.Scheduler):monix.reactive.Observable[A]"></a><a id="subscribeOn(Scheduler):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#subscribeOn(scheduler:monix.execution.Scheduler):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">subscribeOn</span><span class="params">(<span name="scheduler">scheduler: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns a new Observable that uses the specified <code>Scheduler</code> for
initiating the subscription.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new Observable that uses the specified <code>Scheduler</code> for
initiating the subscription.</p><p>This is different from <a href="#executeOn(s:monix.execution.Scheduler,forceAsync:Boolean):monix.reactive.Observable[A]" name="monix.reactive.Observable#executeOn" id="monix.reactive.Observable#executeOn" class="extmbr">executeOn</a> because the given <code>scheduler</code>
is only used to start the subscription, but does not override the
default <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a>.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#sum" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="sum[AA&gt;:A](implicitA:Numeric[AA]):monix.reactive.Observable[AA]"></a><a id="sum[AA&gt;:A](Numeric[AA]):Observable[AA]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#sum[AA&gt;:A](implicitA:Numeric[AA]):monix.reactive.Observable[AA]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sum</span><span class="tparams">[<span name="AA">AA &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="A">A: <span name="scala.Numeric" class="extype">Numeric</span>[<span name="monix.reactive.Observable.sum.AA" class="extype">AA</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.sum.AA" class="extype">AA</span>]</span></span><p class="shortcomment cmt">Given a source that emits numeric values, the <code>sum</code> operator sums
up all values and at onComplete it emits the total.</p></li><li class="indented0 " name="monix.reactive.Observable#sumL" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="sumL[B&gt;:A](implicitB:Numeric[B]):monix.eval.Task[B]"></a><a id="sumL[B&gt;:A](Numeric[B]):Task[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#sumL[B&gt;:A](implicitB:Numeric[B]):monix.eval.Task[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sumL</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="B">B: <span name="scala.Numeric" class="extype">Numeric</span>[<span name="monix.reactive.Observable.sumL.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="monix.reactive.Observable.sumL.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Given a source that emits numeric values, the <code>sum</code> operator sums
up all values and returns the result.</p></li><li class="indented0 " name="monix.reactive.Observable#switch" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="switch[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="switch[B](&lt;:&lt;[A,Observable[B]]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#switch[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">switch</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.3/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>, <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.switch.B" class="extype">B</span>]]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.switch.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Convert an observable that emits observables into a single
observable that emits the items emitted by the
most-recently-emitted of those observables.</p><div class="fullcomment"><div class="comment cmt"><p>Convert an observable that emits observables into a single
observable that emits the items emitted by the
most-recently-emitted of those observables.</p><p>Similar with <a href="#flatten[B](implicitev:A&lt;:&lt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatten" id="monix.reactive.Observable#flatten" class="extmbr">flatten</a>, however the source isn't
back-pressured when emitting new events. Instead new events
being emitted are cancelling the active child observables.</p><h4>Equivalence with switchMap</h4><p>The <code>switch</code> operation can be expressed in terms of <a href="#switchMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#switchMap" id="monix.reactive.Observable#switchMap" class="extmbr">switchMap</a>,
as we have this equivalence:</p><p><code>stream.switch &lt;-&gt; stream.switchMap(x =&gt; x)</code>
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p>the description of <a href="#switchMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#switchMap" id="monix.reactive.Observable#switchMap" class="extmbr">switchMap</a> for an example.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#switchIfEmpty" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="switchIfEmpty[B&gt;:A](backup:monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="switchIfEmpty[B&gt;:A](Observable[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#switchIfEmpty[B&gt;:A](backup:monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">switchIfEmpty</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="backup">backup: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.switchIfEmpty.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.switchIfEmpty.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">In case the source is empty, switch to the given backup.</p></li><li class="indented0 " name="monix.reactive.Observable#switchMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="switchMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="switchMap[B]((A)=&gt;Observable[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#switchMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">switchMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.switchMap.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.switchMap.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Convert an observable that emits observables into a single
observable that emits the items emitted by the
most-recently-emitted of those observables.</p><div class="fullcomment"><div class="comment cmt"><p>Convert an observable that emits observables into a single
observable that emits the items emitted by the
most-recently-emitted of those observables.</p><p>Similar with <a href="#concatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#concatMap" id="monix.reactive.Observable#concatMap" class="extmbr">concatMap</a>, however the source isn't
back-pressured when emitting new events. Instead new events
being emitted are cancelling the active child observables.</p><h4>Example</h4><p>The <code>switchMap</code> can express a lot of cool, time-based operations.
For example we can express <a href="#debounce(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#debounce" id="monix.reactive.Observable#debounce" class="extmbr">debounce</a> in terms of <code>switchMap</code>:</p><pre><span class="kw">import</span> scala.concurrent.duration._

<span class="kw">def</span> debounce[A](stream: Observable[A], d: FiniteDuration): Observable[A] =
  stream.switchMap { x <span class="kw">=&gt;</span>
    Observable.now(x).delayExecution(d)
  }</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is a generator for the streams that are being merged</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](=&gt;T0):T0"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#tail" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="tail:monix.reactive.Observable[A]"></a><a id="tail:Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#tail:monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">tail</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Drops the first element of the source observable,
emitting the rest.</p></li><li class="indented0 " name="monix.reactive.Observable#take" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="take(n:Long):monix.reactive.Observable[A]"></a><a id="take(Long):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#take(n:Long):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">take</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.3/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Selects the first <code>n</code> elements (from the start).</p><div class="fullcomment"><div class="comment cmt"><p>Selects the first <code>n</code> elements (from the start).
</p></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>the number of elements to take</p></dd><dt>returns</dt><dd class="cmt"><p>a new Observable that emits only the first
        <code>n</code> elements from the source</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#takeByTimespan" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="takeByTimespan(timespan:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]"></a><a id="takeByTimespan(FiniteDuration):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#takeByTimespan(timespan:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">takeByTimespan</span><span class="params">(<span name="timespan">timespan: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new Observable that emits the events of the source, only
for the specified <code>timestamp</code>, after which it completes.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new Observable that emits the events of the source, only
for the specified <code>timestamp</code>, after which it completes.
</p></div><dl class="paramcmts block"><dt class="param">timespan</dt><dd class="cmt"><p>the window of time during which the new Observable
       is allowed to emit the events of the source</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#takeEveryNth" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="takeEveryNth(n:Int):monix.reactive.Observable[A]"></a><a id="takeEveryNth(Int):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#takeEveryNth(n:Int):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">takeEveryNth</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new Observable that emits every n-th event from the source,
dropping intermediary events.</p></li><li class="indented0 " name="monix.reactive.Observable#takeLast" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="takeLast(n:Int):monix.reactive.Observable[A]"></a><a id="takeLast(Int):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#takeLast(n:Int):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">takeLast</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new observable that only emits the last <code>n</code> elements
emitted by the source.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new observable that only emits the last <code>n</code> elements
emitted by the source.</p><p>In case the source triggers an error, then the underlying
buffer gets dropped and the error gets emitted immediately.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#takeUntil" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="takeUntil(trigger:monix.reactive.Observable[Any]):monix.reactive.Observable[A]"></a><a id="takeUntil(Observable[Any]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#takeUntil(trigger:monix.reactive.Observable[Any]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">takeUntil</span><span class="params">(<span name="trigger">trigger: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new observable that mirrors the source until
the given <code>trigger</code> emits either an element or <code>onComplete</code>,
after which it is completed.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new observable that mirrors the source until
the given <code>trigger</code> emits either an element or <code>onComplete</code>,
after which it is completed.</p><p>The resulting observable is completed as soon as <code>trigger</code>
emits either an <code>onNext</code> or <code>onComplete</code>. If <code>trigger</code>
emits an <code>onError</code>, then the resulting observable is also
completed with error.
</p></div><dl class="paramcmts block"><dt class="param">trigger</dt><dd class="cmt"><p>is an observable that will cancel the
       streaming as soon as it emits an event</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#takeUntilEval" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="takeUntilEval(trigger:monix.eval.Task[_]):monix.reactive.Observable[A]"></a><a id="takeUntilEval(Task[_]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#takeUntilEval(trigger:monix.eval.Task[_]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">takeUntilEval</span><span class="params">(<span name="trigger">trigger: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[_]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Version of <a href="#takeUntil(trigger:monix.reactive.Observable[Any]):monix.reactive.Observable[A]" name="monix.reactive.Observable#takeUntil" id="monix.reactive.Observable#takeUntil" class="extmbr">takeUntil</a> that can work with a trigger expressed by a <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">monix.eval.Task</a>
</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#takeUntil(trigger:monix.reactive.Observable[Any]):monix.reactive.Observable[A]" name="monix.reactive.Observable#takeUntil" id="monix.reactive.Observable#takeUntil" class="extmbr">takeUntil</a> that can work with a trigger expressed by a <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">monix.eval.Task</a>
</p></div><dl class="paramcmts block"><dt class="param">trigger</dt><dd class="cmt"><p>task that will cancel the stream as soon as it completes.</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#takeUntil(trigger:monix.reactive.Observable[Any]):monix.reactive.Observable[A]" name="monix.reactive.Observable#takeUntil" id="monix.reactive.Observable#takeUntil" class="extmbr">takeUntil</a> for version that works with Observable.</p></span><span class="cmt"><p><a href="#takeUntilEvalF[F[_],B](trigger:F[B])(implicittaskLike:monix.eval.TaskLike[F]):monix.reactive.Observable[A]" name="monix.reactive.Observable#takeUntilEvalF" id="monix.reactive.Observable#takeUntilEvalF" class="extmbr">takeUntilEvalF</a> for version that works with generic <code>F[_]</code> powered by <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a>.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#takeUntilEvalF" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="takeUntilEvalF[F[_],B](trigger:F[B])(implicittaskLike:monix.eval.TaskLike[F]):monix.reactive.Observable[A]"></a><a id="takeUntilEvalF[F[_],B](F[B])(TaskLike[F]):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#takeUntilEvalF[F[_],B](trigger:F[B])(implicittaskLike:monix.eval.TaskLike[F]):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">takeUntilEvalF</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="B">B</span>]</span><span class="params">(<span name="trigger">trigger: <span name="monix.reactive.Observable.takeUntilEvalF.F" class="extype">F</span>[<span name="monix.reactive.Observable.takeUntilEvalF.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="taskLike">taskLike: <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">TaskLike</a>[<span name="monix.reactive.Observable.takeUntilEvalF.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Version of <a href="#takeUntil(trigger:monix.reactive.Observable[Any]):monix.reactive.Observable[A]" name="monix.reactive.Observable#takeUntil" id="monix.reactive.Observable#takeUntil" class="extmbr">takeUntil</a> that can work with a trigger expressed by a generic <code>F[_]</code>
provided an implicit <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a> exists.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="#takeUntil(trigger:monix.reactive.Observable[Any]):monix.reactive.Observable[A]" name="monix.reactive.Observable#takeUntil" id="monix.reactive.Observable#takeUntil" class="extmbr">takeUntil</a> that can work with a trigger expressed by a generic <code>F[_]</code>
provided an implicit <a href="../eval/TaskLike.html" name="monix.eval.TaskLike" id="monix.eval.TaskLike" class="extype">monix.eval.TaskLike</a> exists.
</p></div><dl class="paramcmts block"><dt class="param">trigger</dt><dd class="cmt"><p>operation that will cancel the stream as soon as it completes.</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#takeUntil(trigger:monix.reactive.Observable[Any]):monix.reactive.Observable[A]" name="monix.reactive.Observable#takeUntil" id="monix.reactive.Observable#takeUntil" class="extmbr">takeUntil</a> for version that works with Observable.</p></span><span class="cmt"><p><a href="#takeUntilEval(trigger:monix.eval.Task[_]):monix.reactive.Observable[A]" name="monix.reactive.Observable#takeUntilEval" id="monix.reactive.Observable#takeUntilEval" class="extmbr">takeUntilEval</a> for version that works with <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">monix.eval.Task</a>.</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#takeWhile" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="takeWhile(p:A=&gt;Boolean):monix.reactive.Observable[A]"></a><a id="takeWhile((A)=&gt;Boolean):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#takeWhile(p:A=&gt;Boolean):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">takeWhile</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Takes longest prefix of elements that satisfy the given predicate
and returns a new Observable that emits those elements.</p></li><li class="indented0 " name="monix.reactive.Observable#takeWhileInclusive" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="takeWhileInclusive(p:A=&gt;Boolean):monix.reactive.Observable[A]"></a><a id="takeWhileInclusive((A)=&gt;Boolean):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#takeWhileInclusive(p:A=&gt;Boolean):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">takeWhileInclusive</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Takes longest prefix of elements that satisfy the given predicate, inclusive of
the value that caused <code>predicate</code> to return <code>false</code> and returns a new Observable that emits those elements.</p></li><li class="indented0 " name="monix.reactive.Observable#takeWhileNotCanceled" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="takeWhileNotCanceled(c:monix.execution.cancelables.BooleanCancelable):monix.reactive.Observable[A]"></a><a id="takeWhileNotCanceled(BooleanCancelable):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#takeWhileNotCanceled(c:monix.execution.cancelables.BooleanCancelable):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">takeWhileNotCanceled</span><span class="params">(<span name="c">c: <a href="../execution/cancelables/BooleanCancelable.html" name="monix.execution.cancelables.BooleanCancelable" id="monix.execution.cancelables.BooleanCancelable" class="extype">BooleanCancelable</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Takes longest prefix of elements while given <a href="../execution/cancelables/BooleanCancelable.html" name="monix.execution.cancelables.BooleanCancelable" id="monix.execution.cancelables.BooleanCancelable" class="extype">BooleanCancelable</a>
is not canceled and returns a new Observable that emits those elements.</p></li><li class="indented0 " name="monix.reactive.Observable#throttle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="throttle(period:scala.concurrent.duration.FiniteDuration,n:Int):monix.reactive.Observable[A]"></a><a id="throttle(FiniteDuration,Int):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#throttle(period:scala.concurrent.duration.FiniteDuration,n:Int):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">throttle</span><span class="params">(<span name="period">period: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>, <span name="n">n: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns an Observable that emits maximum <code>n</code> items per given <code>period</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits maximum <code>n</code> items per given <code>period</code>.</p><p>Unlike <a href="#throttleLast(period:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#throttleLast" id="monix.reactive.Observable#throttleLast" class="extmbr">Observable!.throttleLast</a> and <a href="#throttleFirst(interval:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#throttleFirst" id="monix.reactive.Observable#throttleFirst" class="extmbr">Observable!.throttleFirst</a>
it does not discard any elements.</p><p>If the source observable completes, then the current buffer gets
signaled downstream. If the source triggers an error then the
current buffer is being dropped and the error gets propagated
immediately.</p><p>Usage:</p><pre><span class="kw">import</span> scala.concurrent.duration._

<span class="cmt">// emits two items per second</span>
Observable.fromIterable(<span class="num">0</span> to <span class="num">10</span>)
  .throttle(<span class="num">1.</span>second, <span class="num">2</span>)</pre></div><dl class="paramcmts block"><dt class="param">period</dt><dd class="cmt"><p>time that has to pass before emiting new items</p></dd><dt class="param">n</dt><dd class="cmt"><p>maximum number of items emitted per given <code>period</code></p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#throttleFirst" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="throttleFirst(interval:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]"></a><a id="throttleFirst(FiniteDuration):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#throttleFirst(interval:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">throttleFirst</span><span class="params">(<span name="interval">interval: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns an Observable that emits only the first item emitted by
the source Observable during sequential time windows of a
specified duration.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an Observable that emits only the first item emitted by
the source Observable during sequential time windows of a
specified duration.</p><p>This differs from <a href="#throttleLast(period:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#throttleLast" id="monix.reactive.Observable#throttleLast" class="extmbr">Observable!.throttleLast</a> in that this only
tracks passage of time whereas <code>throttleLast</code> ticks at scheduled
intervals.</p><p>Usage:</p><pre><span class="kw">import</span> scala.concurrent.duration._

<span class="cmt">// emits 0, 5, 10 in 1 second intervals</span>
Observable.fromIterable(<span class="num">0</span> to <span class="num">10</span>)
  <span class="cmt">// without delay, it would return only 0</span>
  .delayOnNext(<span class="num">200.</span>millis)
  .throttleFirst(<span class="num">1.</span>second)</pre></div><dl class="paramcmts block"><dt class="param">interval</dt><dd class="cmt"><p>time to wait before emitting another item after
       emitting the last item</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#throttle(period:scala.concurrent.duration.FiniteDuration,n:Int):monix.reactive.Observable[A]" name="monix.reactive.Observable#throttle" id="monix.reactive.Observable#throttle" class="extmbr">throttle</a> for a version that allows to specify number
     of elements processed by a period and does not drop any elements</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#throttleLast" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="throttleLast(period:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]"></a><a id="throttleLast(FiniteDuration):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#throttleLast(period:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">throttleLast</span><span class="params">(<span name="period">period: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Emit the most recent items emitted by the source within
periodic time intervals.</p><div class="fullcomment"><div class="comment cmt"><p>Emit the most recent items emitted by the source within
periodic time intervals.</p><p>Alias for <a href="#sample(period:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#sample" id="monix.reactive.Observable#sample" class="extmbr">sample</a>.</p><p>Usage:</p><pre><span class="kw">import</span> scala.concurrent.duration._

<span class="cmt">// emits 3, 8, 10 in 1 second intervals</span>
Observable.fromIterable(<span class="num">0</span> to <span class="num">10</span>)
  <span class="cmt">// without delay, it would return only 10</span>
  .delayOnNext(<span class="num">200.</span>millis)
  .throttleLast(<span class="num">1.</span>second)</pre></div><dl class="paramcmts block"><dt class="param">period</dt><dd class="cmt"><p>duration of windows within which the last item
       emitted by the source Observable will be emitted</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#throttle(period:scala.concurrent.duration.FiniteDuration,n:Int):monix.reactive.Observable[A]" name="monix.reactive.Observable#throttle" id="monix.reactive.Observable#throttle" class="extmbr">throttle</a> for a version that allows to specify number
     of elements processed by a period and does not drop any elements</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#throttleLatest" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="throttleLatest(period:scala.concurrent.duration.FiniteDuration,emitLast:Boolean):monix.reactive.Observable[A]"></a><a id="throttleLatest(FiniteDuration,Boolean):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#throttleLatest(period:scala.concurrent.duration.FiniteDuration,emitLast:Boolean):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">throttleLatest</span><span class="params">(<span name="period">period: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>, <span name="emitLast">emitLast: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Emit first element emitted by the source and then
emit the most recent items emitted by the source within
periodic time intervals.</p><div class="fullcomment"><div class="comment cmt"><p>Emit first element emitted by the source and then
emit the most recent items emitted by the source within
periodic time intervals.
Usage:</p><pre><span class="kw">import</span> scala.concurrent.duration._

<span class="cmt">// emits 0 after 200 ms and then 4,9 in 1 sec intervals and 10 after the observable completes</span>
Observable.fromIterable(<span class="num">0</span> to <span class="num">10</span>)
  <span class="cmt">// without delay, it would return only 0, 10</span>
  .delayOnNext(<span class="num">200.</span>millis)
  .throttleLatest(<span class="num">1.</span>second, <span class="kw">true</span>)</pre></div><dl class="paramcmts block"><dt class="param">period</dt><dd class="cmt"><p>duration of windows within which the last item
       emitted by the source Observable will be emitted</p></dd><dt class="param">emitLast</dt><dd class="cmt"><p>if true last element will be emitted when source completes
                no matter if interval has passed or not</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#throttleWithTimeout" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="throttleWithTimeout(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]"></a><a id="throttleWithTimeout(FiniteDuration):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#throttleWithTimeout(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">throttleWithTimeout</span><span class="params">(<span name="timeout">timeout: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Only emit an item from an observable if a particular timespan has
passed without it emitting another item.</p><div class="fullcomment"><div class="comment cmt"><p>Only emit an item from an observable if a particular timespan has
passed without it emitting another item.</p><p>Note: If the source observable keeps emitting items more
frequently than the length of the time window, then no items will
be emitted by the resulting observable.</p><p>Alias for <a href="#debounce(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#debounce" id="monix.reactive.Observable#debounce" class="extmbr">debounce</a>.
</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>the length of the window of time that must pass after
       the emission of an item from the source observable in
       which that observable emits no items in order for the
       item to be emitted by the resulting observable</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="#echoOnce(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#echoOnce" id="monix.reactive.Observable#echoOnce" class="extmbr">echoOnce</a> for a similar operator that also mirrors
    the source observable</p></span></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#timeoutOnSlowDownstream" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="timeoutOnSlowDownstream(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]"></a><a id="timeoutOnSlowDownstream(FiniteDuration):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#timeoutOnSlowDownstream(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">timeoutOnSlowDownstream</span><span class="params">(<span name="timeout">timeout: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns an observable that mirrors the source but that will trigger a
<a href="../execution/exceptions/DownstreamTimeoutException.html" name="monix.execution.exceptions.DownstreamTimeoutException" id="monix.execution.exceptions.DownstreamTimeoutException" class="extype">DownstreamTimeoutException</a>
in case the downstream subscriber takes more than the given timespan
to process an <code>onNext</code> message.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an observable that mirrors the source but that will trigger a
<a href="../execution/exceptions/DownstreamTimeoutException.html" name="monix.execution.exceptions.DownstreamTimeoutException" id="monix.execution.exceptions.DownstreamTimeoutException" class="extype">DownstreamTimeoutException</a>
in case the downstream subscriber takes more than the given timespan
to process an <code>onNext</code> message.</p><p>Note that this ignores the time it takes for the upstream to send
<code>onNext</code> messages. For detecting slow producers see <a href="#timeoutOnSlowUpstream(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#timeoutOnSlowUpstream" id="monix.reactive.Observable#timeoutOnSlowUpstream" class="extmbr">timeoutOnSlowUpstream</a>.
</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>maximum duration for <code>onNext</code>.</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#timeoutOnSlowDownstreamTo" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="timeoutOnSlowDownstreamTo[B&gt;:A](timeout:scala.concurrent.duration.FiniteDuration,backup:monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="timeoutOnSlowDownstreamTo[B&gt;:A](FiniteDuration,Observable[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#timeoutOnSlowDownstreamTo[B&gt;:A](timeout:scala.concurrent.duration.FiniteDuration,backup:monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">timeoutOnSlowDownstreamTo</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="timeout">timeout: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>, <span name="backup">backup: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.timeoutOnSlowDownstreamTo.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.timeoutOnSlowDownstreamTo.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns an observable that mirrors the source but applies a timeout
for each <code>onNext</code> message.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an observable that mirrors the source but applies a timeout
for each <code>onNext</code> message. If downstream subscriber takes more time than the given
timespan to process an <code>onNext</code> message, the source is terminated and downstream gets
subscribed to the given backup.</p><p>Note that this ignores the time it takes for the upstream to send
<code>onNext</code> messages. For detecting slow producers see <a href="#timeoutOnSlowUpstream(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#timeoutOnSlowUpstream" id="monix.reactive.Observable#timeoutOnSlowUpstream" class="extmbr">timeoutOnSlowUpstream</a>.
</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>maximum duration for <code>onNext</code>.</p></dd><dt class="param">backup</dt><dd class="cmt"><p>alternative data source to subscribe to on timeout.</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#timeoutOnSlowUpstream" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="timeoutOnSlowUpstream(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]"></a><a id="timeoutOnSlowUpstream(FiniteDuration):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#timeoutOnSlowUpstream(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">timeoutOnSlowUpstream</span><span class="params">(<span name="timeout">timeout: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns an observable that mirrors the source but applies a timeout
for each emitted item by the upstream.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an observable that mirrors the source but applies a timeout
for each emitted item by the upstream. If the next item isn't
emitted within the specified timeout duration starting from its
predecessor, the resulting Observable terminates and notifies
observers of a TimeoutException.</p><p>Note that this ignores the time it takes to process <code>onNext</code>.
If dealing with a slow consumer, see <a href="#timeoutOnSlowDownstream(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#timeoutOnSlowDownstream" id="monix.reactive.Observable#timeoutOnSlowDownstream" class="extmbr">timeoutOnSlowDownstream</a>.
</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>maximum duration between emitted items before
       a timeout occurs (ignoring the time it takes to process <code>onNext</code>)</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#timeoutOnSlowUpstreamTo" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="timeoutOnSlowUpstreamTo[B&gt;:A](timeout:scala.concurrent.duration.FiniteDuration,backup:monix.reactive.Observable[B]):monix.reactive.Observable[B]"></a><a id="timeoutOnSlowUpstreamTo[B&gt;:A](FiniteDuration,Observable[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#timeoutOnSlowUpstreamTo[B&gt;:A](timeout:scala.concurrent.duration.FiniteDuration,backup:monix.reactive.Observable[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">timeoutOnSlowUpstreamTo</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="timeout">timeout: <a href="https://www.scala-lang.org/api/2.13.3/scala/concurrent/duration/FiniteDuration.html#scala.concurrent.duration.FiniteDuration" name="scala.concurrent.duration.FiniteDuration" id="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</a></span>, <span name="backup">backup: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.timeoutOnSlowUpstreamTo.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.timeoutOnSlowUpstreamTo.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns an observable that mirrors the source but applies a timeout
for each emitted item by the upstream.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an observable that mirrors the source but applies a timeout
for each emitted item by the upstream. If the next item isn't
emitted within the specified timeout duration starting from its
predecessor, the source is terminated and the downstream gets
subscribed to the given backup.</p><p>Note that this ignores the time it takes to process <code>onNext</code>.
If dealing with a slow consumer, see <a href="#timeoutOnSlowDownstream(timeout:scala.concurrent.duration.FiniteDuration):monix.reactive.Observable[A]" name="monix.reactive.Observable#timeoutOnSlowDownstream" id="monix.reactive.Observable#timeoutOnSlowDownstream" class="extmbr">timeoutOnSlowDownstream</a>.
</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>maximum duration between emitted items before
       a timeout occurs (ignoring the time it takes to process <code>onNext</code>)</p></dd><dt class="param">backup</dt><dd class="cmt"><p>is the alternative data source to subscribe to on timeout</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#toListL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toListL:monix.eval.Task[List[A]]"></a><a id="toListL:Task[List[A]]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#toListL:monix.eval.Task[List[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toListL</span><span class="result">: <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>[<span name="scala.List" class="extype">List</span>[<span name="monix.reactive.Observable.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Returns a <code>Task</code> that upon evaluation will collect all items from
the source in a Scala <code>List</code> and return this list instead.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <code>Task</code> that upon evaluation will collect all items from
the source in a Scala <code>List</code> and return this list instead.</p><p>WARNING: for infinite streams the process will eventually blow up
with an out of memory error.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#toReactivePublisher" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toReactivePublisher[B&gt;:A](implicits:monix.execution.Scheduler):org.reactivestreams.Publisher[B]"></a><a id="toReactivePublisher[B&gt;:A](Scheduler):Publisher[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#toReactivePublisher[B&gt;:A](implicits:monix.execution.Scheduler):org.reactivestreams.Publisher[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toReactivePublisher</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <span name="org.reactivestreams.Publisher" class="extype">Publisher</span>[<span name="monix.reactive.Observable.toReactivePublisher.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Converts this <code>Observable</code> into an <code>org.reactivestreams.Publisher</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Converts this <code>Observable</code> into an <code>org.reactivestreams.Publisher</code>.</p><p>Meant for interoperability with other Reactive Streams
implementations.</p><p>Usage sample:</p><pre><span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> monix.execution.rstreams.SingleAssignSubscription
<span class="kw">import</span> org.reactivestreams.{Publisher, Subscriber, Subscription}

<span class="kw">def</span> sum(source: Publisher[<span class="std">Int</span>], requestSize: <span class="std">Int</span>): Task[<span class="std">Long</span>] =
  Task.create { (_, cb) <span class="kw">=&gt;</span>
    <span class="kw">val</span> sub = SingleAssignSubscription()

    source.subscribe(<span class="kw">new</span> Subscriber[<span class="std">Int</span>] {
      <span class="kw">private</span>[<span class="kw">this</span>] <span class="kw">var</span> requested = <span class="num">0</span>L
      <span class="kw">private</span>[<span class="kw">this</span>] <span class="kw">var</span> sum = <span class="num">0</span>L

      <span class="kw">def</span> onSubscribe(s: Subscription): <span class="std">Unit</span> = {
        sub := s
        requested = requestSize
        s.request(requestSize)
      }

      <span class="kw">def</span> onNext(t: <span class="std">Int</span>): <span class="std">Unit</span> = {
        sum += t
        <span class="kw">if</span> (requestSize != <span class="std">Long</span>.MaxValue) requested -= <span class="num">1</span>

        <span class="kw">if</span> (requested &lt;= <span class="num">0</span>) {
          requested = requestSize
          sub.request(requestSize)
        }
      }

      <span class="kw">def</span> onError(t: Throwable): <span class="std">Unit</span> =
        cb.onError(t)
      <span class="kw">def</span> onComplete(): <span class="std">Unit</span> =
        cb.onSuccess(sum)
    })

    <span class="cmt">// Cancelable that can be used by Task</span>
    sub
  }

<span class="kw">import</span> monix.execution.Scheduler.Implicits.global
<span class="kw">val</span> pub = Observable(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).toReactivePublisher

<span class="cmt">// Yields 10</span>
sum(pub, requestSize = <span class="num">128</span>)</pre><p>See the <a href="http://www.reactive-streams.org/" target="_blank">Reactive Streams</a>
protocol for details.
</p></div></div></li><li class="indented0 " name="scala.AnyRef#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#java.lang.String" name="java.lang.String" id="java.lang.String" class="extype">String</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#transform" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="transform[B](transformer:monix.reactive.Observable.Transformer[A,B]):monix.reactive.Observable[B]"></a><a id="transform[B](Transformer[A,B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#transform[B](transformer:monix.reactive.Observable.Transformer[A,B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">transform</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="transformer">transformer: <a href="Observable$.html#Transformer[-A,+B]=monix.reactive.Observable[A]=&gt;monix.reactive.Observable[B]" name="monix.reactive.Observable.Transformer" id="monix.reactive.Observable.Transformer" class="extmbr">Transformer</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>, <span name="monix.reactive.Observable.transform.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.transform.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Transforms the source using the given transformer function.</p></li><li class="indented0 " name="monix.reactive.Observable#uncancelable" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="uncancelable:monix.reactive.Observable[A]"></a><a id="uncancelable:Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#uncancelable:monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">uncancelable</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Makes the source <code>Observable</code> uninterruptible such that a <code>cancel</code>
signal has no effect.</p><div class="fullcomment"><div class="comment cmt"><p>Makes the source <code>Observable</code> uninterruptible such that a <code>cancel</code>
signal has no effect.</p><h4>Example</h4><pre><span class="kw">import</span> scala.concurrent.duration._

Observable.eval(println(<span class="lit">"Hello!"</span>))
  .delayExecution(<span class="num">10.</span>seconds)
  .uncancelable</pre><p>The created observable, after <code>subscribe</code>, will print "Hello!"
even if cancellation is attempted.
</p></div></div></li><li class="indented0 " name="monix.reactive.Observable#unsafeMulticast" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="unsafeMulticast[B&gt;:A,R](processor:monix.reactive.subjects.Subject[B,R])(implicits:monix.execution.Scheduler):monix.reactive.observables.ConnectableObservable[R]"></a><a id="unsafeMulticast[B&gt;:A,R](Subject[B,R])(Scheduler):ConnectableObservable[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#unsafeMulticast[B&gt;:A,R](processor:monix.reactive.subjects.Subject[B,R])(implicits:monix.execution.Scheduler):monix.reactive.observables.ConnectableObservable[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">unsafeMulticast</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>, <span name="R">R</span>]</span><span class="params">(<span name="processor">processor: <a href="subjects/Subject.html" name="monix.reactive.subjects.Subject" id="monix.reactive.subjects.Subject" class="extype">Subject</a>[<span name="monix.reactive.Observable.unsafeMulticast.B" class="extype">B</span>, <span name="monix.reactive.Observable.unsafeMulticast.R" class="extype">R</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="observables/ConnectableObservable.html" name="monix.reactive.observables.ConnectableObservable" id="monix.reactive.observables.ConnectableObservable" class="extype">ConnectableObservable</a>[<span name="monix.reactive.Observable.unsafeMulticast.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Converts this observable into a multicast observable, useful for
turning a cold observable into a hot one (i.e.</p><div class="fullcomment"><div class="comment cmt"><p>Converts this observable into a multicast observable, useful for
turning a cold observable into a hot one (i.e. whose source is
shared by all observers).</p><p><b>UNSAFE PROTOCOL</b>: This operator is unsafe because <code>Subject</code>
objects are stateful and have to obey the <code>Observer</code> contract,
meaning that they shouldn't be subscribed multiple times, so
they are error prone. Only use if you know what you're doing,
otherwise prefer the safe <a href="#multicast[B&gt;:A,R](pipe:monix.reactive.Pipe[B,R])(implicits:monix.execution.Scheduler):monix.reactive.observables.ConnectableObservable[R]" name="monix.reactive.Observable#multicast" id="monix.reactive.Observable#multicast" class="extmbr">multicast</a>
operator.</p><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeProtocol.html" name="monix.execution.annotations.UnsafeProtocol" id="monix.execution.annotations.UnsafeProtocol" class="extype">UnsafeProtocol</a></span><span class="args">()</span> <span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#unsafeSubscribeFn" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="unsafeSubscribeFn(observer:monix.reactive.Observer[A])(implicits:monix.execution.Scheduler):monix.execution.Cancelable"></a><a id="unsafeSubscribeFn(Observer[A])(Scheduler):Cancelable"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#unsafeSubscribeFn(observer:monix.reactive.Observer[A])(implicits:monix.execution.Scheduler):monix.execution.Cancelable" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">unsafeSubscribeFn</span><span class="params">(<span name="observer">observer: <a href="Observer.html" name="monix.reactive.Observer" id="monix.reactive.Observer" class="extype">Observer</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="s">s: <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a></span>)</span><span class="result">: <a href="../execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a></span></span><p class="shortcomment cmt">Given an <a href="Observer.html" name="monix.reactive.Observer" id="monix.reactive.Observer" class="extype">observer</a> and a
<a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">scheduler</a> for managing async
boundaries, subscribes to this observable for events.</p><div class="fullcomment"><div class="comment cmt"><p>Given an <a href="Observer.html" name="monix.reactive.Observer" id="monix.reactive.Observer" class="extype">observer</a> and a
<a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">scheduler</a> for managing async
boundaries, subscribes to this observable for events.</p><p>Helper for calling the
<a href="#unsafeSubscribeFn(subscriber:monix.reactive.observers.Subscriber[A]):monix.execution.Cancelable" name="monix.reactive.Observable#unsafeSubscribeFn" id="monix.reactive.Observable#unsafeSubscribeFn" class="extmbr">abstract method</a>.</p><p><b>UNSAFE PROTOCOL:</b> This function is
        "unsafe" to call because it does not protect the calls to
        the given <a href="Observer.html" name="monix.reactive.Observer" id="monix.reactive.Observer" class="extype">Observer</a> implementation and thus knowledge
        of the protocol is needed.</p><p>        Prefer normal
        <a href="#subscribe(subscriber:monix.reactive.observers.Subscriber[A]):monix.execution.Cancelable" name="monix.reactive.Observable#subscribe" id="monix.reactive.Observable#subscribe" class="extmbr">subscribe</a>
        when consuming a stream, these unsafe subscription methods
        being useful when building operators and for testing
        purposes.</p><p>        Normal <code>subscribe</code> protects users in these ways:</p><ul><li>it does a best effort attempt to catch and report
           exceptions that violate the protocol</li><li>the final <code>onComplete</code> or <code>onError</code> message is
           guaranteed to be signaled after the completion
           of the <a href="../execution/Ack.html" name="monix.execution.Ack" id="monix.execution.Ack" class="extype">acknowledgement</a>
           received from the last <code>onNext</code>; the internal
           protocol doesn't require back-pressuring of
           this last message for performance reasons</li></ul><p><b>UNSAFE WARNING</b>:
        this operation can trigger the execution of side effects, which
        breaks referential transparency and is thus not a pure function.</p><p>        For FP code these functions shouldn't be called until
        "the end of the world", which is to say at the end of
        the program (for a console app), or at the end of a web
        request.</p><p>        Otherwise for modifying or operating on streams, prefer
        its pure functions like <a href="#publishSelector[R](f:monix.reactive.Observable[A]=&gt;monix.reactive.Observable[R]):monix.reactive.Observable[R]" name="monix.reactive.Observable#publishSelector" id="monix.reactive.Observable#publishSelector" class="extmbr">publishSelector</a> for sharing
        the data source, or <a href="#map[B](f:A=&gt;B):monix.reactive.Observable[B]" name="monix.reactive.Observable#map" id="monix.reactive.Observable#map" class="extmbr">map</a> or <a href="#flatMap[B](f:A=&gt;monix.reactive.Observable[B]):monix.reactive.Observable[B]" name="monix.reactive.Observable#flatMap" id="monix.reactive.Observable#flatMap" class="extmbr">flatMap</a> for operating
        on its events. Or in case of specialized logic, prefer
        to suspend these side effects via
        <a href="Observable$.html#suspend[A](fa:=&gt;monix.reactive.Observable[A]):monix.reactive.Observable[A]" name="monix.reactive.Observable#suspend" id="monix.reactive.Observable#suspend" class="extmbr">Observable.suspend</a>.
        Monix also provides <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> which can
        also be used for suspending side effects and the <code>Task</code>
        was built to interop well with <code>Observable</code>.</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeProtocol.html" name="monix.execution.annotations.UnsafeProtocol" id="monix.execution.annotations.UnsafeProtocol" class="extype">UnsafeProtocol</a></span><span class="args">()</span> <span class="name">@<a href="../execution/annotations/UnsafeBecauseImpure.html" name="monix.execution.annotations.UnsafeBecauseImpure" id="monix.execution.annotations.UnsafeBecauseImpure" class="extype">UnsafeBecauseImpure</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="arg1">arg1: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#whileBusyAggregateEvents" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="whileBusyAggregateEvents[S](seed:A=&gt;S)(aggregate:(S,A)=&gt;S):monix.reactive.Observable[S]"></a><a id="whileBusyAggregateEvents[S]((A)=&gt;S)((S,A)=&gt;S):Observable[S]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#whileBusyAggregateEvents[S](seed:A=&gt;S)(aggregate:(S,A)=&gt;S):monix.reactive.Observable[S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">whileBusyAggregateEvents</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.whileBusyAggregateEvents.S" class="extype">S</span></span>)</span><span class="params">(<span name="aggregate">aggregate: (<span name="monix.reactive.Observable.whileBusyAggregateEvents.S" class="extype">S</span>, <span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <span name="monix.reactive.Observable.whileBusyAggregateEvents.S" class="extype">S</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.whileBusyAggregateEvents.S" class="extype">S</span>]</span></span><p class="shortcomment cmt">Conflates events when a downstream is slower than the upstream.</p><div class="fullcomment"><div class="comment cmt"><p>Conflates events when a downstream is slower than the upstream.</p><p>Emits: Immediately when an element is received if the downstream is waiting for elements. Otherwise emits when the
downstream stops backpressuring and there is a conflated element available.
Back pressures: Never (conflates instead)</p><p>Usage:</p><pre><span class="kw">import</span> scala.concurrent.duration._
<span class="kw">import</span> cats.data.Chain

<span class="cmt">// Emits [0], [1, 2], [3, 4]</span>
Observable.range(<span class="num">0</span>, <span class="num">5</span>)
  .throttle(<span class="num">1.</span>second, <span class="num">1</span>)
  .whileBusyAggregateEvents(Chain.apply(_)){ <span class="kw">case</span> (chain, ele) <span class="kw">=&gt;</span> chain.append(ele) }
  .throttle(<span class="num">2.</span>seconds, <span class="num">1</span>)</pre></div></div></li><li class="indented0 " name="monix.reactive.Observable#whileBusyBuffer" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="whileBusyBuffer[B&gt;:A](overflowStrategy:monix.reactive.OverflowStrategy.Synchronous[B]):monix.reactive.Observable[B]"></a><a id="whileBusyBuffer[B&gt;:A](Synchronous[B]):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#whileBusyBuffer[B&gt;:A](overflowStrategy:monix.reactive.OverflowStrategy.Synchronous[B]):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">whileBusyBuffer</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="overflowStrategy">overflowStrategy: <a href="OverflowStrategy$$Synchronous.html" name="monix.reactive.OverflowStrategy.Synchronous" id="monix.reactive.OverflowStrategy.Synchronous" class="extype">Synchronous</a>[<span name="monix.reactive.Observable.whileBusyBuffer.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.whileBusyBuffer.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">While the destination observer is busy, buffers events, applying
the given overflowStrategy.</p><div class="fullcomment"><div class="comment cmt"><p>While the destination observer is busy, buffers events, applying
the given overflowStrategy.
</p></div><dl class="paramcmts block"><dt class="param">overflowStrategy</dt><dd class="cmt"><p>- the <a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">overflow strategy</a>
        used for buffering, which specifies what to do in case
        we're dealing with a slow consumer - should an unbounded
        buffer be used, should back-pressure be applied, should
        the pipeline drop newer or older events, should it drop
        the whole buffer? See <a href="OverflowStrategy.html" name="monix.reactive.OverflowStrategy" id="monix.reactive.OverflowStrategy" class="extype">OverflowStrategy</a> for more
        details.</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#whileBusyDropEvents" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="whileBusyDropEvents:monix.reactive.Observable[A]"></a><a id="whileBusyDropEvents:Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#whileBusyDropEvents:monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">whileBusyDropEvents</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">While the destination observer is busy, drop the incoming events.</p></li><li class="indented0 " name="monix.reactive.Observable#whileBusyDropEventsAndSignal" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="whileBusyDropEventsAndSignal[B&gt;:A](onOverflow:Long=&gt;B):monix.reactive.Observable[B]"></a><a id="whileBusyDropEventsAndSignal[B&gt;:A]((Long)=&gt;B):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#whileBusyDropEventsAndSignal[B&gt;:A](onOverflow:Long=&gt;B):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">whileBusyDropEventsAndSignal</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="onOverflow">onOverflow: (<a href="https://www.scala-lang.org/api/2.13.3/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>) =&gt; <span name="monix.reactive.Observable.whileBusyDropEventsAndSignal.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.whileBusyDropEventsAndSignal.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">While the destination observer is busy, drop the incoming events.</p><div class="fullcomment"><div class="comment cmt"><p>While the destination observer is busy, drop the incoming events.
When the downstream recovers, we can signal a special event
meant to inform the downstream observer how many events where
dropped.
</p></div><dl class="paramcmts block"><dt class="param">onOverflow</dt><dd class="cmt"><p>- a function that is used for signaling a special
        event used to inform the consumers that an overflow event
        happened, function that receives the number of dropped
        events as a parameter (see <a href="OverflowStrategy$$Evicted.html" name="monix.reactive.OverflowStrategy.Evicted" id="monix.reactive.OverflowStrategy.Evicted" class="extype">OverflowStrategy.Evicted</a>)</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#whileBusyReduceEvents" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="whileBusyReduceEvents[B&gt;:A](op:(B,B)=&gt;B):monix.reactive.Observable[B]"></a><a id="whileBusyReduceEvents[B&gt;:A]((B,B)=&gt;B):Observable[B]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#whileBusyReduceEvents[B&gt;:A](op:(B,B)=&gt;B):monix.reactive.Observable[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">whileBusyReduceEvents</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.reactive.Observable.A" class="extype">A</span></span>]</span><span class="params">(<span name="op">op: (<span name="monix.reactive.Observable.whileBusyReduceEvents.B" class="extype">B</span>, <span name="monix.reactive.Observable.whileBusyReduceEvents.B" class="extype">B</span>) =&gt; <span name="monix.reactive.Observable.whileBusyReduceEvents.B" class="extype">B</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.whileBusyReduceEvents.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Reduces elements when a downstream is slower than the upstream.</p><div class="fullcomment"><div class="comment cmt"><p>Reduces elements when a downstream is slower than the upstream.</p><p>Emits: Immediately when an element is received if the downstream is waiting for elements. Otherwise emits when the
downstream stops backpressuring and there is a reduced element available.
Back pressures: Never (reduces instead)</p><p>Usage:</p><pre><span class="kw">import</span> scala.concurrent.duration._
<span class="kw">import</span> cats.data.Chain

<span class="cmt">// Emits 0, 3 (1+2), 7 (3+4)</span>
Observable.range(<span class="num">0</span>, <span class="num">5</span>)
  .throttle(<span class="num">1.</span>second, <span class="num">1</span>)
  .whileBusyReduceEvents(_ + _)
  .throttle(<span class="num">2.</span>seconds, <span class="num">1</span>)</pre></div></div></li><li class="indented0 " name="monix.reactive.Observable#withFilter" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="withFilter(p:A=&gt;Boolean):monix.reactive.Observable[A]"></a><a id="withFilter((A)=&gt;Boolean):Observable[A]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#withFilter(p:A=&gt;Boolean):monix.reactive.Observable[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">withFilter</span><span class="params">(<span name="p">p: (<span name="monix.reactive.Observable.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Alias to <a href="#filter(p:A=&gt;Boolean):monix.reactive.Observable[A]" name="monix.reactive.Observable#filter" id="monix.reactive.Observable#filter" class="extmbr">filter</a> to support syntax in for comprehension, i.e.</p><div class="fullcomment"><div class="comment cmt"><p>Alias to <a href="#filter(p:A=&gt;Boolean):monix.reactive.Observable[A]" name="monix.reactive.Observable#filter" id="monix.reactive.Observable#filter" class="extmbr">filter</a> to support syntax in for comprehension, i.e.</p><p>Example: </p><pre><span class="kw">case</span> <span class="kw">class</span> Person(age: <span class="std">Long</span>)

<span class="kw">val</span> peopleObservable: Observable[Person] =
  Observable.range(<span class="num">1</span>, <span class="num">100</span>).map(Person.apply)

<span class="kw">for</span> {
  adult <span class="kw">&lt;-</span> peopleObservable <span class="kw">if</span> adult.age &gt;= <span class="num">18</span>
} <span class="kw">yield</span> adult</pre></div></div></li><li class="indented0 " name="monix.reactive.Observable#withLatestFrom" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="withLatestFrom[B,R](other:monix.reactive.Observable[B])(f:(A,B)=&gt;R):monix.reactive.Observable[R]"></a><a id="withLatestFrom[B,R](Observable[B])((A,B)=&gt;R):Observable[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#withLatestFrom[B,R](other:monix.reactive.Observable[B])(f:(A,B)=&gt;R):monix.reactive.Observable[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">withLatestFrom</span><span class="tparams">[<span name="B">B</span>, <span name="R">R</span>]</span><span class="params">(<span name="other">other: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>, <span name="monix.reactive.Observable.withLatestFrom.B" class="extype">B</span>) =&gt; <span name="monix.reactive.Observable.withLatestFrom.R" class="extype">R</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Combines the elements emitted by the source with the latest element
emitted by another observable.</p><div class="fullcomment"><div class="comment cmt"><p>Combines the elements emitted by the source with the latest element
emitted by another observable.</p><p>Similar with <code>combineLatest</code>, but only emits items when the single source
emits an item (not when any of the Observables that are passed to the operator
do, as combineLatest does).</p><h4> Visual Example </h4><p><pre>
stream1: 1 - - 2 - - 3 - 4 - -
stream2: 1 - - 2 - 3 - - - - 4

result: (1, 1), (2, 2), (3, 3), (4, 3)
</pre>
</p></div><dl class="paramcmts block"><dt class="param">other</dt><dd class="cmt"><p>is an observable that gets paired with the source</p></dd><dt class="param">f</dt><dd class="cmt"><p>is a mapping function over the generated pairs</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#withLatestFrom2" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="withLatestFrom2[B1,B2,R](o1:monix.reactive.Observable[B1],o2:monix.reactive.Observable[B2])(f:(A,B1,B2)=&gt;R):monix.reactive.Observable[R]"></a><a id="withLatestFrom2[B1,B2,R](Observable[B1],Observable[B2])((A,B1,B2)=&gt;R):Observable[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#withLatestFrom2[B1,B2,R](o1:monix.reactive.Observable[B1],o2:monix.reactive.Observable[B2])(f:(A,B1,B2)=&gt;R):monix.reactive.Observable[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">withLatestFrom2</span><span class="tparams">[<span name="B1">B1</span>, <span name="B2">B2</span>, <span name="R">R</span>]</span><span class="params">(<span name="o1">o1: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom2.B1" class="extype">B1</span>]</span>, <span name="o2">o2: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom2.B2" class="extype">B2</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>, <span name="monix.reactive.Observable.withLatestFrom2.B1" class="extype">B1</span>, <span name="monix.reactive.Observable.withLatestFrom2.B2" class="extype">B2</span>) =&gt; <span name="monix.reactive.Observable.withLatestFrom2.R" class="extype">R</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom2.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Combines the elements emitted by the source with the latest elements
emitted by two observables.</p><div class="fullcomment"><div class="comment cmt"><p>Combines the elements emitted by the source with the latest elements
emitted by two observables.</p><p>Similar with <code>combineLatest</code>, but only emits items when the single source
emits an item (not when any of the Observables that are passed to the operator
do, as combineLatest does).
</p></div><dl class="paramcmts block"><dt class="param">o1</dt><dd class="cmt"><p>is the first observable that gets paired with the source</p></dd><dt class="param">o2</dt><dd class="cmt"><p>is the second observable that gets paired with the source</p></dd><dt class="param">f</dt><dd class="cmt"><p>is a mapping function over the generated pairs</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#withLatestFrom3" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="withLatestFrom3[B1,B2,B3,R](o1:monix.reactive.Observable[B1],o2:monix.reactive.Observable[B2],o3:monix.reactive.Observable[B3])(f:(A,B1,B2,B3)=&gt;R):monix.reactive.Observable[R]"></a><a id="withLatestFrom3[B1,B2,B3,R](Observable[B1],Observable[B2],Observable[B3])((A,B1,B2,B3)=&gt;R):Observable[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#withLatestFrom3[B1,B2,B3,R](o1:monix.reactive.Observable[B1],o2:monix.reactive.Observable[B2],o3:monix.reactive.Observable[B3])(f:(A,B1,B2,B3)=&gt;R):monix.reactive.Observable[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">withLatestFrom3</span><span class="tparams">[<span name="B1">B1</span>, <span name="B2">B2</span>, <span name="B3">B3</span>, <span name="R">R</span>]</span><span class="params">(<span name="o1">o1: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom3.B1" class="extype">B1</span>]</span>, <span name="o2">o2: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom3.B2" class="extype">B2</span>]</span>, <span name="o3">o3: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom3.B3" class="extype">B3</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>, <span name="monix.reactive.Observable.withLatestFrom3.B1" class="extype">B1</span>, <span name="monix.reactive.Observable.withLatestFrom3.B2" class="extype">B2</span>, <span name="monix.reactive.Observable.withLatestFrom3.B3" class="extype">B3</span>) =&gt; <span name="monix.reactive.Observable.withLatestFrom3.R" class="extype">R</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom3.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Combines the elements emitted by the source with the latest elements
emitted by three observables.</p><div class="fullcomment"><div class="comment cmt"><p>Combines the elements emitted by the source with the latest elements
emitted by three observables.</p><p>Similar with <code>combineLatest</code>, but only emits items when the single source
emits an item (not when any of the Observables that are passed to the operator
do, as combineLatest does).
</p></div><dl class="paramcmts block"><dt class="param">o1</dt><dd class="cmt"><p>is the first observable that gets paired with the source</p></dd><dt class="param">o2</dt><dd class="cmt"><p>is the second observable that gets paired with the source</p></dd><dt class="param">o3</dt><dd class="cmt"><p>is the third observable that gets paired with the source</p></dd><dt class="param">f</dt><dd class="cmt"><p>is a mapping function over the generated pairs</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#withLatestFrom4" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="withLatestFrom4[B1,B2,B3,B4,R](o1:monix.reactive.Observable[B1],o2:monix.reactive.Observable[B2],o3:monix.reactive.Observable[B3],o4:monix.reactive.Observable[B4])(f:(A,B1,B2,B3,B4)=&gt;R):monix.reactive.Observable[R]"></a><a id="withLatestFrom4[B1,B2,B3,B4,R](Observable[B1],Observable[B2],Observable[B3],Observable[B4])((A,B1,B2,B3,B4)=&gt;R):Observable[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#withLatestFrom4[B1,B2,B3,B4,R](o1:monix.reactive.Observable[B1],o2:monix.reactive.Observable[B2],o3:monix.reactive.Observable[B3],o4:monix.reactive.Observable[B4])(f:(A,B1,B2,B3,B4)=&gt;R):monix.reactive.Observable[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">withLatestFrom4</span><span class="tparams">[<span name="B1">B1</span>, <span name="B2">B2</span>, <span name="B3">B3</span>, <span name="B4">B4</span>, <span name="R">R</span>]</span><span class="params">(<span name="o1">o1: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom4.B1" class="extype">B1</span>]</span>, <span name="o2">o2: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom4.B2" class="extype">B2</span>]</span>, <span name="o3">o3: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom4.B3" class="extype">B3</span>]</span>, <span name="o4">o4: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom4.B4" class="extype">B4</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>, <span name="monix.reactive.Observable.withLatestFrom4.B1" class="extype">B1</span>, <span name="monix.reactive.Observable.withLatestFrom4.B2" class="extype">B2</span>, <span name="monix.reactive.Observable.withLatestFrom4.B3" class="extype">B3</span>, <span name="monix.reactive.Observable.withLatestFrom4.B4" class="extype">B4</span>) =&gt; <span name="monix.reactive.Observable.withLatestFrom4.R" class="extype">R</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom4.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Combines the elements emitted by the source with the latest elements
emitted by four observables.</p><div class="fullcomment"><div class="comment cmt"><p>Combines the elements emitted by the source with the latest elements
emitted by four observables.</p><p>Similar with <code>combineLatest</code>, but only emits items when the single source
emits an item (not when any of the Observables that are passed to the operator
do, as combineLatest does).
</p></div><dl class="paramcmts block"><dt class="param">o1</dt><dd class="cmt"><p>is the first observable that gets paired with the source</p></dd><dt class="param">o2</dt><dd class="cmt"><p>is the second observable that gets paired with the source</p></dd><dt class="param">o3</dt><dd class="cmt"><p>is the third observable that gets paired with the source</p></dd><dt class="param">o4</dt><dd class="cmt"><p>is the fourth observable that gets paired with the source</p></dd><dt class="param">f</dt><dd class="cmt"><p>is a mapping function over the generated pairs</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#withLatestFrom5" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="withLatestFrom5[B1,B2,B3,B4,B5,R](o1:monix.reactive.Observable[B1],o2:monix.reactive.Observable[B2],o3:monix.reactive.Observable[B3],o4:monix.reactive.Observable[B4],o5:monix.reactive.Observable[B5])(f:(A,B1,B2,B3,B4,B5)=&gt;R):monix.reactive.Observable[R]"></a><a id="withLatestFrom5[B1,B2,B3,B4,B5,R](Observable[B1],Observable[B2],Observable[B3],Observable[B4],Observable[B5])((A,B1,B2,B3,B4,B5)=&gt;R):Observable[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#withLatestFrom5[B1,B2,B3,B4,B5,R](o1:monix.reactive.Observable[B1],o2:monix.reactive.Observable[B2],o3:monix.reactive.Observable[B3],o4:monix.reactive.Observable[B4],o5:monix.reactive.Observable[B5])(f:(A,B1,B2,B3,B4,B5)=&gt;R):monix.reactive.Observable[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">withLatestFrom5</span><span class="tparams">[<span name="B1">B1</span>, <span name="B2">B2</span>, <span name="B3">B3</span>, <span name="B4">B4</span>, <span name="B5">B5</span>, <span name="R">R</span>]</span><span class="params">(<span name="o1">o1: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom5.B1" class="extype">B1</span>]</span>, <span name="o2">o2: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom5.B2" class="extype">B2</span>]</span>, <span name="o3">o3: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom5.B3" class="extype">B3</span>]</span>, <span name="o4">o4: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom5.B4" class="extype">B4</span>]</span>, <span name="o5">o5: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom5.B5" class="extype">B5</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>, <span name="monix.reactive.Observable.withLatestFrom5.B1" class="extype">B1</span>, <span name="monix.reactive.Observable.withLatestFrom5.B2" class="extype">B2</span>, <span name="monix.reactive.Observable.withLatestFrom5.B3" class="extype">B3</span>, <span name="monix.reactive.Observable.withLatestFrom5.B4" class="extype">B4</span>, <span name="monix.reactive.Observable.withLatestFrom5.B5" class="extype">B5</span>) =&gt; <span name="monix.reactive.Observable.withLatestFrom5.R" class="extype">R</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom5.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Combines the elements emitted by the source with the latest elements
emitted by five observables.</p><div class="fullcomment"><div class="comment cmt"><p>Combines the elements emitted by the source with the latest elements
emitted by five observables.</p><p>Similar with <code>combineLatest</code>, but only emits items when the single source
emits an item (not when any of the Observables that are passed to the operator
do, as combineLatest does).
</p></div><dl class="paramcmts block"><dt class="param">o1</dt><dd class="cmt"><p>is the first observable that gets paired with the source</p></dd><dt class="param">o2</dt><dd class="cmt"><p>is the second observable that gets paired with the source</p></dd><dt class="param">o3</dt><dd class="cmt"><p>is the third observable that gets paired with the source</p></dd><dt class="param">o4</dt><dd class="cmt"><p>is the fourth observable that gets paired with the source</p></dd><dt class="param">o5</dt><dd class="cmt"><p>is the fifth observable that gets paired with the source</p></dd><dt class="param">f</dt><dd class="cmt"><p>is a mapping function over the generated pairs</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#withLatestFrom6" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="withLatestFrom6[B1,B2,B3,B4,B5,B6,R](o1:monix.reactive.Observable[B1],o2:monix.reactive.Observable[B2],o3:monix.reactive.Observable[B3],o4:monix.reactive.Observable[B4],o5:monix.reactive.Observable[B5],o6:monix.reactive.Observable[B6])(f:(A,B1,B2,B3,B4,B5,B6)=&gt;R):monix.reactive.Observable[R]"></a><a id="withLatestFrom6[B1,B2,B3,B4,B5,B6,R](Observable[B1],Observable[B2],Observable[B3],Observable[B4],Observable[B5],Observable[B6])((A,B1,B2,B3,B4,B5,B6)=&gt;R):Observable[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#withLatestFrom6[B1,B2,B3,B4,B5,B6,R](o1:monix.reactive.Observable[B1],o2:monix.reactive.Observable[B2],o3:monix.reactive.Observable[B3],o4:monix.reactive.Observable[B4],o5:monix.reactive.Observable[B5],o6:monix.reactive.Observable[B6])(f:(A,B1,B2,B3,B4,B5,B6)=&gt;R):monix.reactive.Observable[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">withLatestFrom6</span><span class="tparams">[<span name="B1">B1</span>, <span name="B2">B2</span>, <span name="B3">B3</span>, <span name="B4">B4</span>, <span name="B5">B5</span>, <span name="B6">B6</span>, <span name="R">R</span>]</span><span class="params">(<span name="o1">o1: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom6.B1" class="extype">B1</span>]</span>, <span name="o2">o2: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom6.B2" class="extype">B2</span>]</span>, <span name="o3">o3: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom6.B3" class="extype">B3</span>]</span>, <span name="o4">o4: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom6.B4" class="extype">B4</span>]</span>, <span name="o5">o5: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom6.B5" class="extype">B5</span>]</span>, <span name="o6">o6: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom6.B6" class="extype">B6</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>, <span name="monix.reactive.Observable.withLatestFrom6.B1" class="extype">B1</span>, <span name="monix.reactive.Observable.withLatestFrom6.B2" class="extype">B2</span>, <span name="monix.reactive.Observable.withLatestFrom6.B3" class="extype">B3</span>, <span name="monix.reactive.Observable.withLatestFrom6.B4" class="extype">B4</span>, <span name="monix.reactive.Observable.withLatestFrom6.B5" class="extype">B5</span>, <span name="monix.reactive.Observable.withLatestFrom6.B6" class="extype">B6</span>) =&gt; <span name="monix.reactive.Observable.withLatestFrom6.R" class="extype">R</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.withLatestFrom6.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Combines the elements emitted by the source with the latest elements
emitted by six observables.</p><div class="fullcomment"><div class="comment cmt"><p>Combines the elements emitted by the source with the latest elements
emitted by six observables.</p><p>Similar with <code>combineLatest</code>, but only emits items when the single source
emits an item (not when any of the Observables that are passed to the operator
do, as combineLatest does).
</p></div><dl class="paramcmts block"><dt class="param">o1</dt><dd class="cmt"><p>is the first observable that gets paired with the source</p></dd><dt class="param">o2</dt><dd class="cmt"><p>is the second observable that gets paired with the source</p></dd><dt class="param">o3</dt><dd class="cmt"><p>is the third observable that gets paired with the source</p></dd><dt class="param">o4</dt><dd class="cmt"><p>is the fourth observable that gets paired with the source</p></dd><dt class="param">o5</dt><dd class="cmt"><p>is the fifth observable that gets paired with the source</p></dd><dt class="param">o6</dt><dd class="cmt"><p>is the sixth observable that gets paired with the source</p></dd><dt class="param">f</dt><dd class="cmt"><p>is a mapping function over the generated pairs</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#zip" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zip[B](other:monix.reactive.Observable[B]):monix.reactive.Observable[(A,B)]"></a><a id="zip[B](Observable[B]):Observable[(A,B)]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#zip[B](other:monix.reactive.Observable[B]):monix.reactive.Observable[(A,B)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zip</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="other">other: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.zip.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[(<span name="monix.reactive.Observable.A" class="extype">A</span>, <span name="monix.reactive.Observable.zip.B" class="extype">B</span>)]</span></span><p class="shortcomment cmt">Creates a new observable from this observable and another given
observable by combining their items in pairs in a strict sequence.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new observable from this observable and another given
observable by combining their items in pairs in a strict sequence.</p><p>So the first item emitted by the new observable will be the tuple of the
first items emitted by each of the source observables; the second item
emitted by the new observable will be a tuple with the second items
emitted by each of those observables; and so forth.</p><h4> Visual Example </h4><p><pre>
stream1: 1 - - 2 - - 3 - 4 - -
stream2: 1 - - 2 - 3 - - - - 4

result: (1, 1), (2, 2), (3, 3), (4, 4)
</pre></p><p>See <a href="#combineLatest[B](other:monix.reactive.Observable[B]):monix.reactive.Observable[(A,B)]" name="monix.reactive.Observable#combineLatest" id="monix.reactive.Observable#combineLatest" class="extmbr">combineLatest</a> for a more relaxed alternative that doesn't
combine items in strict sequence.
</p></div><dl class="paramcmts block"><dt class="param">other</dt><dd class="cmt"><p>is an observable that gets paired with the source</p></dd><dt>returns</dt><dd class="cmt"><p>a new observable sequence that emits the paired items
        of the source observables</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#zipMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zipMap[B,R](other:monix.reactive.Observable[B])(f:(A,B)=&gt;R):monix.reactive.Observable[R]"></a><a id="zipMap[B,R](Observable[B])((A,B)=&gt;R):Observable[R]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#zipMap[B,R](other:monix.reactive.Observable[B])(f:(A,B)=&gt;R):monix.reactive.Observable[R]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zipMap</span><span class="tparams">[<span name="B">B</span>, <span name="R">R</span>]</span><span class="params">(<span name="other">other: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.zipMap.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.reactive.Observable.A" class="extype">A</span>, <span name="monix.reactive.Observable.zipMap.B" class="extype">B</span>) =&gt; <span name="monix.reactive.Observable.zipMap.R" class="extype">R</span></span>)</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[<span name="monix.reactive.Observable.zipMap.R" class="extype">R</span>]</span></span><p class="shortcomment cmt">Creates a new observable from this observable and another given
observable by combining their items in pairs in a strict sequence.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new observable from this observable and another given
observable by combining their items in pairs in a strict sequence.</p><p>So the first item emitted by the new observable will be the result
of the function applied to the first item emitted by each of
the source observables; the second item emitted by the new observable
will be the result of the function applied to the second item
emitted by each of those observables; and so forth.</p><h4> Visual Example </h4><p><pre>
stream1: 1 - - 2 - - 3 - 4 - -
stream2: 1 - - 2 - 3 - - - - 4

result: (1, 1), (2, 2), (3, 3), (4, 4)
</pre></p><p>See <a href="#combineLatestMap[B,R](other:monix.reactive.Observable[B])(f:(A,B)=&gt;R):monix.reactive.Observable[R]" name="monix.reactive.Observable#combineLatestMap" id="monix.reactive.Observable#combineLatestMap" class="extmbr">combineLatestMap</a> for a more relaxed alternative that doesn't
combine items in strict sequence.
</p></div><dl class="paramcmts block"><dt class="param">other</dt><dd class="cmt"><p>is an observable that gets paired with the source</p></dd><dt class="param">f</dt><dd class="cmt"><p>is a mapping function over the generated pairs</p></dd></dl></div></li><li class="indented0 " name="monix.reactive.Observable#zipWithIndex" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="zipWithIndex:monix.reactive.Observable[(A,Long)]"></a><a id="zipWithIndex:Observable[(A,Long)]"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#zipWithIndex:monix.reactive.Observable[(A,Long)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zipWithIndex</span><span class="result">: <a href="" name="monix.reactive.Observable" id="monix.reactive.Observable" class="extype">Observable</a>[(<span name="monix.reactive.Observable.A" class="extype">A</span>, <a href="https://www.scala-lang.org/api/2.13.3/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>)]</span></span><p class="shortcomment cmt">Zips the emitted elements of the source with their indices.</p></li></ol></div><div class="values members"><h3>Deprecated Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit"></a> <span class="permalink"><a href="../../monix/reactive/Observable.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: ">finalize</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> <span class="name">@Deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"></dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="java.io.Serializable" class="parent"><h3>Inherited from <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></h3></div><div name="scala.AnyRef" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.3/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
