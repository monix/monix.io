<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Monix 3.4.0 - monix.tail.Iterant.Suspend</title><meta content="Monix 3.4.0 - monix.tail.Iterant.Suspend" name="description"/><meta content="Monix 3.4.0 monix.tail.Iterant.Suspend" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../lib/jquery.min.js"></script><script type="text/javascript" src="../../lib/index.js"></script><script type="text/javascript" src="../../index.js"></script><script type="text/javascript" src="../../lib/scheduler.js"></script><script type="text/javascript" src="../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../';</script></head><body><div id="search"><span id="doc-title">Monix<span id="doc-version">3.4.0</span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">root</span></a></span><p class="shortcomment cmt"><img src="https://monix.io/public/images/monix-logo.png" align="right" width="200" /></p><div class="fullcomment"><div class="comment cmt"><p><img src="https://monix.io/public/images/monix-logo.png" align="right" width="200" /></p><p>This is the API documentation for the <a href="https://monix.io" target="_blank">Monix</a> library.</p><h4>Package Overview</h4><p><b><a href="../execution/index.html" name="monix.execution" id="monix.execution" class="extype">monix.execution</a></b> exposes lower level primitives for dealing
with asynchronous execution:</p><ul><li><a href="../execution/atomic/index.html" name="monix.execution.atomic" id="monix.execution.atomic" class="extype">monix.execution.atomic</a> exposes the <code>Atomic</code> types, as alternative
   to <code>java.util.concurrent.atomic</code></li><li><a href="../execution/cancelables/index.html" name="monix.execution.cancelables" id="monix.execution.cancelables" class="extype">monix.execution.cancelables</a> contains several
   useful <a href="../execution/Cancelable.html" name="monix.execution.Cancelable" id="monix.execution.Cancelable" class="extype">Cancelable</a> implementations</li><li><a href="../execution/schedulers/index.html" name="monix.execution.schedulers" id="monix.execution.schedulers" class="extype">monix.execution.schedulers</a> contains several
   useful <a href="../execution/Scheduler.html" name="monix.execution.Scheduler" id="monix.execution.Scheduler" class="extype">Scheduler</a> implementations</li><li><a href="../execution/rstreams/index.html" name="monix.execution.rstreams" id="monix.execution.rstreams" class="extype">monix.execution.rstreams</a> contains helpers for dealing
   with the <a href="http://www.reactive-streams.org" target="_blank">Reactive Streams</a> specification</li><li><a href="../execution/misc/index.html" name="monix.execution.misc" id="monix.execution.misc" class="extype">monix.execution.misc</a> provides miscellaneous primitives
   useful for dealing with concurrency</li><li><a href="../execution/exceptions/index.html" name="monix.execution.exceptions" id="monix.execution.exceptions" class="extype">monix.execution.exceptions</a> groups some exceptions thrown by
   the implementation</li></ul><p><b><a href="../catnap/index.html" name="monix.catnap" id="monix.catnap" class="extype">monix.catnap</a></b> exposes pure abstractions built on top of
the <a href="https://typelevel.org/cats-effect/" target="_blank">Cats-Effect</a> type classes:</p><ul><li><a href="../catnap/cancelables/index.html" name="monix.catnap.cancelables" id="monix.catnap.cancelables" class="extype">monix.catnap.cancelables</a> exposes pure counterparts to the
   cancelable data types described in <a href="../execution/cancelables/index.html" name="monix.execution.cancelables" id="monix.execution.cancelables" class="extype">monix.execution.cancelables</a></li></ul><p><b><a href="../eval/index.html" name="monix.eval" id="monix.eval" class="extype">monix.eval</a></b> is for dealing with evaluation of results, thus exposing
<a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a> and <a href="../eval/Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>.</p><p><b><a href="../reactive/index.html" name="monix.reactive" id="monix.reactive" class="extype">monix.reactive</a></b> exposes the <code>Observable</code> pattern:</p><ul><li><a href="../reactive/observables/index.html" name="monix.reactive.observables" id="monix.reactive.observables" class="extype">monix.reactive.observables</a> groups reusable <code>Observable</code> implementations</li><li><a href="../reactive/observers/index.html" name="monix.reactive.observers" id="monix.reactive.observers" class="extype">monix.reactive.observers</a> groups reusable <a href="../reactive/Observer.html" name="monix.reactive.Observer" id="monix.reactive.Observer" class="extype">Observer</a>
   implementations</li><li><a href="../reactive/subjects/index.html" name="monix.reactive.subjects" id="monix.reactive.subjects" class="extype">monix.reactive.subjects</a> exposes <a href="../reactive/subjects/Subject.html" name="monix.reactive.subjects.Subject" id="monix.reactive.subjects.Subject" class="extype">Subject</a>
   and <a href="../reactive/subjects/ConcurrentSubject.html" name="monix.reactive.subjects.ConcurrentSubject" id="monix.reactive.subjects.ConcurrentSubject" class="extype">ConcurrentSubject</a>,
   which are implementations of hot observables that function both as input and output</li></ul><p><b><a href="index.html" name="monix.tail" id="monix.tail" class="extype">monix.tail</a></b> exposes <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a> for purely functional pull based streaming:</p><ul><li><a href="batches/index.html" name="monix.tail.batches" id="monix.tail.batches" class="extype">monix.tail.batches</a> describes <code>Batch</code> and <code>BatchCursor</code>, the
   alternatives to Scala's <code>Iterable</code> and <code>Iterator</code> respectively that
   we are using within Iterant's encoding</li></ul><p>You can control evaluation with type you choose - be it <a href="../eval/Task.html" name="monix.eval.Task" id="monix.eval.Task" class="extype">Task</a>, <a href="../eval/Coeval.html" name="monix.eval.Coeval" id="monix.eval.Coeval" class="extype">Coeval</a>, <a href="https://typelevel.org/cats-effect/api/cats/effect/IO.html" target="_blank">cats.effect.IO</a>
or your own as long as you provide correct <a href="https://typelevel.org/cats-effect/typeclasses/" target="_blank">cats-effect</a> or <a href="https://typelevel.org/cats/typeclasses.html" target="_blank">cats</a> typeclass instance.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.monix" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="monix"></a><a id="monix:monix"></a> <span class="permalink"><a href="../../monix/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">monix</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="monix.tail" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="tail"></a><a id="tail:tail"></a> <span class="permalink"><a href="../../monix/tail/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title=""><span class="name">tail</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="monix" id="monix" class="extype">monix</a></dd></dl></div></li><li class="indented3 " name="monix.tail.Iterant" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Iterant"></a><a id="Iterant:Iterant"></a> <span class="permalink"><a href="../../monix/tail/Iterant$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Iterant$.html" title="Defines the standard Iterant builders."><span class="name">Iterant</span></a><span class="result"> extends <span name="monix.tail.IterantInstances" class="extype">IterantInstances</span> with <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></span></span><p class="shortcomment cmt">Defines the standard <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a> builders.</p><div class="fullcomment"><div class="comment cmt"><p>Defines the standard <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a> builders.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="monix.tail" id="monix.tail" class="extype">tail</a></dd></dl></div></li><li class="current-entities indented3"><span class="separator"></span> <a href="Iterant$$CatsSyncInstances.html" title="Provides the cats.effect.Sync instance for Iterant." class="class"></a><a href="Iterant$$CatsSyncInstances.html" title="Provides the cats.effect.Sync instance for Iterant.">CatsSyncInstances</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Iterant$$Concat.html" title="The Concat state of the Iterant represents a state that specifies the concatenation of two streams." class="class"></a><a href="Iterant$$Concat.html" title="The Concat state of the Iterant represents a state that specifies the concatenation of two streams.">Concat</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Iterant$$Deprecated.html" title="Extension methods for deprecated methods." class="class"></a><a href="Iterant$$Deprecated.html" title="Extension methods for deprecated methods.">Deprecated</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Iterant$$Halt.html" title="The Halt state of the Iterant represents the completion state of a stream, with an optional exception if an error happened." class="class"></a><a href="Iterant$$Halt.html" title="The Halt state of the Iterant represents the completion state of a stream, with an optional exception if an error happened.">Halt</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Iterant$$Last.html" title="The Last state of the Iterant represents a completion state as an alternative to Halt(None), describing one last element." class="class"></a><a href="Iterant$$Last.html" title="The Last state of the Iterant represents a completion state as an alternative to Halt(None), describing one last element.">Last</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Iterant$$Next.html" title="The Next state of the Iterant represents a item / rest cons pair, where the head item is a strict value." class="class"></a><a href="Iterant$$Next.html" title="The Next state of the Iterant represents a item / rest cons pair, where the head item is a strict value.">Next</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Iterant$$NextBatch.html" title="The NextBatch state of the Iterant represents an batch / rest cons pair, where batch is an Iterable type that can generate a whole batch of elements." class="class"></a><a href="Iterant$$NextBatch.html" title="The NextBatch state of the Iterant represents an batch / rest cons pair, where batch is an Iterable type that can generate a whole batch of elements.">NextBatch</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Iterant$$NextCursor.html" title="The NextCursor state of the Iterant represents an batch / rest cons pair, where batch is an Iterator type that can generate a whole batch of elements." class="class"></a><a href="Iterant$$NextCursor.html" title="The NextCursor state of the Iterant represents an batch / rest cons pair, where batch is an Iterator type that can generate a whole batch of elements.">NextCursor</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Iterant$$Scope.html" title="The Scope state of the Iterant represents a stream that is able to specify the acquisition and release of a resource, to be used in generating stream events." class="class"></a><a href="Iterant$$Scope.html" title="The Scope state of the Iterant represents a stream that is able to specify the acquisition and release of a resource, to be used in generating stream events.">Scope</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="" title="Builds a stream state equivalent with Iterant.NextCursor." class="class"></a><a href="" title="Builds a stream state equivalent with Iterant.NextCursor.">Suspend</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Iterant$$Visitor.html" title="Implements the Visitor Pattern for interpreting the Iterant data structure." class="class"></a><a href="Iterant$$Visitor.html" title="Implements the Visitor Pattern for interpreting the Iterant data structure.">Visitor</a></li></ul></div></div><div id="content"><body class="class type"><div id="definition"><div class="big-circle class">c</div><p id="owner"><a href="../index.html" name="monix" id="monix" class="extype">monix</a>.<a href="index.html" name="monix.tail" id="monix.tail" class="extype">tail</a>.<a href="Iterant$.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></p><h1>Suspend<span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier">final </span> <span class="kind">case class</span></span> <span class="symbol"><span class="name">Suspend</span><span class="tparams">[<span name="F">F<span class="tparams">[<span name="_">_</span>]</span></span>, <span name="A">A</span>]</span><span class="params">(<span name="rest">rest: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]]</span>)</span><span class="result"> extends <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>] with <a href="https://www.scala-lang.org/api/2.13.3/scala/Product.html#scala.Product" name="scala.Product" id="scala.Product" class="extype">Product</a> with <span name="scala.Serializable" class="extype">Serializable</span></span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Builds a stream state equivalent with <a href="Iterant$$NextCursor.html" name="monix.tail.Iterant.NextCursor" id="monix.tail.Iterant.NextCursor" class="extype">Iterant.NextCursor</a>.</p><p>The <a href="" name="monix.tail.Iterant.Suspend" id="monix.tail.Iterant.Suspend" class="extype">Suspend</a> state
        of the <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a> represents a suspended stream to be
        evaluated in the <code>F</code> context. It is useful to delay the
        evaluation of a stream by deferring to <code>F</code>.</p></div><dl class="paramcmts block"><dt class="param">rest</dt><dd class="cmt"><p>is the next state in the sequence that
        will produce the rest of the stream when evaluated</p></dd></dl><dl class="attributes block"><dt>Source</dt><dd><a href="https://github.com/monix/monix/tree/346352380c4b2b12a66f83cf7ca416dbebde357b/monix-tail/shared/src/main/scala/monix/tail/Iterant.scala" target="_blank">Iterant.scala</a></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>], <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a>, <a href="https://www.scala-lang.org/api/2.13.3/scala/Product.html#scala.Product" name="scala.Product" id="scala.Product" class="extype">Product</a>, <a href="https://www.scala-lang.org/api/2.13.3/scala/Equals.html#scala.Equals" name="scala.Equals" id="scala.Equals" class="extype">Equals</a>, <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>, <a href="https://www.scala-lang.org/api/2.13.3/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="monix.tail.Iterant.Suspend"><span>Suspend</span></li><li class="in" name="monix.tail.Iterant"><span>Iterant</span></li><li class="in" name="java.io.Serializable"><span>Serializable</span></li><li class="in" name="scala.Product"><span>Product</span></li><li class="in" name="scala.Equals"><span>Equals</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="constructors" class="members"><h3>Instance Constructors</h3><ol><li class="indented0 " name="monix.tail.Iterant.Suspend#&lt;init&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="&lt;init&gt;(rest:F[monix.tail.Iterant[F,A]]):monix.tail.Iterant.Suspend[F,A]"></a><a id="&lt;init&gt;:Suspend[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#&lt;init&gt;(rest:F[monix.tail.Iterant[F,A]]):monix.tail.Iterant.Suspend[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">new</span></span> <span class="symbol"><span class="name">Suspend</span><span class="params">(<span name="rest">rest: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]]</span>)</span></span><p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="paramcmts block"><dt class="param">rest</dt><dd class="cmt"><p>is the next state in the sequence that
        will produce the rest of the stream when evaluated</p></dd></dl></div></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##:Int"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html###:Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#++" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="++[B&gt;:A](rhs:=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="++[B&gt;:A](=&gt;Iterant[F,B])(Sync[F]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#++[B&gt;:A](rhs:=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $plus$plus">++</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span></span>]</span><span class="params">(<span name="rhs">rhs: =&gt; <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.++.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.++.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Appends the given stream to the end of the source, effectively
concatenating them.</p><div class="fullcomment"><div class="comment cmt"><p>Appends the given stream to the end of the source, effectively
concatenating them.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 1, 2, 3, 4</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>) ++ Iterant[Task].of(<span class="num">3</span>, <span class="num">4</span>)</pre></div><dl class="paramcmts block"><dt class="param">rhs</dt><dd class="cmt"><p>is the (right hand side) lazily evaluated iterant to concatenate at
       the end of this iterant.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#++" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="++[B&gt;:A](rhs:F[monix.tail.Iterant[F,B]])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="++[B&gt;:A](F[Iterant[F,B]])(Sync[F]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#++[B&gt;:A](rhs:F[monix.tail.Iterant[F,B]])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $plus$plus">++</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span></span>]</span><span class="params">(<span name="rhs">rhs: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.++.B" class="extype">B</span>]]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.++.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Appends a stream to the end of the source, effectively
concatenating them.</p><div class="fullcomment"><div class="comment cmt"><p>Appends a stream to the end of the source, effectively
concatenating them.</p><p>The right hand side is suspended in the <code>F[_]</code> data type, thus
allowing for laziness.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 1, 2, 3, 4</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>) ++ Task.eval {
  Iterant[Task].of(<span class="num">3</span>, <span class="num">4</span>)
}</pre></div><dl class="paramcmts block"><dt class="param">rhs</dt><dd class="cmt"><p>is the iterant to append at the end of our source.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#+:" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="+:[B&gt;:A](head:B)(implicitF:cats.Applicative[F]):monix.tail.Iterant[F,B]"></a><a id="+:[B&gt;:A](B)(Applicative[F]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#+:[B&gt;:A](head:B)(implicitF:cats.Applicative[F]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $plus$colon">+:</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span></span>]</span><span class="params">(<span name="head">head: <span name="monix.tail.Iterant.+:.B" class="extype">B</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="http://typelevel.org/cats/api/cats/Applicative.html#cats.Applicative" name="cats.Applicative" id="cats.Applicative" class="extype">Applicative</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.+:.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Prepends an element to the iterant, returning a new
iterant that will start with the given <code>head</code> and then
continue with the source.</p><div class="fullcomment"><div class="comment cmt"><p>Prepends an element to the iterant, returning a new
iterant that will start with the given <code>head</code> and then
continue with the source.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 1, 2, 3, 4</span>
<span class="num">1</span> +: Iterant[Task].of(<span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>)</pre></div><dl class="paramcmts block"><dt class="param">head</dt><dd class="cmt"><p>is the element to prepend at the start of
       this iterant</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#:+" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id=":+[B&gt;:A](elem:B)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id=":+[B&gt;:A](B)(Sync[F]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#:+[B&gt;:A](elem:B)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $colon$plus">:+</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span></span>]</span><span class="params">(<span name="elem">elem: <span name="monix.tail.Iterant.:+.B" class="extype">B</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.:+.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Appends the right hand side element to the end of this iterant.</p><div class="fullcomment"><div class="comment cmt"><p>Appends the right hand side element to the end of this iterant.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 1, 2, 3, 4</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>) :+ <span class="num">4</span></pre></div><dl class="paramcmts block"><dt class="param">elem</dt><dd class="cmt"><p>is the element to append at the end</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant.Suspend#accept" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="accept[R](visitor:monix.tail.Iterant.Visitor[F,A,R]):R"></a><a id="accept[R](Visitor[F,A,R]):R"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#accept[R](visitor:monix.tail.Iterant.Visitor[F,A,R]):R" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">accept</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="visitor">visitor: <a href="Iterant$$Visitor.html" name="monix.tail.Iterant.Visitor" id="monix.tail.Iterant.Visitor" class="extype">Visitor</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>, <span name="monix.tail.Iterant.Suspend.accept.R" class="extype">R</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.accept.R" class="extype">R</span></span></span><p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="" name="monix.tail.Iterant.Suspend" id="monix.tail.Iterant.Suspend" class="extype">Suspend</a> → <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Iterant$$Visitor.html" name="monix.tail.Iterant.Visitor" id="monix.tail.Iterant.Visitor" class="extype">Iterant.Visitor</a>.</p></span></dd></dl></div></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#attempt" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="attempt(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,Either[Throwable,A]]"></a><a id="attempt(Sync[F]):Iterant[F,Either[Throwable,A]]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#attempt(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,Either[Throwable,A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">attempt</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="scala.Either" class="extype">Either</span>[<span name="scala.Throwable" class="extype">Throwable</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Converts the source <code>Iterant</code> that emits <code>A</code> elements into an
iterant that emits <code>Either[Throwable, A]</code>, thus materializing
whatever error that might interrupt the stream.</p><div class="fullcomment"><div class="comment cmt"><p>Converts the source <code>Iterant</code> that emits <code>A</code> elements into an
iterant that emits <code>Either[Throwable, A]</code>, thus materializing
whatever error that might interrupt the stream.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> monix.execution.exceptions.DummyException

<span class="cmt">// Yields Right(1), Right(2), Right(3)</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>).attempt

<span class="cmt">// Yields Right(1), Right(2), Left(DummyException())</span>
(Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>) ++
  Iterant[Task].raiseError[<span class="std">Int</span>](DummyException(<span class="lit">"dummy"</span>))).attempt</pre></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#batched" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="batched(count:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="batched(Int)(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#batched(count:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">batched</span><span class="params">(<span name="count">count: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Optimizes the access to the source by periodically gathering
items emitted into batches of the specified size and emitting
<a href="Iterant$$NextBatch.html" name="monix.tail.Iterant.NextBatch" id="monix.tail.Iterant.NextBatch" class="extype">NextBatch</a> nodes.</p><div class="fullcomment"><div class="comment cmt"><p>Optimizes the access to the source by periodically gathering
items emitted into batches of the specified size and emitting
<a href="Iterant$$NextBatch.html" name="monix.tail.Iterant.NextBatch" id="monix.tail.Iterant.NextBatch" class="extype">NextBatch</a> nodes.</p><p>For this operation we have this law:</p><p><code>source.batched(16) &lt;-&gt; source</code></p><p>This means that the result will emit exactly what the source
emits, however the underlying representation will be different,
the emitted notes being of type <code>NextBatch</code>, wrapping arrays
with the length equal to the given <code>count</code>.</p><p>Very similar in behavior with <a href="Iterant.html#bufferTumbling(count:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,Seq[A]]" name="monix.tail.Iterant#bufferTumbling" id="monix.tail.Iterant#bufferTumbling" class="extmbr">bufferTumbling</a>, however the
batches are implicit, not explicit. Useful for optimization.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#bufferSliding" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bufferSliding(count:Int,skip:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,Seq[A]]"></a><a id="bufferSliding(Int,Int)(Sync[F]):Iterant[F,Seq[A]]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#bufferSliding(count:Int,skip:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,Seq[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bufferSliding</span><span class="params">(<span name="count">count: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>, <span name="skip">skip: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="scala.Seq" class="extype">Seq</span>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Returns an iterant that emits buffers of items it collects from
the source iterant.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an iterant that emits buffers of items it collects from
the source iterant. The resulting iterant emits buffers
every <code>skip</code> items, each containing <code>count</code> items.</p><p>If the source iterant completes, then the current buffer gets
signaled downstream. If the source triggers an error then the
current buffer is being dropped and the error gets propagated
immediately.</p><p>For <code>count</code> and <code>skip</code> there are 3 possibilities:</p><ol class="decimal"><li>in case <code>skip == count</code>, then there are no items dropped and
    no overlap, the call being equivalent to <code>buffer(count)</code></li><li>in case <code>skip &lt; count</code>, then overlap between buffers
    happens, with the number of elements being repeated being
    <code>count - skip</code></li><li>in case <code>skip &gt; count</code>, then <code>skip - count</code> elements start
    getting dropped between windows</li></ol><p>Example:</p><pre><span class="kw">import</span> monix.eval.Coeval

<span class="kw">val</span> source = Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>, <span class="num">7</span>)

<span class="cmt">// Yields Seq(1, 2, 3), Seq(4, 5, 6), Seq(7)</span>
source.bufferSliding(<span class="num">3</span>, <span class="num">3</span>)

<span class="cmt">// Yields Seq(1, 2, 3), Seq(5, 6, 7)</span>
source.bufferSliding(<span class="num">3</span>, <span class="num">4</span>)

<span class="cmt">// Yields Seq(1, 2, 3), Seq(3, 4, 5), Seq(5, 6, 7)</span>
source.bufferSliding(<span class="num">3</span>, <span class="num">2</span>)</pre></div><dl class="paramcmts block"><dt class="param">count</dt><dd class="cmt"><p>the maximum size of each buffer before it should
       be emitted</p></dd><dt class="param">skip</dt><dd class="cmt"><p>how many items emitted by the source iterant should
       be skipped before starting a new buffer. Note that when
       skip and count are equal, this is the same operation as
       <code>bufferTumbling(count)</code></p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#bufferTumbling" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="bufferTumbling(count:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,Seq[A]]"></a><a id="bufferTumbling(Int)(Sync[F]):Iterant[F,Seq[A]]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#bufferTumbling(count:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,Seq[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">bufferTumbling</span><span class="params">(<span name="count">count: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="scala.Seq" class="extype">Seq</span>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Periodically gather items emitted by an iterant into bundles
and emit these bundles rather than emitting the items one at a
time.</p><div class="fullcomment"><div class="comment cmt"><p>Periodically gather items emitted by an iterant into bundles
and emit these bundles rather than emitting the items one at a
time. This version of <code>buffer</code> is emitting items once the
internal buffer has reached the given count.</p><p>If the source iterant completes, then the current buffer gets
signaled downstream. If the source triggers an error then the
current buffer is being dropped and the error gets propagated
immediately.</p><pre><span class="kw">import</span> monix.eval.Coeval

<span class="cmt">// Yields Seq(1, 2, 3), Seq(4, 5, 6), Seq(7)</span>
Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>, <span class="num">7</span>).bufferTumbling(<span class="num">3</span>)</pre></div><dl class="paramcmts block"><dt class="param">count</dt><dd class="cmt"><p>the maximum size of each buffer before it should
       be emitted</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Iterant.html#bufferSliding(count:Int,skip:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,Seq[A]]" name="monix.tail.Iterant#bufferSliding" id="monix.tail.Iterant#bufferSliding" class="extmbr">bufferSliding</a> for the more flexible version that allows
     to specify a <code>skip</code> argument.</p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object"></a><a id="clone():AnyRef"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#collect" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="collect[B](pf:PartialFunction[A,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="collect[B](PartialFunction[A,B])(Sync[F]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#collect[B](pf:PartialFunction[A,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">collect</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="pf">pf: <a href="https://www.scala-lang.org/api/2.13.3/scala/PartialFunction.html#scala.PartialFunction" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>, <span name="monix.tail.Iterant.collect.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.collect.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Builds a new iterant by applying a partial function to all
elements of the source on which the function is defined.</p><div class="fullcomment"><div class="comment cmt"><p>Builds a new iterant by applying a partial function to all
elements of the source on which the function is defined.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 2, 4, 6</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>)
  .map { x <span class="kw">=&gt;</span> <span class="std">Option</span>(x).filter(_ % <span class="num">2</span> == <span class="num">0</span>) }
  .collect { <span class="kw">case</span> <span class="std">Some</span>(x) <span class="kw">=&gt;</span> x }</pre></div><dl class="paramcmts block"><dt class="tparam">B</dt><dd class="cmt"><p>the element type of the returned iterant.</p></dd><dt class="param">pf</dt><dd class="cmt"><p>the partial function that filters and maps the iterant</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant resulting from applying the partial
        function <code>pf</code> to each element on which it is defined and
        collecting the results. The order of the elements is
        preserved.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#completedL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="completedL(implicitF:cats.effect.Sync[F]):F[Unit]"></a><a id="completedL(Sync[F]):F[Unit]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#completedL(implicitF:cats.effect.Sync[F]):F[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">completedL</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Upon evaluation of the result, consumes this iterant to
completion.</p><div class="fullcomment"><div class="comment cmt"><p>Upon evaluation of the result, consumes this iterant to
completion.</p><p>Example: </p><pre><span class="kw">import</span> cats.implicits._
<span class="kw">import</span> monix.eval.Task

<span class="cmt">// Whatever...</span>
<span class="kw">val</span> iterant = Iterant[Task].range(<span class="num">0</span>, <span class="num">10000</span>)

<span class="kw">val</span> onFinish: Task[<span class="std">Unit</span>] =
  iterant.completedL &gt;&gt; Task.eval(println(<span class="lit">"Done!"</span>))</pre></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#concat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="concat[B](implicitev:A&lt;:&lt;monix.tail.Iterant[F,B],implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="concat[B](&lt;:&lt;[A,Iterant[F,B]],Sync[F]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#concat[B](implicitev:A&lt;:&lt;monix.tail.Iterant[F,B],implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">concat</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.3/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>, <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.concat.B" class="extype">B</span>]]</span>, <span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.concat.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Alias for <a href="Iterant.html#concat[B](implicitev:A&lt;:&lt;monix.tail.Iterant[F,B],implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" name="monix.tail.Iterant#concat" id="monix.tail.Iterant#concat" class="extmbr">concat</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Alias for <a href="Iterant.html#concat[B](implicitev:A&lt;:&lt;monix.tail.Iterant[F,B],implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" name="monix.tail.Iterant#concat" id="monix.tail.Iterant#concat" class="extmbr">concat</a>.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#concatMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="concatMap[B](f:A=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="concatMap[B]((A)=&gt;Iterant[F,B])(Sync[F]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#concatMap[B](f:A=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">concatMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.concatMap.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.concatMap.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Alias for <a href="Iterant.html#flatMap[B](f:A=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" name="monix.tail.Iterant#flatMap" id="monix.tail.Iterant#flatMap" class="extmbr">flatMap</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Alias for <a href="Iterant.html#flatMap[B](f:A=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" name="monix.tail.Iterant#flatMap" id="monix.tail.Iterant#flatMap" class="extmbr">flatMap</a>.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#consume" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="consume(implicitF:cats.effect.Concurrent[F],implicitcs:cats.effect.ContextShift[F]):cats.effect.Resource[F,monix.tail.Iterant.Consumer[F,A]]"></a><a id="consume(Concurrent[F],ContextShift[F]):Resource[F,Consumer[F,A]]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#consume(implicitF:cats.effect.Concurrent[F],implicitcs:cats.effect.ContextShift[F]):cats.effect.Resource[F,monix.tail.Iterant.Consumer[F,A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">consume</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Concurrent" class="extype">Concurrent</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>, <span name="cs">cs: <span name="cats.effect.ContextShift" class="extype">ContextShift</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="cats.effect.Resource" class="extype">Resource</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <a href="Iterant$.html#Consumer[F[_],A]=monix.catnap.ConsumerF[F,Option[Throwable],A]" name="monix.tail.Iterant.Consumer" id="monix.tail.Iterant.Consumer" class="extmbr">Consumer</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Create a <a href="../catnap/ConsumerF.html" name="monix.catnap.ConsumerF" id="monix.catnap.ConsumerF" class="extype">ConsumerF</a> value that can be used to
consume events from the channel.</p><div class="fullcomment"><div class="comment cmt"><p>Create a <a href="../catnap/ConsumerF.html" name="monix.catnap.ConsumerF" id="monix.catnap.ConsumerF" class="extype">ConsumerF</a> value that can be used to
consume events from the channel.</p><p>The returned value is a
<a href="https://typelevel.org/cats-effect/datatypes/resource.html" target="_blank">Resource</a>,
because a consumer can be unsubscribed from the channel early, with its
internal buffer being garbage collected and the finalizers of the source
being triggered.</p><pre><span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> monix.tail.Iterant.Consumer

<span class="kw">def</span> sum(channel: Consumer[Task, <span class="std">Int</span>], acc: <span class="std">Long</span> = <span class="num">0</span>): Task[<span class="std">Long</span>] =
  channel.pull.flatMap {
    <span class="kw">case</span> Right(a) <span class="kw">=&gt;</span>
      sum(channel, acc + a)
    <span class="kw">case</span> Left(<span class="std">None</span>) <span class="kw">=&gt;</span>
      Task.pure(acc)
    <span class="kw">case</span> Left(<span class="std">Some</span>(e)) <span class="kw">=&gt;</span>
      Task.raiseError(e)
  }

Iterant[Task].range(<span class="num">0</span>, <span class="num">10000</span>).consume.use { consumer <span class="kw">=&gt;</span>
  sum(consumer)
}</pre></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Iterant.html#consumeWithConfig(config:monix.catnap.ConsumerF.Config)(implicitF:cats.effect.Concurrent[F],implicitcs:cats.effect.ContextShift[F]):cats.effect.Resource[F,monix.tail.Iterant.Consumer[F,A]]" name="monix.tail.Iterant#consumeWithConfig" id="monix.tail.Iterant#consumeWithConfig" class="extmbr">consumeWithConfig</a> for fine tuning the internal buffer of the
     created consumer</p></span></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#consumeWithConfig" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="consumeWithConfig(config:monix.catnap.ConsumerF.Config)(implicitF:cats.effect.Concurrent[F],implicitcs:cats.effect.ContextShift[F]):cats.effect.Resource[F,monix.tail.Iterant.Consumer[F,A]]"></a><a id="consumeWithConfig(Config)(Concurrent[F],ContextShift[F]):Resource[F,Consumer[F,A]]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#consumeWithConfig(config:monix.catnap.ConsumerF.Config)(implicitF:cats.effect.Concurrent[F],implicitcs:cats.effect.ContextShift[F]):cats.effect.Resource[F,monix.tail.Iterant.Consumer[F,A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">consumeWithConfig</span><span class="params">(<span name="config">config: <a href="../catnap/ConsumerF$$Config.html" name="monix.catnap.ConsumerF.Config" id="monix.catnap.ConsumerF.Config" class="extype">Config</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Concurrent" class="extype">Concurrent</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>, <span name="cs">cs: <span name="cats.effect.ContextShift" class="extype">ContextShift</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="cats.effect.Resource" class="extype">Resource</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <a href="Iterant$.html#Consumer[F[_],A]=monix.catnap.ConsumerF[F,Option[Throwable],A]" name="monix.tail.Iterant.Consumer" id="monix.tail.Iterant.Consumer" class="extmbr">Consumer</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Version of <a href="Iterant.html#consume(implicitF:cats.effect.Concurrent[F],implicitcs:cats.effect.ContextShift[F]):cats.effect.Resource[F,monix.tail.Iterant.Consumer[F,A]]" name="monix.tail.Iterant#consume" id="monix.tail.Iterant#consume" class="extmbr">consume</a> that allows for fine tuning the underlying
buffer used.</p><div class="fullcomment"><div class="comment cmt"><p>Version of <a href="Iterant.html#consume(implicitF:cats.effect.Concurrent[F],implicitcs:cats.effect.ContextShift[F]):cats.effect.Resource[F,monix.tail.Iterant.Consumer[F,A]]" name="monix.tail.Iterant#consume" id="monix.tail.Iterant#consume" class="extmbr">consume</a> that allows for fine tuning the underlying
buffer used.</p><p>There are two parameters that can be configured:</p><ul><li>the <a href="../execution/BufferCapacity.html" name="monix.execution.BufferCapacity" id="monix.execution.BufferCapacity" class="extype">BufferCapacity</a>, which can be
   <a href="../execution/BufferCapacity$$Unbounded.html" name="monix.execution.BufferCapacity.Unbounded" id="monix.execution.BufferCapacity.Unbounded" class="extype">Unbounded</a>, for an
   unlimited internal buffer in case the consumer is definitely faster
   than the producer, or <a href="../execution/BufferCapacity$$Bounded.html" name="monix.execution.BufferCapacity.Bounded" id="monix.execution.BufferCapacity.Bounded" class="extype">Bounded</a>
   in case back-pressuring a slow consumer is desirable</li><li>the <a href="../execution/ChannelType$$ConsumerSide.html" name="monix.execution.ChannelType.ConsumerSide" id="monix.execution.ChannelType.ConsumerSide" class="extype">ChannelType.ConsumerSide</a>,
   which specifies if this consumer will use multiple workers in parallel
   or not; this is an optimization, with the safe choice being
   <a href="../execution/ChannelType$$MultiConsumer$.html" name="monix.execution.ChannelType.MultiConsumer" id="monix.execution.ChannelType.MultiConsumer" class="extype">MultiConsumer</a>, which
   specifies that multiple workers can use the created consumer in
   parallel, pulling data from multiple threads at the same time; whereas
   <a href="../execution/ChannelType$$SingleConsumer$.html" name="monix.execution.ChannelType.SingleConsumer" id="monix.execution.ChannelType.SingleConsumer" class="extype">SingleConsumer</a> specifies
   that the data will be read sequentially by a single worker, not in
   parallel; this being a risky optimization
</li></ul></div><dl class="paramcmts block"><dt class="param">config</dt><dd class="cmt"><p>is the configuration object for fine tuning the behavior
       of the created consumer, see
       <a href="../catnap/ConsumerF$$Config.html" name="monix.catnap.ConsumerF.Config" id="monix.catnap.ConsumerF.Config" class="extype">ConsumerF.Config1</a></p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd><dt>Annotations</dt><dd><span class="name">@<a href="../execution/annotations/UnsafeProtocol.html" name="monix.execution.annotations.UnsafeProtocol" id="monix.execution.annotations.UnsafeProtocol" class="extype">UnsafeProtocol</a></span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#countL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="countL(implicitF:cats.effect.Sync[F]):F[Long]"></a><a id="countL(Sync[F]):F[Long]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#countL(implicitF:cats.effect.Sync[F]):F[Long]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">countL</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>]</span></span><p class="shortcomment cmt">Counts the total number of elements emitted by the source.</p><div class="fullcomment"><div class="comment cmt"><p>Counts the total number of elements emitted by the source.</p><p>Example:</p><pre><span class="kw">import</span> cats.effect.IO

<span class="cmt">// Yields 100</span>
Iterant[IO].range(<span class="num">0</span>, <span class="num">100</span>).countL

<span class="cmt">// Yields 1</span>
Iterant[IO].pure(<span class="num">1</span>).countL

<span class="cmt">// Yields 0</span>
Iterant[IO].empty[<span class="std">Int</span>].countL</pre></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#distinctUntilChanged" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="distinctUntilChanged(implicitF:cats.effect.Sync[F],implicitA:cats.Eq[A]):monix.tail.Iterant[F,A]"></a><a id="distinctUntilChanged(Sync[F],Eq[A]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#distinctUntilChanged(implicitF:cats.effect.Sync[F],implicitA:cats.Eq[A]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">distinctUntilChanged</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>, <span name="A">A: <span name="cats.Eq" class="extype">Eq</span>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Suppress duplicate consecutive items emitted by the source.</p><div class="fullcomment"><div class="comment cmt"><p>Suppress duplicate consecutive items emitted by the source.</p><p>Example:</p><pre><span class="kw">import</span> cats.implicits._
<span class="kw">import</span> monix.eval.Coeval

<span class="cmt">// Yields 1, 2, 1, 3, 2, 4</span>
Iterant[Coeval].of(<span class="num">1</span>, <span class="num">1</span>, <span class="num">1</span>, <span class="num">2</span>, <span class="num">2</span>, <span class="num">1</span>, <span class="num">1</span>, <span class="num">3</span>, <span class="num">3</span>, <span class="num">3</span>, <span class="num">2</span>, <span class="num">2</span>, <span class="num">4</span>, <span class="num">4</span>, <span class="num">4</span>)
  .distinctUntilChanged</pre><p>Duplication is detected by using the equality relationship
provided by the <code>cats.Eq</code> type class. This allows one to
override the equality operation being used (e.g. maybe the
default <code>.equals</code> is badly defined, or maybe you want reference
equality, so depending on use case).</p><h4>Cats Eq and Scala Interop</h4><p>        Monix prefers to work with <a href="http://typelevel.org/cats/api/cats/index.html#Eq[A]=cats.kernel.Eq[A]" name="cats" id="cats" class="extype">cats.Eq</a> for assessing the equality
        of elements that have an ordering defined, instead of
        <a href="https://www.scala-lang.org/api/2.13.3/scala/math/Equiv.html" name="scala.math.Equiv" id="scala.math.Equiv" class="extype">scala.math.Equiv</a>.</p><p>        We do this because Scala's <code>Equiv</code> has a default instance defined
        that's based on universal equality and that's a big problem, because
        when using the <code>Eq</code> type class, it is universal equality that we
        want to avoid and there have been countless of bugs in the ecosystem
        related to both universal equality and <code>Equiv</code>. Thankfully people
        are working to fix it.</p><p>        We also do this for consistency, as Monix is now building on top of
        Cats. This may change in the future, depending on what happens with
        <a href="https://github.com/typelevel/cats/issues/2455" target="_blank">typelevel/cats#2455</a>.</p><p>        Defining <code>Eq</code> instance is easy and we can use universal equality
        in our definitions as well:</p><pre><span class="kw">import</span> cats.Eq

<span class="kw">case</span> <span class="kw">class</span> Address(host: <span class="std">String</span>, port: <span class="std">Int</span>)

<span class="kw">implicit</span> <span class="kw">val</span> eqForAddress: Eq[Address] =
  Eq.fromUniversalEquals</pre></div><dl class="paramcmts block"><dt class="param">A</dt><dd class="cmt"><p>is the <code>cats.Eq</code> instance that defines equality for <code>A</code></p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#distinctUntilChangedByKey" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="distinctUntilChangedByKey[K](key:A=&gt;K)(implicitF:cats.effect.Sync[F],implicitK:cats.Eq[K]):monix.tail.Iterant[F,A]"></a><a id="distinctUntilChangedByKey[K]((A)=&gt;K)(Sync[F],Eq[K]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#distinctUntilChangedByKey[K](key:A=&gt;K)(implicitF:cats.effect.Sync[F],implicitK:cats.Eq[K]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">distinctUntilChangedByKey</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="key">key: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <span name="monix.tail.Iterant.distinctUntilChangedByKey.K" class="extype">K</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>, <span name="K">K: <span name="cats.Eq" class="extype">Eq</span>[<span name="monix.tail.Iterant.distinctUntilChangedByKey.K" class="extype">K</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Given a function that returns a key for each element emitted by
the source, suppress consecutive duplicate items.</p><div class="fullcomment"><div class="comment cmt"><p>Given a function that returns a key for each element emitted by
the source, suppress consecutive duplicate items.</p><p>Example:</p><pre><span class="kw">import</span> cats.implicits._
<span class="kw">import</span> monix.eval.Coeval

<span class="cmt">// Yields 1, 2, 3, 4</span>
Iterant[Coeval].of(<span class="num">1</span>, <span class="num">3</span>, <span class="num">2</span>, <span class="num">4</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">5</span>, <span class="num">7</span>, <span class="num">4</span>)
  .distinctUntilChangedByKey(_ % <span class="num">2</span>)</pre><p>Duplication is detected by using the equality relationship
provided by the <code>cats.Eq</code> type class. This allows one to
override the equality operation being used (e.g. maybe the
default <code>.equals</code> is badly defined, or maybe you want reference
equality, so depending on use case).</p><h4>Cats Eq and Scala Interop</h4><p>        Monix prefers to work with <a href="http://typelevel.org/cats/api/cats/index.html#Eq[A]=cats.kernel.Eq[A]" name="cats" id="cats" class="extype">cats.Eq</a> for assessing the equality
        of elements that have an ordering defined, instead of
        <a href="https://www.scala-lang.org/api/2.13.3/scala/math/Equiv.html" name="scala.math.Equiv" id="scala.math.Equiv" class="extype">scala.math.Equiv</a>.</p><p>        We do this because Scala's <code>Equiv</code> has a default instance defined
        that's based on universal equality and that's a big problem, because
        when using the <code>Eq</code> type class, it is universal equality that we
        want to avoid and there have been countless of bugs in the ecosystem
        related to both universal equality and <code>Equiv</code>. Thankfully people
        are working to fix it.</p><p>        We also do this for consistency, as Monix is now building on top of
        Cats. This may change in the future, depending on what happens with
        <a href="https://github.com/typelevel/cats/issues/2455" target="_blank">typelevel/cats#2455</a>.</p><p>        Defining <code>Eq</code> instance is easy and we can use universal equality
        in our definitions as well:</p><pre><span class="kw">import</span> cats.Eq

<span class="kw">case</span> <span class="kw">class</span> Address(host: <span class="std">String</span>, port: <span class="std">Int</span>)

<span class="kw">implicit</span> <span class="kw">val</span> eqForAddress: Eq[Address] =
  Eq.fromUniversalEquals</pre></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>is a function that returns a <code>K</code> key for each element,
       a value that's then used to do the deduplication</p></dd><dt class="param">K</dt><dd class="cmt"><p>is the <code>cats.Eq</code> instance that defines equality for
       the key type <code>K</code></p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#drop" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="drop(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="drop(Int)(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#drop(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">drop</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Drops the first <code>n</code> elements (from the start).</p><div class="fullcomment"><div class="comment cmt"><p>Drops the first <code>n</code> elements (from the start).</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 4, 5</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).drop(<span class="num">3</span>)</pre></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>the number of elements to drop</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant that drops the first <i>n</i> elements
        emitted by the source</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#dropLast" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dropLast(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="dropLast(Int)(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#dropLast(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">dropLast</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Drops the last <code>n</code> elements (from the end).</p><div class="fullcomment"><div class="comment cmt"><p>Drops the last <code>n</code> elements (from the end).</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 1, 2</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).dropLast(<span class="num">3</span>)</pre></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>the number of elements to drop</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant that drops the last <i>n</i> elements
        emitted by the source</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#dropWhile" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dropWhile(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="dropWhile((A)=&gt;Boolean)(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#dropWhile(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">dropWhile</span><span class="params">(<span name="p">p: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Drops the longest prefix of elements that satisfy the given
predicate and returns a new iterant that emits the rest.</p><div class="fullcomment"><div class="comment cmt"><p>Drops the longest prefix of elements that satisfy the given
predicate and returns a new iterant that emits the rest.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 4, 5</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).dropWhile(_ &lt; <span class="num">4</span>)</pre></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is the predicate used to test whether the current
       element should be dropped, if <code>true</code>, or to interrupt
       the dropping process, if <code>false</code></p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant that drops the elements of the source
        until the first time the given predicate returns <code>false</code></p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#dropWhileWithIndex" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dropWhileWithIndex(p:(A,Int)=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="dropWhileWithIndex((A,Int)=&gt;Boolean)(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#dropWhileWithIndex(p:(A,Int)=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">dropWhileWithIndex</span><span class="params">(<span name="p">p: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>, <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Drops the longest prefix of elements that satisfy the given
function and returns a new Iterant that emits the rest.</p><div class="fullcomment"><div class="comment cmt"><p>Drops the longest prefix of elements that satisfy the given
function and returns a new Iterant that emits the rest.</p><p>In comparison with <a href="Iterant.html#dropWhile(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" name="monix.tail.Iterant#dropWhile" id="monix.tail.Iterant#dropWhile" class="extmbr">dropWhile</a>, this version accepts a function
that takes an additional parameter: the zero-based index of the
element.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 3, 4, 5</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>)
  .dropWhileWithIndex((value, index) <span class="kw">=&gt;</span> value &gt;= index * <span class="num">2</span>)</pre></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is the predicate used to test whether the current
       element should be dropped, if <code>true</code>, or to interrupt
       the dropping process, if <code>false</code></p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant that drops the elements of the source
        until the first time the given predicate returns <code>false</code></p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#dump" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="dump(prefix:String,out:java.io.PrintStream)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="dump(String,PrintStream)(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#dump(prefix:String,out:java.io.PrintStream)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">dump</span><span class="params">(<span name="prefix">prefix: <span name="scala.Predef.String" class="extype">String</span></span>, <span name="out">out: <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/PrintStream.html#java.io.PrintStream" name="java.io.PrintStream" id="java.io.PrintStream" class="extype">PrintStream</a> = <span class="symbol">System.out</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Dumps incoming events to standard output with provided prefix.</p><div class="fullcomment"><div class="comment cmt"><p>Dumps incoming events to standard output with provided prefix.</p><p>Utility that can be used for debugging purposes.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global

Iterant[Task].range(<span class="num">0</span>, <span class="num">4</span>)
  .dump(<span class="lit">"O"</span>)
  .completedL

<span class="cmt">// 0: O --&gt; next-batch --&gt; 0</span>
<span class="cmt">// 1: O --&gt; next-batch --&gt; 1</span>
<span class="cmt">// 2: O --&gt; next-batch --&gt; 2</span>
<span class="cmt">// 3: O --&gt; next-batch --&gt; 3</span>
<span class="cmt">// 4: O --&gt; halt --&gt; no error</span></pre></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#existsL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="existsL(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):F[Boolean]"></a><a id="existsL((A)=&gt;Boolean)(Sync[F]):F[Boolean]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#existsL(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):F[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">existsL</span><span class="params">(<span name="p">p: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Returns <code>true</code> in case the given predicate is satisfied by any
of the emitted items, or <code>false</code> in case the end of the stream
has been reached with no items satisfying the given predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Returns <code>true</code> in case the given predicate is satisfied by any
of the emitted items, or <code>false</code> in case the end of the stream
has been reached with no items satisfying the given predicate.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Coeval

<span class="kw">val</span> source = Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>)

<span class="cmt">// Yields true</span>
source.existsL(_ % <span class="num">2</span> == <span class="num">0</span>)

<span class="cmt">// Yields false</span>
source.existsL(_ % <span class="num">7</span> == <span class="num">0</span>)</pre></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is a predicate function that's going to test each item
       emitted by the source until we get a positive match for
       one of them or until the stream ends</p></dd><dt>returns</dt><dd class="cmt"><p><code>true</code> if any of the items satisfies the given predicate
       or <code>false</code> if none of them do</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#filter" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="filter(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="filter((A)=&gt;Boolean)(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#filter(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">filter</span><span class="params">(<span name="p">p: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Filters the iterant by the given predicate function, returning
only those elements that match.</p><div class="fullcomment"><div class="comment cmt"><p>Filters the iterant by the given predicate function, returning
only those elements that match.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 2, 4, 6</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).filter(_ % <span class="num">2</span> == <span class="num">0</span>)</pre></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>the predicate used to test elements.</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant consisting of all elements that satisfy
        the given predicate. The order of the elements is
        preserved.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#findL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="findL(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):F[Option[A]]"></a><a id="findL((A)=&gt;Boolean)(Sync[F]):F[Option[A]]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#findL(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):F[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">findL</span><span class="params">(<span name="p">p: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Given a predicate, finds the first item that satisfies it,
returning <code>Some(a)</code> if available, or <code>None</code> otherwise.</p><div class="fullcomment"><div class="comment cmt"><p>Given a predicate, finds the first item that satisfies it,
returning <code>Some(a)</code> if available, or <code>None</code> otherwise.</p><pre><span class="kw">import</span> monix.eval.Coeval

<span class="cmt">// Yields Some(2)</span>
Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).findL(_ % <span class="num">2</span> == <span class="num">0</span>)

<span class="cmt">// Yields None</span>
Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).findL(_ &gt; <span class="num">10</span>)</pre><p>The stream is traversed from beginning to end, the process
being interrupted as soon as it finds one element matching
the predicate, or until the stream ends.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is the function to test the elements of the source</p></dd><dt>returns</dt><dd class="cmt"><p>either <code>Some(value)</code> in case <code>value</code> is an element
        emitted by the source, found to satisfy the predicate,
        or <code>None</code> otherwise</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#flatMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatMap[B](f:A=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="flatMap[B]((A)=&gt;Iterant[F,B])(Sync[F]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#flatMap[B](f:A=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.flatMap.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.flatMap.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Applies the function to the elements of the source and
concatenates the results.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the function to the elements of the source and
concatenates the results.</p><p>This operation is the monadic "bind", with all laws it entails.</p><p>Also note that the implementation can use constant memory
depending on usage, thus it can be used in tail recursive loops.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Effectively equivalent with .filter</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).flatMap { elem <span class="kw">=&gt;</span>
  <span class="kw">if</span> (elem % <span class="num">2</span> == <span class="num">0</span>)
    Iterant[Task].pure(elem)
  <span class="kw">else</span>
    Iterant[Task].empty[<span class="std">Int</span>]
}</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the function mapping elements from the
       source to iterants</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#flatten" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatten[B](implicitev:A&lt;:&lt;monix.tail.Iterant[F,B],implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="flatten[B](&lt;:&lt;[A,Iterant[F,B]],Sync[F]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#flatten[B](implicitev:A&lt;:&lt;monix.tail.Iterant[F,B],implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatten</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="https://www.scala-lang.org/api/2.13.3/scala/$less$colon$less.html#scala.%3C:%3C" name="scala.&lt;:&lt;" id="scala.&lt;:&lt;" class="extype">&lt;:&lt;</a>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>, <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.flatten.B" class="extype">B</span>]]</span>, <span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.flatten.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Given an <code>Iterant</code> that generates <code>Iterant</code> elements, concatenates
all the generated iterants.</p><div class="fullcomment"><div class="comment cmt"><p>Given an <code>Iterant</code> that generates <code>Iterant</code> elements, concatenates
all the generated iterants.</p><p>Equivalent with: <code>source.flatMap(x =&gt; x)</code>
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#foldL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foldL(implicitF:cats.effect.Sync[F],implicitA:cats.Monoid[A]):F[A]"></a><a id="foldL(Sync[F],Monoid[A]):F[A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#foldL(implicitF:cats.effect.Sync[F],implicitA:cats.Monoid[A]):F[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foldL</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>, <span name="A">A: <span name="cats.Monoid" class="extype">Monoid</span>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Given evidence that type <code>A</code> has a <code>cats.Monoid</code> implementation,
folds the stream with the provided monoid definition.</p><div class="fullcomment"><div class="comment cmt"><p>Given evidence that type <code>A</code> has a <code>cats.Monoid</code> implementation,
folds the stream with the provided monoid definition.</p><p>For streams emitting numbers, this effectively sums them up.
For strings, this concatenates them.</p><p>Example:</p><pre><span class="kw">import</span> cats.implicits._
<span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 10</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).foldL

<span class="cmt">// Yields "1234"</span>
Iterant[Task].of(<span class="lit">"1"</span>, <span class="lit">"2"</span>, <span class="lit">"3"</span>, <span class="lit">"4"</span>).foldL</pre><p>Note, in case you don't have a <code>Monoid</code> instance in scope,
but you feel like you should, try one of these imports:</p><pre><span class="cmt">// everything</span>
<span class="kw">import</span> cats.implicits._
<span class="cmt">// a la carte:</span>
<span class="kw">import</span> cats.instances.all._</pre></div><dl class="paramcmts block"><dt class="param">A</dt><dd class="cmt"><p>is the <code>cats.Monoid</code> type class instance that's needed
         in scope for folding the source</p></dd><dt>returns</dt><dd class="cmt"><p>the result of combining all elements of the source,
        or the defined <code>Monoid.empty</code> element in case the
        stream is empty</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#foldLeftL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foldLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):F[S]"></a><a id="foldLeftL[S](=&gt;S)((S,A)=&gt;S)(Sync[F]):F[S]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#foldLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):F[S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foldLeftL</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: =&gt; <span name="monix.tail.Iterant.foldLeftL.S" class="extype">S</span></span>)</span><span class="params">(<span name="op">op: (<span name="monix.tail.Iterant.foldLeftL.S" class="extype">S</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <span name="monix.tail.Iterant.foldLeftL.S" class="extype">S</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<span name="monix.tail.Iterant.foldLeftL.S" class="extype">S</span>]</span></span><p class="shortcomment cmt">Left associative fold using the function <code>op</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Left associative fold using the function <code>op</code>.</p><p>On execution the stream will be traversed from left to right,
and the given function will be called with the prior result,
accumulating state until the end, when the summary is returned.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 15 (1 + 2 + 3 + 4 + 5)</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).foldLeftL(<span class="num">0</span>)(_ + _)</pre></div><dl class="paramcmts block"><dt class="param">seed</dt><dd class="cmt"><p>is the start value</p></dd><dt class="param">op</dt><dd class="cmt"><p>is the binary operator</p></dd><dt>returns</dt><dd class="cmt"><p>the result of inserting <code>op</code> between consecutive
        elements of this iterant, going from left to right with
        the <code>seed</code> as the start value, or <code>seed</code> if the iterant
        is empty.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#foldRightL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foldRightL[B](b:F[B])(f:(A,F[B])=&gt;F[B])(implicitF:cats.effect.Sync[F]):F[B]"></a><a id="foldRightL[B](F[B])((A,F[B])=&gt;F[B])(Sync[F]):F[B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#foldRightL[B](b:F[B])(f:(A,F[B])=&gt;F[B])(implicitF:cats.effect.Sync[F]):F[B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foldRightL</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="b">b: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<span name="monix.tail.Iterant.foldRightL.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>, <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<span name="monix.tail.Iterant.foldRightL.B" class="extype">B</span>]) =&gt; <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<span name="monix.tail.Iterant.foldRightL.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<span name="monix.tail.Iterant.foldRightL.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Lazily fold the stream to a single value from the right.</p><div class="fullcomment"><div class="comment cmt"><p>Lazily fold the stream to a single value from the right.</p><p>This is the common <code>foldr</code> operation from Haskell's <code>Foldable</code>,
or <code>foldRight</code> from <code>cats.Foldable</code>, but with the difference that
<code>Iterant</code> is a lazy data type and thus it has to operate in the <code>F[_]</code>
context.</p><p>Here's for example how <a href="Iterant.html#existsL(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):F[Boolean]" name="monix.tail.Iterant#existsL" id="monix.tail.Iterant#existsL" class="extmbr">existsL</a>, <a href="Iterant.html#forallL(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):F[Boolean]" name="monix.tail.Iterant#forallL" id="monix.tail.Iterant#forallL" class="extmbr">forallL</a> and <code>++</code> could
be expressed in terms of <code>foldRightL</code>:</p><pre><span class="kw">import</span> cats.implicits._
<span class="kw">import</span> cats.effect.Sync

<span class="kw">def</span> exists[F[_], A](fa: Iterant[F, A], p: A <span class="kw">=&gt;</span> <span class="std">Boolean</span>)
  (<span class="kw">implicit</span> F: Sync[F]): F[<span class="std">Boolean</span>] = {

  fa.foldRightL(F.pure(<span class="kw">false</span>)) { (a, next) <span class="kw">=&gt;</span>
    <span class="kw">if</span> (p(a)) F.pure(<span class="kw">true</span>) <span class="kw">else</span> next
  }
}

<span class="kw">def</span> forall[F[_], A](fa: Iterant[F, A], p: A <span class="kw">=&gt;</span> <span class="std">Boolean</span>)
  (<span class="kw">implicit</span> F: Sync[F]): F[<span class="std">Boolean</span>] = {

  fa.foldRightL(F.pure(<span class="kw">true</span>)) { (a, next) <span class="kw">=&gt;</span>
    <span class="kw">if</span> (!p(a)) F.pure(<span class="kw">false</span>) <span class="kw">else</span> next
  }
}

<span class="kw">def</span> concat[F[_], A](lh: Iterant[F, A], rh: Iterant[F, A])
  (<span class="kw">implicit</span> F: Sync[F]): Iterant[F, A] = {

  Iterant.suspend[F, A] {
    lh.foldRightL(F.pure(rh)) { (a, rest) <span class="kw">=&gt;</span>
      F.pure(Iterant.nextS(a, rest))
    }
  }
}</pre><p>In this example we are short-circuiting the processing in case
we find the one element that we are looking for, otherwise we
keep traversing the stream until the end, finally returning
the default value in case we haven't found what we were looking
for.
</p></div><dl class="paramcmts block"><dt class="param">b</dt><dd class="cmt"><p>is the starting value; in case <code>f</code> is a binary operator,
       this is typically its left-identity (zero)</p></dd><dt class="param">f</dt><dd class="cmt"><p>is the function to be called that folds the list,
       receiving the current element being iterated on
       (first param) and the (lazy) result from recursively
       combining the rest of the list (second param)</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Iterant.html#foldWhileLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;Either[S,S])(implicitF:cats.effect.Sync[F]):F[S]" name="monix.tail.Iterant#foldWhileLeftL" id="monix.tail.Iterant#foldWhileLeftL" class="extmbr">foldWhileLeftL</a> and <a href="Iterant.html#foldWhileLeftEvalL[S](seed:F[S])(op:(S,A)=&gt;F[Either[S,S]])(implicitF:cats.effect.Sync[F]):F[S]" name="monix.tail.Iterant#foldWhileLeftEvalL" id="monix.tail.Iterant#foldWhileLeftEvalL" class="extmbr">foldWhileLeftEvalL</a></p></span></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#foldWhileLeftEvalL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foldWhileLeftEvalL[S](seed:F[S])(op:(S,A)=&gt;F[Either[S,S]])(implicitF:cats.effect.Sync[F]):F[S]"></a><a id="foldWhileLeftEvalL[S](F[S])((S,A)=&gt;F[Either[S,S]])(Sync[F]):F[S]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#foldWhileLeftEvalL[S](seed:F[S])(op:(S,A)=&gt;F[Either[S,S]])(implicitF:cats.effect.Sync[F]):F[S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foldWhileLeftEvalL</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<span name="monix.tail.Iterant.foldWhileLeftEvalL.S" class="extype">S</span>]</span>)</span><span class="params">(<span name="op">op: (<span name="monix.tail.Iterant.foldWhileLeftEvalL.S" class="extype">S</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<span name="scala.Either" class="extype">Either</span>[<span name="monix.tail.Iterant.foldWhileLeftEvalL.S" class="extype">S</span>, <span name="monix.tail.Iterant.foldWhileLeftEvalL.S" class="extype">S</span>]]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<span name="monix.tail.Iterant.foldWhileLeftEvalL.S" class="extype">S</span>]</span></span><p class="shortcomment cmt">Left associative fold using the function <code>op</code> that can be
short-circuited.</p><div class="fullcomment"><div class="comment cmt"><p>Left associative fold using the function <code>op</code> that can be
short-circuited.</p><p>On execution the stream will be traversed from left to right,
and the given function will be called with the prior result,
accumulating state either until the end, or until <code>op</code> returns
a <code>Right</code> result, when the summary is returned.</p><p>The results are returned in the <code>F[_]</code> functor context, meaning
that we can have lazy or asynchronous processing and we can
suspend side effects, depending on the <code>F</code> data type being used.</p><p>Example using <code>cats.effect.IO</code>: </p><pre><span class="kw">import</span> cats.implicits._
<span class="kw">import</span> cats.effect.IO

<span class="cmt">// Sums first 10 items</span>
Iterant[IO].range(<span class="num">0</span>, <span class="num">1000</span>).foldWhileLeftEvalL(IO((<span class="num">0</span>, <span class="num">0</span>))) {
  <span class="kw">case</span> ((sum, count), e) <span class="kw">=&gt;</span>
    IO {
      <span class="kw">val</span> next = (sum + e, count + <span class="num">1</span>)
      <span class="kw">if</span> (count + <span class="num">1</span> &lt; <span class="num">10</span>) Left(next) <span class="kw">else</span> Right(next)
    }
}

<span class="cmt">// Implements exists(predicate)</span>
Iterant[IO].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).foldWhileLeftEvalL(IO(<span class="kw">false</span>)) {
  (default, e) <span class="kw">=&gt;</span>
    IO { <span class="kw">if</span> (e == <span class="num">3</span>) Right(<span class="kw">true</span>) <span class="kw">else</span> Left(default) }
}

<span class="cmt">// Implements forall(predicate)</span>
Iterant[IO].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).foldWhileLeftEvalL(IO(<span class="kw">true</span>)) {
  (default, e) <span class="kw">=&gt;</span>
    IO { <span class="kw">if</span> (e != <span class="num">3</span>) Right(<span class="kw">false</span>) <span class="kw">else</span> Left(default) }
}</pre></div><dl class="paramcmts block"><dt class="param">seed</dt><dd class="cmt"><p>is the start value</p></dd><dt class="param">op</dt><dd class="cmt"><p>is the binary operator returning either <code>Left</code>,
       signaling that the state should be evolved or a <code>Right</code>,
       signaling that the process can be short-circuited and
       the result returned immediately</p></dd><dt>returns</dt><dd class="cmt"><p>the result of inserting <code>op</code> between consecutive
        elements of this iterant, going from left to right with
        the <code>seed</code> as the start value, or <code>seed</code> if the iterant
        is empty</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Iterant.html#foldWhileLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;Either[S,S])(implicitF:cats.effect.Sync[F]):F[S]" name="monix.tail.Iterant#foldWhileLeftL" id="monix.tail.Iterant#foldWhileLeftL" class="extmbr">Iterant.foldWhileLeftL</a> for the strict version.</p></span></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#foldWhileLeftL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foldWhileLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;Either[S,S])(implicitF:cats.effect.Sync[F]):F[S]"></a><a id="foldWhileLeftL[S](=&gt;S)((S,A)=&gt;Either[S,S])(Sync[F]):F[S]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#foldWhileLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;Either[S,S])(implicitF:cats.effect.Sync[F]):F[S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foldWhileLeftL</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: =&gt; <span name="monix.tail.Iterant.foldWhileLeftL.S" class="extype">S</span></span>)</span><span class="params">(<span name="op">op: (<span name="monix.tail.Iterant.foldWhileLeftL.S" class="extype">S</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <span name="scala.Either" class="extype">Either</span>[<span name="monix.tail.Iterant.foldWhileLeftL.S" class="extype">S</span>, <span name="monix.tail.Iterant.foldWhileLeftL.S" class="extype">S</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<span name="monix.tail.Iterant.foldWhileLeftL.S" class="extype">S</span>]</span></span><p class="shortcomment cmt">Left associative fold using the function <code>op</code> that can be
short-circuited.</p><div class="fullcomment"><div class="comment cmt"><p>Left associative fold using the function <code>op</code> that can be
short-circuited.</p><p>On execution the stream will be traversed from left to right,
and the given function will be called with the prior result,
accumulating state either until the end, or until <code>op</code> returns
a <code>Right</code> result, when the summary is returned.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Sums first 10 items</span>
Iterant[Task].range(<span class="num">0</span>, <span class="num">1000</span>).foldWhileLeftL((<span class="num">0</span>, <span class="num">0</span>)) {
  <span class="kw">case</span> ((sum, count), e) <span class="kw">=&gt;</span>
    <span class="kw">val</span> next = (sum + e, count + <span class="num">1</span>)
    <span class="kw">if</span> (count + <span class="num">1</span> &lt; <span class="num">10</span>) Left(next) <span class="kw">else</span> Right(next)
}

<span class="cmt">// Implements exists(predicate)</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).foldWhileLeftL(<span class="kw">false</span>) {
  (default, e) <span class="kw">=&gt;</span>
    <span class="kw">if</span> (e == <span class="num">3</span>) Right(<span class="kw">true</span>) <span class="kw">else</span> Left(default)
}

<span class="cmt">// Implements forall(predicate)</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>).foldWhileLeftL(<span class="kw">true</span>) {
  (default, e) <span class="kw">=&gt;</span>
    <span class="kw">if</span> (e != <span class="num">3</span>) Right(<span class="kw">false</span>) <span class="kw">else</span> Left(default)
}</pre></div><dl class="paramcmts block"><dt class="param">seed</dt><dd class="cmt"><p>is the start value</p></dd><dt class="param">op</dt><dd class="cmt"><p>is the binary operator returning either <code>Left</code>,
       signaling that the state should be evolved or a <code>Right</code>,
       signaling that the process can be short-circuited and
       the result returned immediately</p></dd><dt>returns</dt><dd class="cmt"><p>the result of inserting <code>op</code> between consecutive
        elements of this iterant, going from left to right with
        the <code>seed</code> as the start value, or <code>seed</code> if the iterant
        is empty</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Iterant.html#foldWhileLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;Either[S,S])(implicitF:cats.effect.Sync[F]):F[S]" name="monix.tail.Iterant#foldWhileLeftL" id="monix.tail.Iterant#foldWhileLeftL" class="extmbr">Iterant.foldWhileLeftL</a> for the lazy, potentially
     asynchronous version.</p></span></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#forallL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="forallL(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):F[Boolean]"></a><a id="forallL((A)=&gt;Boolean)(Sync[F]):F[Boolean]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#forallL(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):F[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">forallL</span><span class="params">(<span name="p">p: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a>]</span></span><p class="shortcomment cmt">Returns <code>true</code> in case the given predicate is satisfied by all
of the emitted items, or <code>false</code> in case the given predicate
fails for any of those items.</p><div class="fullcomment"><div class="comment cmt"><p>Returns <code>true</code> in case the given predicate is satisfied by all
of the emitted items, or <code>false</code> in case the given predicate
fails for any of those items.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Coeval

<span class="kw">val</span> source = Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>)

<span class="cmt">// Yields false</span>
source.forallL(_ % <span class="num">2</span> == <span class="num">0</span>)

<span class="cmt">// Yields true</span>
source.existsL(_ &lt; <span class="num">10</span>)</pre></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is a predicate function that's going to test each item
       emitted by the source until we get a negative match for
       one of them or until the stream ends</p></dd><dt>returns</dt><dd class="cmt"><p><code>true</code> if all of the items satisfy the given predicate
       or <code>false</code> if any of them don't</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#foreach" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foreach(cb:A=&gt;Unit)(implicitF:cats.effect.Sync[F]):F[Unit]"></a><a id="foreach((A)=&gt;Unit)(Sync[F]):F[Unit]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#foreach(cb:A=&gt;Unit)(implicitF:cats.effect.Sync[F]):F[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foreach</span><span class="params">(<span name="cb">cb: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Consumes the source iterable, executing the given callback for
each element.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes the source iterable, executing the given callback for
each element.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Prints all elements, each one on a different line</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>).foreach { elem <span class="kw">=&gt;</span>
  println(<span class="lit">"Elem: "</span> + elem.toString)
}</pre></div><dl class="paramcmts block"><dt class="param">cb</dt><dd class="cmt"><p>is the callback to call for each element emitted
       by the source.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]"></a><a id="getClass():Class[_&lt;:AnyRef]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html#java.lang.Class" name="java.lang.Class" id="java.lang.Class" class="extype">Class</a>[_ &lt;: <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#guarantee" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="guarantee(f:F[Unit])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="guarantee(F[Unit])(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#guarantee(f:F[Unit])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">guarantee</span><span class="params">(<span name="f">f: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Given a routine make sure to execute it whenever the current
stream reaches the end, successfully, in error, or canceled.</p><div class="fullcomment"><div class="comment cmt"><p>Given a routine make sure to execute it whenever the current
stream reaches the end, successfully, in error, or canceled.</p><p>Implements <code>cats.effect.Bracket.guarantee</code>.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="kw">def</span> iterant: Iterant[Task, <span class="std">Int</span>] =
  Iterant.delay(???)

iterant.guarantee(Task.eval {
  println(<span class="lit">"Releasing resources!"</span>)
})</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the function to execute on early stop</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#guaranteeCase" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="guaranteeCase(f:cats.effect.ExitCase[Throwable]=&gt;F[Unit])(implicitF:cats.Applicative[F]):monix.tail.Iterant[F,A]"></a><a id="guaranteeCase((ExitCase[Throwable])=&gt;F[Unit])(Applicative[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#guaranteeCase(f:cats.effect.ExitCase[Throwable]=&gt;F[Unit])(implicitF:cats.Applicative[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">guaranteeCase</span><span class="params">(<span name="f">f: (<span name="cats.effect.ExitCase" class="extype">ExitCase</span>[<span name="scala.Throwable" class="extype">Throwable</span>]) =&gt; <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <a href="http://typelevel.org/cats/api/cats/Applicative.html#cats.Applicative" name="cats.Applicative" id="cats.Applicative" class="extype">Applicative</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns a new iterant in which <code>f</code> is scheduled to be executed
on <a href="Iterant$$Halt.html" name="monix.tail.Iterant.Halt" id="monix.tail.Iterant.Halt" class="extype">halt</a> or if canceled.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new iterant in which <code>f</code> is scheduled to be executed
on <a href="Iterant$$Halt.html" name="monix.tail.Iterant.Halt" id="monix.tail.Iterant.Halt" class="extype">halt</a> or if canceled.</p><p>Implements <code>cats.effect.Bracket.guaranteeCase</code>.</p><p>This would typically be used to ensure that a finalizer
will run at the end of the stream.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> cats.effect.ExitCase

<span class="kw">def</span> iterant: Iterant[Task, <span class="std">Int</span>] =
  Iterant.delay(???)

iterant.guaranteeCase(err <span class="kw">=&gt;</span> Task.eval {
  err <span class="kw">match</span> {
    <span class="kw">case</span> ExitCase.Completed <span class="kw">=&gt;</span>
      println(<span class="lit">"Completed successfully!"</span>)
    <span class="kw">case</span> ExitCase.Error(e) <span class="kw">=&gt;</span>
      e.printStackTrace()
    <span class="kw">case</span> ExitCase.Canceled <span class="kw">=&gt;</span>
      println(<span class="lit">"Was stopped early!"</span>)
  }
})</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the finalizer to execute when streaming is
       terminated, by successful completion, error or
       cancellation</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#headOptionL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="headOptionL(implicitF:cats.effect.Sync[F]):F[Option[A]]"></a><a id="headOptionL(Sync[F]):F[Option[A]]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#headOptionL(implicitF:cats.effect.Sync[F]):F[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">headOptionL</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Optionally selects the first element.</p><div class="fullcomment"><div class="comment cmt"><p>Optionally selects the first element.</p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields Some(1)</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).headOptionL

<span class="cmt">// Yields None</span>
Iterant[Task].empty[<span class="std">Int</span>].headOptionL</pre></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the first element of this iterant if it is nonempty, or
        <code>None</code> if it is empty, in the <code>F</code> context.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#interleave" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="interleave[B&gt;:A](rhs:monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="interleave[B&gt;:A](Iterant[F,B])(Sync[F]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#interleave[B&gt;:A](rhs:monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">interleave</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span></span>]</span><span class="params">(<span name="rhs">rhs: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.interleave.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.interleave.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Lazily interleaves two iterants together, starting with the first
element from <code>self</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Lazily interleaves two iterants together, starting with the first
element from <code>self</code>.</p><p>The length of the result will be the shorter of the two
arguments.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="kw">val</span> lh = Iterant[Task].of(<span class="num">11</span>, <span class="num">12</span>)
<span class="kw">val</span> rh = Iterant[Task].of(<span class="num">21</span>, <span class="num">22</span>, <span class="num">23</span>)

<span class="cmt">// Yields 11, 21, 12, 22</span>
lh.interleave(rh)</pre></div><dl class="paramcmts block"><dt class="param">rhs</dt><dd class="cmt"><p>is the other iterant to interleave the source with (the
       right hand side)</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#intersperse" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="intersperse(start:A,separator:A,end:A)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="intersperse(A,A,A)(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#intersperse(start:A,separator:A,end:A)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">intersperse</span><span class="params">(<span name="start">start: <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span></span>, <span name="separator">separator: <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span></span>, <span name="end">end: <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new stream from the source that will emit the <code>start</code> element
followed by the upstream elements paired with the <code>separator</code>
and lastly the <code>end</code> element.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new stream from the source that will emit the <code>start</code> element
followed by the upstream elements paired with the <code>separator</code>
and lastly the <code>end</code> element.</p><pre><span class="kw">import</span> monix.eval.Coeval

<span class="cmt">// Yields '&lt;', 'a', '-', 'b', '&gt;'</span>
Iterant[Coeval].of(<span class="lit">'a'</span>, <span class="lit">'b'</span>).intersperse(<span class="lit">'<'</span>, <span class="lit">'-'</span>, <span class="lit">'>'</span>)</pre></div><dl class="paramcmts block"><dt class="param">start</dt><dd class="cmt"><p>the first element emitted</p></dd><dt class="param">separator</dt><dd class="cmt"><p>the separator</p></dd><dt class="param">end</dt><dd class="cmt"><p>the last element emitted</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#intersperse" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="intersperse(separator:A)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="intersperse(A)(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#intersperse(separator:A)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">intersperse</span><span class="params">(<span name="separator">separator: <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new stream from the source that will emit a specific <code>separator</code>
between every pair of elements.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new stream from the source that will emit a specific <code>separator</code>
between every pair of elements.</p><pre><span class="kw">import</span> monix.eval.Coeval

<span class="cmt">// Yields 1, 0, 2, 0, 3</span>
Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>).intersperse(<span class="num">0</span>)</pre></div><dl class="paramcmts block"><dt class="param">separator</dt><dd class="cmt"><p>the separator</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#lastOptionL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="lastOptionL(implicitF:cats.effect.Sync[F]):F[Option[A]]"></a><a id="lastOptionL(Sync[F]):F[Option[A]]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#lastOptionL(implicitF:cats.effect.Sync[F]):F[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">lastOptionL</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Optionally selects the last element.</p><div class="fullcomment"><div class="comment cmt"><p>Optionally selects the last element.</p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields Some(4)</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).lastOptionL

<span class="cmt">// Yields None</span>
Iterant[Task].empty[<span class="std">Int</span>].lastOptionL</pre></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the last element of this iterant if it is nonempty, or
        <code>None</code> if it is empty, in the <code>F</code> context.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#map" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="map[B](f:A=&gt;B)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="map[B]((A)=&gt;B)(Sync[F]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#map[B](f:A=&gt;B)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">map</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <span name="monix.tail.Iterant.map.B" class="extype">B</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.map.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a new stream by mapping the supplied function over the
elements of the source.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new stream by mapping the supplied function over the
elements of the source.</p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 2, 4, 6</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>).map(_ * <span class="num">2</span>)</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the mapping function that transforms the source</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant that's the result of mapping the given
        function over the source</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#mapBatch" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mapBatch[B](f:A=&gt;monix.tail.batches.Batch[B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="mapBatch[B]((A)=&gt;Batch[B])(Sync[F]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#mapBatch[B](f:A=&gt;monix.tail.batches.Batch[B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mapBatch</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <a href="batches/Batch.html" name="monix.tail.batches.Batch" id="monix.tail.batches.Batch" class="extype">Batch</a>[<span name="monix.tail.Iterant.mapBatch.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.mapBatch.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns a new stream by mapping the supplied function over the
elements of the source yielding <code>Iterant</code> consisting of <code>NextBatch</code> nodes.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new stream by mapping the supplied function over the
elements of the source yielding <code>Iterant</code> consisting of <code>NextBatch</code> nodes.</p><pre><span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> monix.tail.batches.Batch

<span class="cmt">// Yields 1, 2, 3, 4, 5</span>
Iterant[Task].of(<span class="std">List</span>(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>), <span class="std">List</span>(<span class="num">4</span>), <span class="std">List</span>(<span class="num">5</span>)).mapBatch(Batch.fromSeq(_))
<span class="cmt">// Yields 2, 4, 6</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>).mapBatch(x <span class="kw">=&gt;</span> Batch(x * <span class="num">2</span>))</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the mapping function that transforms the source into batches.</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant that's the result of mapping the given
        function over the source</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#mapEval" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mapEval[B](f:A=&gt;F[B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="mapEval[B]((A)=&gt;F[B])(Sync[F]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#mapEval[B](f:A=&gt;F[B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mapEval</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<span name="monix.tail.Iterant.mapEval.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.mapEval.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Given a mapping function that returns a possibly lazy or
asynchronous result, applies it over the elements emitted by the
stream.</p><div class="fullcomment"><div class="comment cmt"><p>Given a mapping function that returns a possibly lazy or
asynchronous result, applies it over the elements emitted by the
stream.</p><pre><span class="kw">import</span> monix.eval.Task

Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).mapEval { elem <span class="kw">=&gt;</span>
  Task.eval {
    println(<span class="lit">"Received: "</span> + elem.toString)
    elem * <span class="num">2</span>
  }
}</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the mapping function that transforms the source</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant that's the result of mapping the given
        function over the source,</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#mapK" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="mapK[G[_]](f:F~&gt;G)(implicitG:cats.effect.Sync[G]):monix.tail.Iterant[G,A]"></a><a id="mapK[G[_]](~&gt;[F,G])(Sync[G]):Iterant[G,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#mapK[G[_]](f:F~&gt;G)(implicitG:cats.effect.Sync[G]):monix.tail.Iterant[G,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">mapK</span><span class="tparams">[<span name="G">G<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="params">(<span name="f">f: <span name="cats.~&gt;" class="extype">~&gt;</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.mapK.G" class="extype">G</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="G">G: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.mapK.G" class="extype">G</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.mapK.G" class="extype">G</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Given a functor transformation from <code>F</code> to <code>G</code>, lifts the source
into an iterant that is going to use the resulting <code>G</code> for
evaluation.</p><div class="fullcomment"><div class="comment cmt"><p>Given a functor transformation from <code>F</code> to <code>G</code>, lifts the source
into an iterant that is going to use the resulting <code>G</code> for
evaluation.</p><p>This can be used for replacing the underlying <code>F</code> type into
something else. For example say we have an iterant that uses
<code>monix.eval.Coeval</code>, but we want to convert it into
one that uses <code>monix.eval.Task</code> for evaluation:</p><pre><span class="kw">import</span> cats.~&gt;
<span class="kw">import</span> monix.eval._

<span class="cmt">// Source is using Coeval for evaluation</span>
<span class="kw">val</span> source = Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>)

<span class="cmt">// Transformation to an Iterant of Task</span>
source.mapK(Coeval.liftTo[Task])</pre><p>This operator can be used for more than transforming the <code>F</code>
type into something else.
</p></div><dl class="paramcmts block"><dt class="tparam">G</dt><dd class="cmt"><p>is the data type that is going to drive the evaluation
          of the resulting iterant</p></dd><dt class="param">f</dt><dd class="cmt"><p>is the functor transformation that's used to transform
         the source into an iterant that uses <code>G</code> for evaluation</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#maxByL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="maxByL[K](key:A=&gt;K)(implicitF:cats.effect.Sync[F],implicitK:cats.Order[K]):F[Option[A]]"></a><a id="maxByL[K]((A)=&gt;K)(Sync[F],Order[K]):F[Option[A]]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#maxByL[K](key:A=&gt;K)(implicitF:cats.effect.Sync[F],implicitK:cats.Order[K]):F[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">maxByL</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="key">key: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <span name="monix.tail.Iterant.maxByL.K" class="extype">K</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>, <span name="K">K: <span name="cats.Order" class="extype">Order</span>[<span name="monix.tail.Iterant.maxByL.K" class="extype">K</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Takes the elements of the source iterant and emits the
element that has the maximum key value, where the key is
generated by the given function.</p><div class="fullcomment"><div class="comment cmt"><p>Takes the elements of the source iterant and emits the
element that has the maximum key value, where the key is
generated by the given function.</p><p>Example:</p><pre><span class="kw">import</span> cats.implicits._
<span class="kw">import</span> monix.eval.Coeval

<span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Yields Some(Person("Peter", 23))</span>
Iterant[Coeval].of(Person(<span class="lit">"Peter"</span>, <span class="num">23</span>), Person(<span class="lit">"May"</span>, <span class="num">21</span>))
  .maxByL(_.age)

<span class="cmt">// Yields None</span>
Iterant[Coeval].empty[Person].maxByL(_.age)</pre><h4>Cats Order and Scala Interop</h4><p>        Monix prefers to work with <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> for assessing the order
        of elements that have an ordering defined, instead of
        <a href="https://www.scala-lang.org/api/2.13.3/scala/math/Ordering.html" name="scala.math.Ordering" id="scala.math.Ordering" class="extype">scala.math.Ordering</a>.</p><p>        We do this for consistency, as Monix is now building on top of Cats.
        This may change in the future, depending on what happens with
        <a href="https://github.com/typelevel/cats/issues/2455" target="_blank">typelevel/cats#2455</a>.</p><p>        Building a <code>cats.Order</code> is easy to do if you already have a
        Scala <code>Ordering</code> instance:</p><pre><span class="kw">import</span> cats.Order

<span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Starting from a Scala Ordering</span>
<span class="kw">implicit</span> <span class="kw">val</span> scalaOrderingForPerson: Ordering[Person] =
  <span class="kw">new</span> Ordering[Person] {
    <span class="kw">def</span> compare(x: Person, y: Person): <span class="std">Int</span> =
      x.age.compareTo(y.age) <span class="kw">match</span> {
        <span class="kw">case</span> <span class="num">0</span> <span class="kw">=&gt;</span> x.name.compareTo(y.name)
        <span class="kw">case</span> o <span class="kw">=&gt;</span> o
      }
  }

<span class="cmt">// Building a cats.Order from it</span>
<span class="kw">implicit</span> <span class="kw">val</span> catsOrderForPerson: Order[Person] =
  Order.fromOrdering</pre><p>        You can also do that in reverse, so you can prefer <code>cats.Order</code>
        (due to Cats also exposing laws and tests for free) and build a
        Scala <code>Ordering</code> when needed:</p><pre><span class="kw">val</span> scalaOrdering = catsOrderForPerson.toOrdering</pre></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>is the function that returns the key for which the
           given ordering is defined</p></dd><dt class="param">K</dt><dd class="cmt"><p>is the <code>cats.Order</code> type class instance that's going
          to be used for comparing elements</p></dd><dt>returns</dt><dd class="cmt"><p>the maximum element of the source stream, relative
        to its key generated by the given function and the
        given ordering</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#maxL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="maxL(implicitF:cats.effect.Sync[F],implicitA:cats.Order[A]):F[Option[A]]"></a><a id="maxL(Sync[F],Order[A]):F[Option[A]]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#maxL(implicitF:cats.effect.Sync[F],implicitA:cats.Order[A]):F[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">maxL</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>, <span name="A">A: <span name="cats.Order" class="extype">Order</span>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Given a <code>cats.Order</code> over the stream's elements, returns the
maximum element in the stream.</p><div class="fullcomment"><div class="comment cmt"><p>Given a <code>cats.Order</code> over the stream's elements, returns the
maximum element in the stream.</p><p>Example:</p><pre><span class="kw">import</span> cats.implicits._
<span class="kw">import</span> monix.eval.Coeval

<span class="cmt">// Yields Some(20)</span>
Iterant[Coeval].of(<span class="num">1</span>, <span class="num">10</span>, <span class="num">7</span>, <span class="num">6</span>, <span class="num">8</span>, <span class="num">20</span>, <span class="num">3</span>, <span class="num">5</span>).maxL

<span class="cmt">// Yields None</span>
Iterant[Coeval].empty[<span class="std">Int</span>].maxL</pre><h4>Cats Order and Scala Interop</h4><p>        Monix prefers to work with <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> for assessing the order
        of elements that have an ordering defined, instead of
        <a href="https://www.scala-lang.org/api/2.13.3/scala/math/Ordering.html" name="scala.math.Ordering" id="scala.math.Ordering" class="extype">scala.math.Ordering</a>.</p><p>        We do this for consistency, as Monix is now building on top of Cats.
        This may change in the future, depending on what happens with
        <a href="https://github.com/typelevel/cats/issues/2455" target="_blank">typelevel/cats#2455</a>.</p><p>        Building a <code>cats.Order</code> is easy to do if you already have a
        Scala <code>Ordering</code> instance:</p><pre><span class="kw">import</span> cats.Order

<span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Starting from a Scala Ordering</span>
<span class="kw">implicit</span> <span class="kw">val</span> scalaOrderingForPerson: Ordering[Person] =
  <span class="kw">new</span> Ordering[Person] {
    <span class="kw">def</span> compare(x: Person, y: Person): <span class="std">Int</span> =
      x.age.compareTo(y.age) <span class="kw">match</span> {
        <span class="kw">case</span> <span class="num">0</span> <span class="kw">=&gt;</span> x.name.compareTo(y.name)
        <span class="kw">case</span> o <span class="kw">=&gt;</span> o
      }
  }

<span class="cmt">// Building a cats.Order from it</span>
<span class="kw">implicit</span> <span class="kw">val</span> catsOrderForPerson: Order[Person] =
  Order.fromOrdering</pre><p>        You can also do that in reverse, so you can prefer <code>cats.Order</code>
        (due to Cats also exposing laws and tests for free) and build a
        Scala <code>Ordering</code> when needed:</p><pre><span class="kw">val</span> scalaOrdering = catsOrderForPerson.toOrdering</pre></div><dl class="paramcmts block"><dt class="param">A</dt><dd class="cmt"><p>is the <code>cats.Order</code> type class instance that's going
         to be used for comparing elements</p></dd><dt>returns</dt><dd class="cmt"><p>the maximum element of the source stream, relative
        to the defined <code>Order</code></p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#minByL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="minByL[K](key:A=&gt;K)(implicitF:cats.effect.Sync[F],implicitK:cats.Order[K]):F[Option[A]]"></a><a id="minByL[K]((A)=&gt;K)(Sync[F],Order[K]):F[Option[A]]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#minByL[K](key:A=&gt;K)(implicitF:cats.effect.Sync[F],implicitK:cats.Order[K]):F[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">minByL</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="key">key: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <span name="monix.tail.Iterant.minByL.K" class="extype">K</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>, <span name="K">K: <span name="cats.Order" class="extype">Order</span>[<span name="monix.tail.Iterant.minByL.K" class="extype">K</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Takes the elements of the source iterant and emits the
element that has the minimum key value, where the key is
generated by the given function.</p><div class="fullcomment"><div class="comment cmt"><p>Takes the elements of the source iterant and emits the
element that has the minimum key value, where the key is
generated by the given function.</p><p>Example:</p><pre><span class="kw">import</span> cats.implicits._
<span class="kw">import</span> monix.eval.Coeval

<span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Yields Some(Person("May", 21))</span>
Iterant[Coeval].of(Person(<span class="lit">"Peter"</span>, <span class="num">23</span>), Person(<span class="lit">"May"</span>, <span class="num">21</span>))
  .minByL(_.age)

<span class="cmt">// Yields None</span>
Iterant[Coeval].empty[Person].minByL(_.age)</pre><h4>Cats Order and Scala Interop</h4><p>        Monix prefers to work with <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> for assessing the order
        of elements that have an ordering defined, instead of
        <a href="https://www.scala-lang.org/api/2.13.3/scala/math/Ordering.html" name="scala.math.Ordering" id="scala.math.Ordering" class="extype">scala.math.Ordering</a>.</p><p>        We do this for consistency, as Monix is now building on top of Cats.
        This may change in the future, depending on what happens with
        <a href="https://github.com/typelevel/cats/issues/2455" target="_blank">typelevel/cats#2455</a>.</p><p>        Building a <code>cats.Order</code> is easy to do if you already have a
        Scala <code>Ordering</code> instance:</p><pre><span class="kw">import</span> cats.Order

<span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Starting from a Scala Ordering</span>
<span class="kw">implicit</span> <span class="kw">val</span> scalaOrderingForPerson: Ordering[Person] =
  <span class="kw">new</span> Ordering[Person] {
    <span class="kw">def</span> compare(x: Person, y: Person): <span class="std">Int</span> =
      x.age.compareTo(y.age) <span class="kw">match</span> {
        <span class="kw">case</span> <span class="num">0</span> <span class="kw">=&gt;</span> x.name.compareTo(y.name)
        <span class="kw">case</span> o <span class="kw">=&gt;</span> o
      }
  }

<span class="cmt">// Building a cats.Order from it</span>
<span class="kw">implicit</span> <span class="kw">val</span> catsOrderForPerson: Order[Person] =
  Order.fromOrdering</pre><p>        You can also do that in reverse, so you can prefer <code>cats.Order</code>
        (due to Cats also exposing laws and tests for free) and build a
        Scala <code>Ordering</code> when needed:</p><pre><span class="kw">val</span> scalaOrdering = catsOrderForPerson.toOrdering</pre></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>is the function that returns the key for which the
           given ordering is defined</p></dd><dt class="param">K</dt><dd class="cmt"><p>is the <code>cats.Order</code> type class instance that's going
          to be used for comparing elements</p></dd><dt>returns</dt><dd class="cmt"><p>the minimum element of the source stream, relative
        to its key generated by the given function and the
        given ordering</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#minL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="minL(implicitF:cats.effect.Sync[F],implicitA:cats.Order[A]):F[Option[A]]"></a><a id="minL(Sync[F],Order[A]):F[Option[A]]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#minL(implicitF:cats.effect.Sync[F],implicitA:cats.Order[A]):F[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">minL</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>, <span name="A">A: <span name="cats.Order" class="extype">Order</span>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Given a <code>cats.Order</code> over the stream's elements, returns the
minimum element in the stream.</p><div class="fullcomment"><div class="comment cmt"><p>Given a <code>cats.Order</code> over the stream's elements, returns the
minimum element in the stream.</p><p>Example:</p><pre><span class="kw">import</span> cats.implicits._
<span class="kw">import</span> monix.eval.Coeval

<span class="cmt">// Yields Some(3)</span>
Iterant[Coeval].of(<span class="num">10</span>, <span class="num">7</span>, <span class="num">6</span>, <span class="num">8</span>, <span class="num">20</span>, <span class="num">3</span>, <span class="num">5</span>).minL

<span class="cmt">// Yields None</span>
Iterant[Coeval].empty[<span class="std">Int</span>].minL</pre><h4>Cats Order and Scala Interop</h4><p>        Monix prefers to work with <a href="http://typelevel.org/cats/api/cats/index.html#Order[A]=cats.kernel.Order[A]" name="cats" id="cats" class="extype">cats.Order</a> for assessing the order
        of elements that have an ordering defined, instead of
        <a href="https://www.scala-lang.org/api/2.13.3/scala/math/Ordering.html" name="scala.math.Ordering" id="scala.math.Ordering" class="extype">scala.math.Ordering</a>.</p><p>        We do this for consistency, as Monix is now building on top of Cats.
        This may change in the future, depending on what happens with
        <a href="https://github.com/typelevel/cats/issues/2455" target="_blank">typelevel/cats#2455</a>.</p><p>        Building a <code>cats.Order</code> is easy to do if you already have a
        Scala <code>Ordering</code> instance:</p><pre><span class="kw">import</span> cats.Order

<span class="kw">case</span> <span class="kw">class</span> Person(name: <span class="std">String</span>, age: <span class="std">Int</span>)

<span class="cmt">// Starting from a Scala Ordering</span>
<span class="kw">implicit</span> <span class="kw">val</span> scalaOrderingForPerson: Ordering[Person] =
  <span class="kw">new</span> Ordering[Person] {
    <span class="kw">def</span> compare(x: Person, y: Person): <span class="std">Int</span> =
      x.age.compareTo(y.age) <span class="kw">match</span> {
        <span class="kw">case</span> <span class="num">0</span> <span class="kw">=&gt;</span> x.name.compareTo(y.name)
        <span class="kw">case</span> o <span class="kw">=&gt;</span> o
      }
  }

<span class="cmt">// Building a cats.Order from it</span>
<span class="kw">implicit</span> <span class="kw">val</span> catsOrderForPerson: Order[Person] =
  Order.fromOrdering</pre><p>        You can also do that in reverse, so you can prefer <code>cats.Order</code>
        (due to Cats also exposing laws and tests for free) and build a
        Scala <code>Ordering</code> when needed:</p><pre><span class="kw">val</span> scalaOrdering = catsOrderForPerson.toOrdering</pre></div><dl class="paramcmts block"><dt class="param">A</dt><dd class="cmt"><p>is the <code>cats.Order</code> type class instance that's going
         to be used for comparing elements</p></dd><dt>returns</dt><dd class="cmt"><p>the minimum element of the source stream, relative
        to the defined <code>Order</code></p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#onErrorHandle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorHandle[B&gt;:A](f:Throwable=&gt;B)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="onErrorHandle[B&gt;:A]((Throwable)=&gt;B)(Sync[F]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#onErrorHandle[B&gt;:A](f:Throwable=&gt;B)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorHandle</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span></span>]</span><span class="params">(<span name="f">f: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <span name="monix.tail.Iterant.onErrorHandle.B" class="extype">B</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.onErrorHandle.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns an <code>Iterant</code> that mirrors the behavior of the source,
unless the source is terminated with an error, in which
case the streaming of events fallbacks to an iterant
emitting a single element generated by the backup function.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an <code>Iterant</code> that mirrors the behavior of the source,
unless the source is terminated with an error, in which
case the streaming of events fallbacks to an iterant
emitting a single element generated by the backup function.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> monix.execution.exceptions.DummyException

<span class="kw">val</span> prefix = Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>)
<span class="kw">val</span> suffix = Iterant[Task].raiseError[<span class="std">Int</span>](DummyException(<span class="lit">"dummy"</span>))
<span class="kw">val</span> fa = prefix ++ suffix

fa.onErrorHandle { _ <span class="kw">=&gt;</span> <span class="num">5</span> }</pre><p>See <a href="Iterant.html#onErrorRecover[B&gt;:A](pf:PartialFunction[Throwable,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" name="monix.tail.Iterant#onErrorRecover" id="monix.tail.Iterant#onErrorRecover" class="extmbr">onErrorRecover</a> for the version that takes a
partial function as a parameter.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is a function that matches errors with a
       backup element that is emitted when the source
       throws an error.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#onErrorHandleWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorHandleWith[B&gt;:A](f:Throwable=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="onErrorHandleWith[B&gt;:A]((Throwable)=&gt;Iterant[F,B])(Sync[F]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#onErrorHandleWith[B&gt;:A](f:Throwable=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorHandleWith</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span></span>]</span><span class="params">(<span name="f">f: (<span name="scala.Throwable" class="extype">Throwable</span>) =&gt; <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.onErrorHandleWith.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.onErrorHandleWith.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns an <code>Iterant</code> that mirrors the behavior of the source,
unless the source is terminated with an error, in which case
the streaming of events continues with the specified backup
sequence generated by the given function.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an <code>Iterant</code> that mirrors the behavior of the source,
unless the source is terminated with an error, in which case
the streaming of events continues with the specified backup
sequence generated by the given function.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> monix.execution.exceptions.DummyException

<span class="kw">val</span> prefix = Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>)
<span class="kw">val</span> suffix = Iterant[Task].raiseError[<span class="std">Int</span>](DummyException(<span class="lit">"dummy"</span>))
<span class="kw">val</span> fa = prefix ++ suffix

fa.onErrorHandleWith {
  <span class="kw">case</span> _: DummyException <span class="kw">=&gt;</span>
    Iterant[Task].pure(<span class="num">5</span>)
  <span class="kw">case</span> other <span class="kw">=&gt;</span>
    Iterant[Task].raiseError[<span class="std">Int</span>](other)
}</pre><p>See <a href="Iterant.html#onErrorRecoverWith[B&gt;:A](pf:PartialFunction[Throwable,monix.tail.Iterant[F,B]])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" name="monix.tail.Iterant#onErrorRecoverWith" id="monix.tail.Iterant#onErrorRecoverWith" class="extmbr">onErrorRecoverWith</a> for the version that takes a partial
function as a parameter.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is a function that matches errors with a
       backup throwable that is subscribed when the source
       throws an error.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#onErrorIgnore" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorIgnore(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="onErrorIgnore(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#onErrorIgnore(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorIgnore</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Returns a new <code>Iterant</code> that mirrors the source, but ignores
any errors in case they happen.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new <code>Iterant</code> that mirrors the source, but ignores
any errors in case they happen.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#onErrorRecover" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRecover[B&gt;:A](pf:PartialFunction[Throwable,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="onErrorRecover[B&gt;:A](PartialFunction[Throwable,B])(Sync[F]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#onErrorRecover[B&gt;:A](pf:PartialFunction[Throwable,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRecover</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span></span>]</span><span class="params">(<span name="pf">pf: <a href="https://www.scala-lang.org/api/2.13.3/scala/PartialFunction.html#scala.PartialFunction" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<span name="scala.Throwable" class="extype">Throwable</span>, <span name="monix.tail.Iterant.onErrorRecover.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.onErrorRecover.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns an <code>Iterant</code> that mirrors the behavior of the source,
unless the source is terminated with an error, in which
case the streaming of events fallbacks to an iterant
emitting a single element generated by the backup function.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an <code>Iterant</code> that mirrors the behavior of the source,
unless the source is terminated with an error, in which
case the streaming of events fallbacks to an iterant
emitting a single element generated by the backup function.</p><p>The created <code>Iterant</code> mirrors the behavior of the source
in case the source does not end with an error or if the
thrown <code>Throwable</code> is not matched.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> monix.execution.exceptions.DummyException

<span class="kw">val</span> prefix = Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>)
<span class="kw">val</span> suffix = Iterant[Task].raiseError[<span class="std">Int</span>](DummyException(<span class="lit">"dummy"</span>))
<span class="kw">val</span> fa = prefix ++ suffix

fa.onErrorRecover {
  <span class="kw">case</span> _: DummyException <span class="kw">=&gt;</span> <span class="num">5</span>
}</pre><p>See <a href="Iterant.html#onErrorHandle[B&gt;:A](f:Throwable=&gt;B)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" name="monix.tail.Iterant#onErrorHandle" id="monix.tail.Iterant#onErrorHandle" class="extmbr">onErrorHandle</a> for the version that takes a
total function as a parameter.
</p></div><dl class="paramcmts block"><dt class="param">pf</dt><dd class="cmt"><p>- a function that matches errors with a
       backup element that is emitted when the source
       throws an error.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#onErrorRecoverWith" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onErrorRecoverWith[B&gt;:A](pf:PartialFunction[Throwable,monix.tail.Iterant[F,B]])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="onErrorRecoverWith[B&gt;:A](PartialFunction[Throwable,Iterant[F,B]])(Sync[F]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#onErrorRecoverWith[B&gt;:A](pf:PartialFunction[Throwable,monix.tail.Iterant[F,B]])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onErrorRecoverWith</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span></span>]</span><span class="params">(<span name="pf">pf: <a href="https://www.scala-lang.org/api/2.13.3/scala/PartialFunction.html#scala.PartialFunction" name="scala.PartialFunction" id="scala.PartialFunction" class="extype">PartialFunction</a>[<span name="scala.Throwable" class="extype">Throwable</span>, <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.onErrorRecoverWith.B" class="extype">B</span>]]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.onErrorRecoverWith.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Returns an <code>Iterant</code> that mirrors the behavior of the source,
unless the source is terminated with an error, in which case
the streaming of events continues with the specified backup
sequence generated by the given partial function.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an <code>Iterant</code> that mirrors the behavior of the source,
unless the source is terminated with an error, in which case
the streaming of events continues with the specified backup
sequence generated by the given partial function.</p><p>The created <code>Iterant</code> mirrors the behavior of the source in
case the source does not end with an error or if the thrown
<code>Throwable</code> is not matched.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> monix.execution.exceptions.DummyException

<span class="kw">val</span> prefix = Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>)
<span class="kw">val</span> suffix = Iterant[Task].raiseError[<span class="std">Int</span>](DummyException(<span class="lit">"dummy"</span>))
<span class="kw">val</span> fa = prefix ++ suffix

fa.onErrorRecoverWith {
  <span class="kw">case</span> _: DummyException <span class="kw">=&gt;</span>
    Iterant[Task].pure(<span class="num">5</span>)
}</pre><p>See <a href="Iterant.html#onErrorHandleWith[B&gt;:A](f:Throwable=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" name="monix.tail.Iterant#onErrorHandleWith" id="monix.tail.Iterant#onErrorHandleWith" class="extmbr">onErrorHandleWith</a> for the version that takes a total
function as a parameter.
</p></div><dl class="paramcmts block"><dt class="param">pf</dt><dd class="cmt"><p>is a function that matches errors with a
       backup throwable that is subscribed when the source
       throws an error.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#parZip" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="parZip[B](rhs:monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F],implicitP:cats.Parallel[F]):monix.tail.Iterant[F,(A,B)]"></a><a id="parZip[B](Iterant[F,B])(Sync[F],Parallel[F]):Iterant[F,(A,B)]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#parZip[B](rhs:monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F],implicitP:cats.Parallel[F]):monix.tail.Iterant[F,(A,B)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parZip</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="rhs">rhs: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.parZip.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>, <span name="P">P: <a href="http://typelevel.org/cats/api/cats/Parallel.html#cats.Parallel" name="cats.Parallel" id="cats.Parallel" class="extype">Parallel</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>, <span name="monix.tail.Iterant.parZip.B" class="extype">B</span>)]</span></span><p class="shortcomment cmt">Lazily zip two iterants together, the elements of the emitted
tuples being fetched in parallel.</p><div class="fullcomment"><div class="comment cmt"><p>Lazily zip two iterants together, the elements of the emitted
tuples being fetched in parallel.</p><p>This is the parallel version of <a href="Iterant.html#zip[B](rhs:monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,(A,B)]" name="monix.tail.Iterant#zip" id="monix.tail.Iterant#zip" class="extmbr">zip</a>, the results are
still ordered, but it can yield non-deterministic ordering
of effects when fetching the elements of an emitted tuple.
</p></div><dl class="paramcmts block"><dt class="param">rhs</dt><dd class="cmt"><p>is the other iterant to zip the source with (the
       right hand side)</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#parZipMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="parZipMap[B,C](rhs:monix.tail.Iterant[F,B])(f:(A,B)=&gt;C)(implicitF:cats.effect.Sync[F],implicitP:cats.Parallel[F]):monix.tail.Iterant[F,C]"></a><a id="parZipMap[B,C](Iterant[F,B])((A,B)=&gt;C)(Sync[F],Parallel[F]):Iterant[F,C]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#parZipMap[B,C](rhs:monix.tail.Iterant[F,B])(f:(A,B)=&gt;C)(implicitF:cats.effect.Sync[F],implicitP:cats.Parallel[F]):monix.tail.Iterant[F,C]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">parZipMap</span><span class="tparams">[<span name="B">B</span>, <span name="C">C</span>]</span><span class="params">(<span name="rhs">rhs: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.parZipMap.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>, <span name="monix.tail.Iterant.parZipMap.B" class="extype">B</span>) =&gt; <span name="monix.tail.Iterant.parZipMap.C" class="extype">C</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>, <span name="P">P: <a href="http://typelevel.org/cats/api/cats/Parallel.html#cats.Parallel" name="cats.Parallel" id="cats.Parallel" class="extype">Parallel</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.parZipMap.C" class="extype">C</span>]</span></span><p class="shortcomment cmt">Lazily zip two iterants together, in parallel, using the given
function <code>f</code> to produce output values.</p><div class="fullcomment"><div class="comment cmt"><p>Lazily zip two iterants together, in parallel, using the given
function <code>f</code> to produce output values.</p><p>This is like <a href="Iterant.html#zipMap[B,C](rhs:monix.tail.Iterant[F,B])(f:(A,B)=&gt;C)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,C]" name="monix.tail.Iterant#zipMap" id="monix.tail.Iterant#zipMap" class="extmbr">zipMap</a>, except that the element pairs are
processed in parallel (ordered results, but non-deterministic
ordering of effects).
</p></div><dl class="paramcmts block"><dt class="param">rhs</dt><dd class="cmt"><p>is the other iterant to zip the source with (the
       right hand side)</p></dd><dt class="param">f</dt><dd class="cmt"><p>is the mapping function to transform the zipped
       <code>(A, B)</code> elements</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="scala.Product#productElementNames" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="productElementNames:Iterator[String]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#productElementNames:Iterator[String]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">productElementNames</span><span class="result">: <span name="scala.Iterator" class="extype">Iterator</span>[<span name="scala.Predef.String" class="extype">String</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Product</dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#pushToChannel" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="pushToChannel(channel:monix.tail.Iterant.Producer[F,A])(implicitF:cats.effect.Sync[F]):F[Unit]"></a><a id="pushToChannel(Producer[F,A])(Sync[F]):F[Unit]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#pushToChannel(channel:monix.tail.Iterant.Producer[F,A])(implicitF:cats.effect.Sync[F]):F[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">pushToChannel</span><span class="params">(<span name="channel">channel: <a href="Iterant$.html#Producer[F[_],A]=monix.catnap.ProducerF[F,Option[Throwable],A]" name="monix.tail.Iterant.Producer" id="monix.tail.Iterant.Producer" class="extmbr">Producer</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a>]</span></span><p class="shortcomment cmt">Consumes the source by pushing it to the specified channel.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes the source by pushing it to the specified channel.
</p></div><dl class="paramcmts block"><dt class="param">channel</dt><dd class="cmt"><p>is a <a href="../catnap/ProducerF.html" name="monix.catnap.ProducerF" id="monix.catnap.ProducerF" class="extype">ProducerF</a> value that
       will be used for consuming the stream</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#reduceL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="reduceL(op:(A,A)=&gt;A)(implicitF:cats.effect.Sync[F]):F[Option[A]]"></a><a id="reduceL((A,A)=&gt;A)(Sync[F]):F[Option[A]]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#reduceL(op:(A,A)=&gt;A)(implicitF:cats.effect.Sync[F]):F[Option[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">reduceL</span><span class="params">(<span name="op">op: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Reduces the elements of the source using the specified
associative binary operator, going from left to right, start to
finish.</p><div class="fullcomment"><div class="comment cmt"><p>Reduces the elements of the source using the specified
associative binary operator, going from left to right, start to
finish.</p><p>Example:</p><pre><span class="kw">import</span> monix.eval.Coeval

<span class="cmt">// Yields Some(10)</span>
Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).reduceL(_ + _)

<span class="cmt">// Yields None</span>
Iterant[Coeval].empty[<span class="std">Int</span>].reduceL(_ + _)</pre></div><dl class="paramcmts block"><dt class="param">op</dt><dd class="cmt"><p>is an associative binary operation that's going
          to be used to reduce the source to a single value</p></dd><dt>returns</dt><dd class="cmt"><p>either <code>Some(value)</code> in case the stream is not empty,
        <code>value</code> being the result of inserting <code>op</code> between
        consecutive elements of this iterant, going from left
        to right, or <code>None</code> in case the stream is empty</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#repeat" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="repeat(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="repeat(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#repeat(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">repeat</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Repeats the items emitted by the source continuously</p><div class="fullcomment"><div class="comment cmt"><p>Repeats the items emitted by the source continuously</p><p>It terminates either on error or if the source is empty.</p><p>In case repetition on empty streams is desired, then combine with
<a href="Iterant.html#retryIfEmpty(maxRetries:Option[Int])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" name="monix.tail.Iterant#retryIfEmpty" id="monix.tail.Iterant#retryIfEmpty" class="extmbr">retryIfEmpty</a>:</p><pre><span class="kw">import</span> monix.eval.Coeval
<span class="kw">import</span> scala.util.Random

<span class="kw">val</span> stream = Iterant[Coeval].suspend(Coeval {
  <span class="kw">val</span> nr = Random.nextInt()
  <span class="kw">if</span> (nr % <span class="num">10</span> != <span class="num">0</span>)
    Iterant[Coeval].empty[<span class="std">Int</span>]
  <span class="kw">else</span>
    Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>)
})

<span class="cmt">// Will eventually repeat elements 1, 2, 3</span>
stream.retryIfEmpty(<span class="std">None</span>).repeat</pre></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant.Suspend#rest" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="rest:F[monix.tail.Iterant[F,A]]"></a><a id="rest:F[Iterant[F,A]]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#rest:F[monix.tail.Iterant[F,A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">rest</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]]</span></span></li><li class="indented0 " name="monix.tail.Iterant#retryIfEmpty" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="retryIfEmpty(maxRetries:Option[Int])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="retryIfEmpty(Option[Int])(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#retryIfEmpty(maxRetries:Option[Int])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">retryIfEmpty</span><span class="params">(<span name="maxRetries">maxRetries: <a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Retries processing the source stream after the search is
detected as being empty.</p><div class="fullcomment"><div class="comment cmt"><p>Retries processing the source stream after the search is
detected as being empty.</p><pre><span class="kw">import</span> monix.eval.Coeval
<span class="kw">import</span> scala.util.Random

<span class="kw">val</span> stream = Iterant[Coeval].suspend(Coeval {
  <span class="kw">val</span> nr = Random.nextInt()
  <span class="kw">if</span> (nr % <span class="num">10</span> != <span class="num">0</span>)
    Iterant[Coeval].empty[<span class="std">Int</span>]
  <span class="kw">else</span>
    Iterant[Coeval].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>)
})

<span class="cmt">// Will eventually stream elements 1, 2, 3</span>
stream.retryIfEmpty(<span class="std">None</span>)</pre></div><dl class="paramcmts block"><dt class="param">maxRetries</dt><dd class="cmt"><p>is an optional integer specifying a maximum
       number of retries before it gives up and returns an
       empty stream</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#scan" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scan[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]"></a><a id="scan[S](=&gt;S)((S,A)=&gt;S)(Sync[F]):Iterant[F,S]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#scan[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scan</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: =&gt; <span name="monix.tail.Iterant.scan.S" class="extype">S</span></span>)</span><span class="params">(<span name="op">op: (<span name="monix.tail.Iterant.scan.S" class="extype">S</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <span name="monix.tail.Iterant.scan.S" class="extype">S</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.scan.S" class="extype">S</span>]</span></span><p class="shortcomment cmt">Applies a binary operator to a start value and all elements of
this <code>Iterant</code>, going left to right and returns a new
<code>Iterant</code> that emits on each step the result of the applied
function.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a binary operator to a start value and all elements of
this <code>Iterant</code>, going left to right and returns a new
<code>Iterant</code> that emits on each step the result of the applied
function.</p><p>Similar to <a href="Iterant.html#foldLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):F[S]" name="monix.tail.Iterant#foldLeftL" id="monix.tail.Iterant#foldLeftL" class="extmbr">foldLeftL</a>, but emits the state on each
step. Useful for modeling finite state machines.</p><p>Example showing how state can be evolved and acted upon:</p><pre><span class="kw">import</span> monix.eval.Task

<span class="kw">sealed</span> <span class="kw">trait</span> State[+A] { <span class="kw">def</span> count: <span class="std">Int</span> }
<span class="kw">case</span> <span class="kw">object</span> Init <span class="kw">extends</span> State[<span class="std">Nothing</span>] { <span class="kw">def</span> count = <span class="num">0</span> }
<span class="kw">case</span> <span class="kw">class</span> Current[A](current: A, count: <span class="std">Int</span>) <span class="kw">extends</span> State[A]

<span class="cmt">// Whatever...</span>
<span class="kw">val</span> source = Iterant[Task].range(<span class="num">0</span>, <span class="num">1000</span>)

<span class="kw">val</span> scanned = source.scan(Init : State[<span class="std">Int</span>]) { (acc, a) <span class="kw">=&gt;</span>
  acc <span class="kw">match</span> {
    <span class="kw">case</span> Init <span class="kw">=&gt;</span> Current(a, <span class="num">1</span>)
    <span class="kw">case</span> Current(_, count) <span class="kw">=&gt;</span> Current(a, count + <span class="num">1</span>)
  }
}

scanned
  .takeWhile(_.count &lt; <span class="num">10</span>)
  .collect { <span class="kw">case</span> Current(a, _) <span class="kw">=&gt;</span> a }</pre></div><dl class="paramcmts block"><dt class="param">seed</dt><dd class="cmt"><p>is the initial state</p></dd><dt class="param">op</dt><dd class="cmt"><p>is the function that evolves the current state</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant that emits all intermediate states being
        resulted from applying function <code>op</code></p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Iterant.html#scan0[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]" name="monix.tail.Iterant#scan0" id="monix.tail.Iterant#scan0" class="extmbr">scan0</a> for the version that emits seed element at the beginning</p></span></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#scan0" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scan0[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]"></a><a id="scan0[S](=&gt;S)((S,A)=&gt;S)(Sync[F]):Iterant[F,S]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#scan0[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scan0</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: =&gt; <span name="monix.tail.Iterant.scan0.S" class="extype">S</span></span>)</span><span class="params">(<span name="op">op: (<span name="monix.tail.Iterant.scan0.S" class="extype">S</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <span name="monix.tail.Iterant.scan0.S" class="extype">S</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.scan0.S" class="extype">S</span>]</span></span><p class="shortcomment cmt">Applies a binary operator to a start value and all elements of
this <code>Iterant</code>, going left to right and returns a new
<code>Iterant</code> that emits on each step the result of the applied
function.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a binary operator to a start value and all elements of
this <code>Iterant</code>, going left to right and returns a new
<code>Iterant</code> that emits on each step the result of the applied
function.</p><p>This is a version of <a href="Iterant.html#scan[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]" name="monix.tail.Iterant#scan" id="monix.tail.Iterant#scan" class="extmbr">scan</a> that emits seed element at the beginning,
similar to <code>scanLeft</code> on Scala collections.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#scanEval" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scanEval[S](seed:F[S])(op:(S,A)=&gt;F[S])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]"></a><a id="scanEval[S](F[S])((S,A)=&gt;F[S])(Sync[F]):Iterant[F,S]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#scanEval[S](seed:F[S])(op:(S,A)=&gt;F[S])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scanEval</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<span name="monix.tail.Iterant.scanEval.S" class="extype">S</span>]</span>)</span><span class="params">(<span name="op">op: (<span name="monix.tail.Iterant.scanEval.S" class="extype">S</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<span name="monix.tail.Iterant.scanEval.S" class="extype">S</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.scanEval.S" class="extype">S</span>]</span></span><p class="shortcomment cmt">Applies a binary operator to a start value and all elements of
this <code>Iterant</code>, going left to right and returns a new
<code>Iterant</code> that emits on each step the result of the applied
function.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a binary operator to a start value and all elements of
this <code>Iterant</code>, going left to right and returns a new
<code>Iterant</code> that emits on each step the result of the applied
function.</p><p>Similar with <a href="Iterant.html#scan[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]" name="monix.tail.Iterant#scan" id="monix.tail.Iterant#scan" class="extmbr">scan</a>, but this can suspend and evaluate
side effects in the <code>F[_]</code> context, thus allowing for
asynchronous data processing.</p><p>Similar to <a href="Iterant.html#foldLeftL[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):F[S]" name="monix.tail.Iterant#foldLeftL" id="monix.tail.Iterant#foldLeftL" class="extmbr">foldLeftL</a> and <a href="Iterant.html#foldWhileLeftEvalL[S](seed:F[S])(op:(S,A)=&gt;F[Either[S,S]])(implicitF:cats.effect.Sync[F]):F[S]" name="monix.tail.Iterant#foldWhileLeftEvalL" id="monix.tail.Iterant#foldWhileLeftEvalL" class="extmbr">foldWhileLeftEvalL</a>, but
emits the state on each step. Useful for modeling finite
state machines.</p><p>Example showing how state can be evolved and acted upon:</p><pre><span class="kw">import</span> monix.eval.Task

<span class="kw">sealed</span> <span class="kw">trait</span> State[+A] { <span class="kw">def</span> count: <span class="std">Int</span> }
<span class="kw">case</span> <span class="kw">object</span> Init <span class="kw">extends</span> State[<span class="std">Nothing</span>] { <span class="kw">def</span> count = <span class="num">0</span> }
<span class="kw">case</span> <span class="kw">class</span> Current[A](current: <span class="std">Option</span>[A], count: <span class="std">Int</span>)
  <span class="kw">extends</span> State[A]

<span class="cmt">// Dummies</span>
<span class="kw">case</span> <span class="kw">class</span> Person(id: <span class="std">Int</span>, name: <span class="std">String</span>, age: <span class="std">Int</span>)
<span class="kw">def</span> requestPersonDetails(id: <span class="std">Int</span>): Task[<span class="std">Option</span>[Person]] = Task.delay(???)

<span class="cmt">// Whatever</span>
<span class="kw">val</span> source = Iterant[Task].range(<span class="num">0</span>, <span class="num">1000</span>)
<span class="cmt">// Initial state</span>
<span class="kw">val</span> seed = Task.now(Init : State[Person])

<span class="kw">val</span> scanned = source.scanEval(seed) { (state, id) <span class="kw">=&gt;</span>
  requestPersonDetails(id).map { a <span class="kw">=&gt;</span>
    state <span class="kw">match</span> {
      <span class="kw">case</span> Init <span class="kw">=&gt;</span>
        Current(a, <span class="num">1</span>)
      <span class="kw">case</span> Current(_, count) <span class="kw">=&gt;</span>
        Current(a, count + <span class="num">1</span>)
    }
  }
}

scanned
  .takeWhile(_.count &lt; <span class="num">10</span>)
  .collect { <span class="kw">case</span> Current(<span class="std">Some</span>(a), _) <span class="kw">=&gt;</span> a }</pre></div><dl class="paramcmts block"><dt class="param">seed</dt><dd class="cmt"><p>is the initial state</p></dd><dt class="param">op</dt><dd class="cmt"><p>is the function that evolves the current state</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant that emits all intermediate states being
        resulted from applying the given function</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Iterant.html#scan[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]" name="monix.tail.Iterant#scan" id="monix.tail.Iterant#scan" class="extmbr">scan</a> for the version that does not require using <code>F[_]</code>
     in the provided operator</p></span><span class="cmt"><p><a href="Iterant.html#scanEval0[S](seed:F[S])(op:(S,A)=&gt;F[S])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]" name="monix.tail.Iterant#scanEval0" id="monix.tail.Iterant#scanEval0" class="extmbr">scanEval0</a> for the version that emits seed element at the
     beginning</p></span></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#scanEval0" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scanEval0[S](seed:F[S])(op:(S,A)=&gt;F[S])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]"></a><a id="scanEval0[S](F[S])((S,A)=&gt;F[S])(Sync[F]):Iterant[F,S]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#scanEval0[S](seed:F[S])(op:(S,A)=&gt;F[S])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scanEval0</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="seed">seed: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<span name="monix.tail.Iterant.scanEval0.S" class="extype">S</span>]</span>)</span><span class="params">(<span name="op">op: (<span name="monix.tail.Iterant.scanEval0.S" class="extype">S</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<span name="monix.tail.Iterant.scanEval0.S" class="extype">S</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.scanEval0.S" class="extype">S</span>]</span></span><p class="shortcomment cmt">Applies a binary operator to a start value and all elements of
this <code>Iterant</code>, going left to right and returns a new
<code>Iterant</code> that emits on each step the result of the applied
function.</p><div class="fullcomment"><div class="comment cmt"><p>Applies a binary operator to a start value and all elements of
this <code>Iterant</code>, going left to right and returns a new
<code>Iterant</code> that emits on each step the result of the applied
function.</p><p>This is a version of <a href="Iterant.html#scanEval[S](seed:F[S])(op:(S,A)=&gt;F[S])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]" name="monix.tail.Iterant#scanEval" id="monix.tail.Iterant#scanEval" class="extmbr">scanEval</a> that emits seed element at the beginning,
similar to <code>scanLeft</code> on Scala collections.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#scanMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scanMap[B](f:A=&gt;B)(implicitF:cats.effect.Sync[F],implicitB:cats.Monoid[B]):monix.tail.Iterant[F,B]"></a><a id="scanMap[B]((A)=&gt;B)(Sync[F],Monoid[B]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#scanMap[B](f:A=&gt;B)(implicitF:cats.effect.Sync[F],implicitB:cats.Monoid[B]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scanMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <span name="monix.tail.Iterant.scanMap.B" class="extype">B</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>, <span name="B">B: <span name="cats.Monoid" class="extype">Monoid</span>[<span name="monix.tail.Iterant.scanMap.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.scanMap.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Given a mapping function that returns a <code>B</code> type for which we have
a <a href="http://typelevel.org/cats/api/cats/index.html#Monoid[A]=cats.kernel.Monoid[A]" name="cats" id="cats" class="extype">cats.Monoid</a> instance, returns a new stream that folds the incoming
elements of the sources using the provided <code>Monoid[B].combine</code>, with the
initial seed being the <code>Monoid[B].empty</code> value, emitting the generated values
at each step.</p><div class="fullcomment"><div class="comment cmt"><p>Given a mapping function that returns a <code>B</code> type for which we have
a <a href="http://typelevel.org/cats/api/cats/index.html#Monoid[A]=cats.kernel.Monoid[A]" name="cats" id="cats" class="extype">cats.Monoid</a> instance, returns a new stream that folds the incoming
elements of the sources using the provided <code>Monoid[B].combine</code>, with the
initial seed being the <code>Monoid[B].empty</code> value, emitting the generated values
at each step.</p><p>Equivalent with <a href="Iterant.html#scan[S](seed:=&gt;S)(op:(S,A)=&gt;S)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,S]" name="monix.tail.Iterant#scan" id="monix.tail.Iterant#scan" class="extmbr">scan</a> applied with the given <a href="http://typelevel.org/cats/api/cats/index.html#Monoid[A]=cats.kernel.Monoid[A]" name="cats" id="cats" class="extype">cats.Monoid</a>, so given
our <code>f</code> mapping function returns a <code>B</code>, this law holds:</p><p><code>stream.scanMap(f) &lt;-&gt; stream.scan(Monoid[B].empty)(Monoid[B].combine)</code></p><p>Example:</p><pre><span class="kw">import</span> cats.implicits._
<span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 2, 6, 12, 20, 30, 42</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).scanMap(x <span class="kw">=&gt;</span> x * <span class="num">2</span>)</pre></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the mapping function applied to every incoming element of this <code>Iterant</code>
         before folding using <code>Monoid[B].combine</code></p></dd><dt>returns</dt><dd class="cmt"><p>a new <code>Iterant</code> that emits all intermediate states being
        resulted from applying <code>Monoid[B].combine</code> function</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="Iterant.html#scanMap0[B](f:A=&gt;B)(implicitF:cats.effect.Sync[F],implicitB:cats.Monoid[B]):monix.tail.Iterant[F,B]" name="monix.tail.Iterant#scanMap0" id="monix.tail.Iterant#scanMap0" class="extmbr">scanMap0</a> for the version that emits empty element at the beginning</p></span></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#scanMap0" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scanMap0[B](f:A=&gt;B)(implicitF:cats.effect.Sync[F],implicitB:cats.Monoid[B]):monix.tail.Iterant[F,B]"></a><a id="scanMap0[B]((A)=&gt;B)(Sync[F],Monoid[B]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#scanMap0[B](f:A=&gt;B)(implicitF:cats.effect.Sync[F],implicitB:cats.Monoid[B]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scanMap0</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <span name="monix.tail.Iterant.scanMap0.B" class="extype">B</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>, <span name="B">B: <span name="cats.Monoid" class="extype">Monoid</span>[<span name="monix.tail.Iterant.scanMap0.B" class="extype">B</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.scanMap0.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Given a mapping function that returns a <code>B</code> type for which we have
a <a href="http://typelevel.org/cats/api/cats/index.html#Monoid[A]=cats.kernel.Monoid[A]" name="cats" id="cats" class="extype">cats.Monoid</a> instance, returns a new stream that folds the incoming
elements of the sources using the provided <code>Monoid[B].combine</code>, with the
initial seed being the <code>Monoid[B].empty</code> value, emitting the generated values
at each step.</p><div class="fullcomment"><div class="comment cmt"><p>Given a mapping function that returns a <code>B</code> type for which we have
a <a href="http://typelevel.org/cats/api/cats/index.html#Monoid[A]=cats.kernel.Monoid[A]" name="cats" id="cats" class="extype">cats.Monoid</a> instance, returns a new stream that folds the incoming
elements of the sources using the provided <code>Monoid[B].combine</code>, with the
initial seed being the <code>Monoid[B].empty</code> value, emitting the generated values
at each step.</p><p>This is a version of <a href="Iterant.html#scanMap[B](f:A=&gt;B)(implicitF:cats.effect.Sync[F],implicitB:cats.Monoid[B]):monix.tail.Iterant[F,B]" name="monix.tail.Iterant#scanMap" id="monix.tail.Iterant#scanMap" class="extmbr">scanMap</a> that emits seed element at the beginning.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#sumL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="sumL(implicitF:cats.effect.Sync[F],implicitA:Numeric[A]):F[A]"></a><a id="sumL(Sync[F],Numeric[A]):F[A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#sumL(implicitF:cats.effect.Sync[F],implicitA:Numeric[A]):F[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">sumL</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>, <span name="A">A: <span name="scala.Numeric" class="extype">Numeric</span>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Given evidence that type <code>A</code> has a <code>scala.math.Numeric</code> implementation,
sums the stream of elements.</p><div class="fullcomment"><div class="comment cmt"><p>Given evidence that type <code>A</code> has a <code>scala.math.Numeric</code> implementation,
sums the stream of elements.</p><p>An alternative to <a href="Iterant.html#foldL(implicitF:cats.effect.Sync[F],implicitA:cats.Monoid[A]):F[A]" name="monix.tail.Iterant#foldL" id="monix.tail.Iterant#foldL" class="extmbr">foldL</a> which does not require any imports and works
in cases <code>cats.Monoid</code> is not defined for values (e.g. <code>A = Char</code>)
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#switchIfEmpty" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="switchIfEmpty(backup:monix.tail.Iterant[F,A])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="switchIfEmpty(Iterant[F,A])(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#switchIfEmpty(backup:monix.tail.Iterant[F,A])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">switchIfEmpty</span><span class="params">(<span name="backup">backup: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">In case this Iterant is empty, switch to the given backup.</p><div class="fullcomment"><div class="comment cmt"><p>In case this Iterant is empty, switch to the given backup.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](=&gt;T0):T0"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#tail" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="tail(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="tail(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#tail(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">tail</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Drops the first element of the source iterant, emitting the rest.</p><div class="fullcomment"><div class="comment cmt"><p>Drops the first element of the source iterant, emitting the rest.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 2, 3, 4</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).tail</pre></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a new iterant that upon evaluation will emit all
        elements of the source, except for the head</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#take" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="take(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="take(Int)(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#take(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">take</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new iterant that upon evaluation will select
the first <code>n</code> elements from the source and then stop,
in the order they are emitted by the source.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new iterant that upon evaluation will select
the first <code>n</code> elements from the source and then stop,
in the order they are emitted by the source.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 1, 2, 3</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).take(<span class="num">3</span>)</pre></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>is the number of elements to take from this iterant</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant instance that on evaluation will emit
        only the first <code>n</code> elements of this iterant</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#takeEveryNth" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="takeEveryNth(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="takeEveryNth(Int)(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#takeEveryNth(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">takeEveryNth</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Takes every n-th element, dropping intermediary elements
and returns a new iterant that emits those elements.</p><div class="fullcomment"><div class="comment cmt"><p>Takes every n-th element, dropping intermediary elements
and returns a new iterant that emits those elements.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 2, 4, 6</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).takeEveryNth(<span class="num">2</span>)

<span class="cmt">// Yields 1, 2, 3, 4, 5, 6</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).takeEveryNth(<span class="num">1</span>)</pre></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>is the sequence number of an element to be taken (must be &gt; 0)</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant instance that on evaluation will return only every n-th
        element of the source</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#takeLast" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="takeLast(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="takeLast(Int)(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#takeLast(n:Int)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">takeLast</span><span class="params">(<span name="n">n: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Creates a new iterable that only emits the last <code>n</code> elements
emitted by the source.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new iterable that only emits the last <code>n</code> elements
emitted by the source.</p><p>In case the source triggers an error, then the underlying buffer
gets dropped and the error gets emitted immediately.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 1, 2, 3</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).take(<span class="num">3</span>)</pre></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>is the number of elements to take from the end of the
       stream.</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant instance that on evaluation will emit the
        last <code>n</code> elements of the source</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#takeWhile" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="takeWhile(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="takeWhile((A)=&gt;Boolean)(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#takeWhile(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">takeWhile</span><span class="params">(<span name="p">p: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Takes longest prefix of elements that satisfy the given predicate
and returns a new iterant that emits those elements.</p><div class="fullcomment"><div class="comment cmt"><p>Takes longest prefix of elements that satisfy the given predicate
and returns a new iterant that emits those elements.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 1, 2, 3</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).takeWhile(_ &lt; <span class="num">4</span>)</pre></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is the function that tests each element, stopping
         the streaming on the first <code>false</code> result</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant instance that on evaluation will all
        elements of the source for as long as the given predicate
        returns <code>true</code>, stopping upon the first <code>false</code> result</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#takeWhileWithIndex" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="takeWhileWithIndex(p:(A,Long)=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="takeWhileWithIndex((A,Long)=&gt;Boolean)(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#takeWhileWithIndex(p:(A,Long)=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">takeWhileWithIndex</span><span class="params">(<span name="p">p: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>, <a href="https://www.scala-lang.org/api/2.13.3/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Takes longest prefix of elements zipped with their indices that satisfy the given predicate
and returns a new iterant that emits those elements.</p><div class="fullcomment"><div class="comment cmt"><p>Takes longest prefix of elements zipped with their indices that satisfy the given predicate
and returns a new iterant that emits those elements.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields 1, 2</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>).takeWhileWithIndex((_, idx) <span class="kw">=&gt;</span> idx != <span class="num">2</span>)</pre></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>is the function that tests each element, stopping
         the streaming on the first <code>false</code> result</p></dd><dt>returns</dt><dd class="cmt"><p>a new iterant instance that on evaluation will all
        elements of the source for as long as the given predicate
        returns <code>true</code>, stopping upon the first <code>false</code> result</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#toChannel" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toChannel(implicitF:cats.effect.Concurrent[F],implicitcs:cats.effect.ContextShift[F]):monix.tail.Iterant.Channel[F,A]"></a><a id="toChannel(Concurrent[F],ContextShift[F]):Channel[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#toChannel(implicitF:cats.effect.Concurrent[F],implicitcs:cats.effect.ContextShift[F]):monix.tail.Iterant.Channel[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toChannel</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Concurrent" class="extype">Concurrent</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>, <span name="cs">cs: <span name="cats.effect.ContextShift" class="extype">ContextShift</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant$.html#Channel[F[_],A]=monix.catnap.ChannelF[F,Option[Throwable],A]" name="monix.tail.Iterant.Channel" id="monix.tail.Iterant.Channel" class="extmbr">Channel</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Converts this <code>Iterant</code> to a <a href="../catnap/ChannelF.html" name="monix.catnap.ChannelF" id="monix.catnap.ChannelF" class="extype">monix.catnap.ChannelF</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Converts this <code>Iterant</code> to a <a href="../catnap/ChannelF.html" name="monix.catnap.ChannelF" id="monix.catnap.ChannelF" class="extype">monix.catnap.ChannelF</a>.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#toListL" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toListL(implicitF:cats.effect.Sync[F]):F[List[A]]"></a><a id="toListL(Sync[F]):F[List[A]]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#toListL(implicitF:cats.effect.Sync[F]):F[List[A]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toListL</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>[<span name="scala.List" class="extype">List</span>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]]</span></span><p class="shortcomment cmt">Aggregates all elements in a <code>List</code> and preserves order.</p><div class="fullcomment"><div class="comment cmt"><p>Aggregates all elements in a <code>List</code> and preserves order.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="cmt">// Yields List(1, 2, 3, 4)</span>
Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).toListL</pre><p>Note that this operation is dangerous, since if the iterant is
infinite then this operation is non-terminating, the process
probably blowing up with an out of memory error sooner or later.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#toReactivePublisher" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toReactivePublisher(implicitF:cats.effect.Effect[F]):org.reactivestreams.Publisher[A]"></a><a id="toReactivePublisher(Effect[F]):Publisher[A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#toReactivePublisher(implicitF:cats.effect.Effect[F]):org.reactivestreams.Publisher[A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toReactivePublisher</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Effect" class="extype">Effect</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <span name="org.reactivestreams.Publisher" class="extype">Publisher</span>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Converts this <code>Iterant</code> into an <code>org.reactivestreams.Publisher</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Converts this <code>Iterant</code> into an <code>org.reactivestreams.Publisher</code>.</p><p>Meant for interoperability with other Reactive Streams
implementations. Also useful because it turns the <code>Iterant</code>
into another data type with a push-based communication protocol
with back-pressure.</p><p>Usage sample:</p><pre><span class="kw">import</span> monix.eval.Task
<span class="kw">import</span> monix.execution.rstreams.SingleAssignSubscription
<span class="kw">import</span> org.reactivestreams.{Publisher, Subscriber, Subscription}

<span class="kw">def</span> sum(source: Publisher[<span class="std">Int</span>], requestSize: <span class="std">Int</span>): Task[<span class="std">Long</span>] =
  Task.create { (_, cb) <span class="kw">=&gt;</span>
    <span class="kw">val</span> sub = SingleAssignSubscription()

    source.subscribe(<span class="kw">new</span> Subscriber[<span class="std">Int</span>] {
      <span class="kw">private</span>[<span class="kw">this</span>] <span class="kw">var</span> requested = <span class="num">0</span>L
      <span class="kw">private</span>[<span class="kw">this</span>] <span class="kw">var</span> sum = <span class="num">0</span>L

      <span class="kw">def</span> onSubscribe(s: Subscription): <span class="std">Unit</span> = {
        sub := s
        requested = requestSize
        s.request(requestSize)
      }

      <span class="kw">def</span> onNext(t: <span class="std">Int</span>): <span class="std">Unit</span> = {
        sum += t
        <span class="kw">if</span> (requestSize != <span class="std">Long</span>.MaxValue) requested -= <span class="num">1</span>

        <span class="kw">if</span> (requested &lt;= <span class="num">0</span>) {
          requested = requestSize
          sub.request(requestSize)
        }
      }

      <span class="kw">def</span> onError(t: Throwable): <span class="std">Unit</span> =
        cb.onError(t)
      <span class="kw">def</span> onComplete(): <span class="std">Unit</span> =
        cb.onSuccess(sum)
    })

    <span class="cmt">// Cancelable that can be used by Task</span>
    sub
  }

<span class="cmt">// Needed for `Effect[Task]`</span>
<span class="kw">import</span> monix.execution.Scheduler.Implicits.global

<span class="kw">val</span> pub = Iterant[Task].of(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>).toReactivePublisher

<span class="cmt">// Yields 10</span>
sum(pub, requestSize = <span class="num">128</span>)</pre><p>See the <a href="http://www.reactive-streams.org/" target="_blank">Reactive Streams</a>
for details.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#uncons" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="uncons(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,(Option[A],monix.tail.Iterant[F,A])]"></a><a id="uncons(Sync[F]):Iterant[F,(Option[A],Iterant[F,A])]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#uncons(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,(Option[A],monix.tail.Iterant[F,A])]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">uncons</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, (<a href="https://www.scala-lang.org/api/2.13.3/scala/Option.html#scala.Option" name="scala.Option" id="scala.Option" class="extype">Option</a>[<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>], <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>])]</span></span><p class="shortcomment cmt">Pull the first element out of this Iterant and return it and the rest.</p><div class="fullcomment"><div class="comment cmt"><p>Pull the first element out of this Iterant and return it and the rest.
If the returned Option is None, the remainder is always empty.</p><p>The value returned is wrapped in Iterant to preserve resource safety,
and consumption of the rest must not leak outside of use. The returned
Iterant always contains a single element</p><pre><span class="kw">import</span> cats._, cats.implicits._, cats.effect._

 <span class="kw">def</span> unconsFold[F[_]: Sync, A: Monoid](iterant: Iterant[F, A]): F[A] = {
  <span class="kw">def</span> go(iterant: Iterant[F, A], acc: A): Iterant[F, A] =
    iterant.uncons.flatMap {
      <span class="kw">case</span> (<span class="std">None</span>, _) <span class="kw">=&gt;</span> Iterant.pure(acc)
      <span class="kw">case</span> (<span class="std">Some</span>(a), rest) <span class="kw">=&gt;</span> go(rest, acc |+| a)
    }

  go(iterant, Monoid[A].empty).headOptionL.map(_.getOrElse(Monoid[A].empty))
}</pre></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#unsafeFlatMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="unsafeFlatMap[B](f:A=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]"></a><a id="unsafeFlatMap[B]((A)=&gt;Iterant[F,B])(Sync[F]):Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#unsafeFlatMap[B](f:A=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">unsafeFlatMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.unsafeFlatMap.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.unsafeFlatMap.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Applies the function to the elements of the source and
concatenates the results.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the function to the elements of the source and
concatenates the results.</p><p>This variant of <a href="Iterant.html#flatMap[B](f:A=&gt;monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,B]" name="monix.tail.Iterant#flatMap" id="monix.tail.Iterant#flatMap" class="extmbr">flatMap</a> is not referentially transparent,
because it tries to apply function <code>f</code> immediately, in case the
<code>Iterant</code> is in a <code>NextCursor</code> or <code>NextBatch</code> state.</p><p>To be used for optimizations, but keep in mind it's unsafe, as
its application isn't referentially transparent.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>is the function mapping elements from the source to
       iterants</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#upcast" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="upcast[B&gt;:A]:monix.tail.Iterant[F,B]"></a><a id="upcast[B&gt;:A]:Iterant[F,B]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#upcast[B&gt;:A]:monix.tail.Iterant[F,B]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">upcast</span><span class="tparams">[<span name="B">B &gt;: <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span></span>]</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.upcast.B" class="extype">B</span>]</span></span><p class="shortcomment cmt">Explicit covariance operator.</p><div class="fullcomment"><div class="comment cmt"><p>Explicit covariance operator.</p><p>The <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a> type isn't covariant in type param <code>A</code>, because
covariance doesn't play well with a higher-kinded type like
<code>F[_]</code>.  So in case you have an <code>Iterant[F, A]</code>, but need an
<code>Iterant[F, B]</code>, knowing that <code>A extends B</code>, then you can do an
<code>upcast</code>.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="kw">val</span> source: Iterant[Task, <span class="std">List</span>[<span class="std">Int</span>]] = Iterant.suspend(Task[Iterant[Task, <span class="std">List</span>[<span class="std">Int</span>]]](???))

<span class="cmt">// This will trigger an error because of the invariance:</span>
<span class="cmt">// val sequences: Iterant[Task, Seq[Int]] = source</span>

<span class="cmt">// But this will work just fine:</span>
<span class="kw">val</span> sequence: Iterant[Task, <span class="std">Seq</span>[<span class="std">Int</span>]] = source.upcast[<span class="std">Seq</span>[<span class="std">Int</span>]]</pre></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>, <span name="arg1">arg1: <a href="https://www.scala-lang.org/api/2.13.3/scala/Int.html#scala.Int" name="scala.Int" id="scala.Int" class="extype">Int</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="https://www.scala-lang.org/api/2.13.3/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a></span>)</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#withFilter" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="withFilter(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]"></a><a id="withFilter((A)=&gt;Boolean)(Sync[F]):Iterant[F,A]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#withFilter(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">withFilter</span><span class="params">(<span name="p">p: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>) =&gt; <a href="https://www.scala-lang.org/api/2.13.3/scala/Boolean.html#scala.Boolean" name="scala.Boolean" id="scala.Boolean" class="extype">Boolean</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">Alias to <a href="Iterant.html#filter(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" name="monix.tail.Iterant#filter" id="monix.tail.Iterant#filter" class="extmbr">filter</a> to support syntax in for comprehension, i.e.</p><div class="fullcomment"><div class="comment cmt"><p>Alias to <a href="Iterant.html#filter(p:A=&gt;Boolean)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,A]" name="monix.tail.Iterant#filter" id="monix.tail.Iterant#filter" class="extmbr">filter</a> to support syntax in for comprehension, i.e.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="kw">case</span> <span class="kw">class</span> Person(age: <span class="std">Int</span>)

<span class="kw">val</span> peopleSource: Iterant[Task, Person] =
  Iterant.range[Task](<span class="num">1</span>, <span class="num">100</span>).map(Person.apply)

<span class="kw">for</span> {
  adult <span class="kw">&lt;-</span> peopleSource <span class="kw">if</span> adult.age &gt;= <span class="num">18</span>
} <span class="kw">yield</span> adult</pre></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#zip" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zip[B](rhs:monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,(A,B)]"></a><a id="zip[B](Iterant[F,B])(Sync[F]):Iterant[F,(A,B)]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#zip[B](rhs:monix.tail.Iterant[F,B])(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,(A,B)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zip</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="rhs">rhs: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.zip.B" class="extype">B</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>, <span name="monix.tail.Iterant.zip.B" class="extype">B</span>)]</span></span><p class="shortcomment cmt">Lazily zip two iterants together.</p><div class="fullcomment"><div class="comment cmt"><p>Lazily zip two iterants together.</p><p>The length of the result will be the shorter of the two
arguments.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="kw">val</span> lh = Iterant[Task].of(<span class="num">11</span>, <span class="num">12</span>, <span class="num">13</span>, <span class="num">14</span>)
<span class="kw">val</span> rh = Iterant[Task].of(<span class="num">21</span>, <span class="num">22</span>, <span class="num">23</span>, <span class="num">24</span>, <span class="num">25</span>)

<span class="cmt">// Yields (11, 21), (12, 22), (13, 23), (14, 24)</span>
lh.zip(rh)</pre></div><dl class="paramcmts block"><dt class="param">rhs</dt><dd class="cmt"><p>is the other iterant to zip the source with (the
       right hand side)</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#zipMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zipMap[B,C](rhs:monix.tail.Iterant[F,B])(f:(A,B)=&gt;C)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,C]"></a><a id="zipMap[B,C](Iterant[F,B])((A,B)=&gt;C)(Sync[F]):Iterant[F,C]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#zipMap[B,C](rhs:monix.tail.Iterant[F,B])(f:(A,B)=&gt;C)(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,C]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zipMap</span><span class="tparams">[<span name="B">B</span>, <span name="C">C</span>]</span><span class="params">(<span name="rhs">rhs: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.zipMap.B" class="extype">B</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>, <span name="monix.tail.Iterant.zipMap.B" class="extype">B</span>) =&gt; <span name="monix.tail.Iterant.zipMap.C" class="extype">C</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.zipMap.C" class="extype">C</span>]</span></span><p class="shortcomment cmt">Lazily zip two iterants together, using the given function <code>f</code> to
produce output values.</p><div class="fullcomment"><div class="comment cmt"><p>Lazily zip two iterants together, using the given function <code>f</code> to
produce output values.</p><p>The length of the result will be the shorter of the two
arguments.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="kw">val</span> lh = Iterant[Task].of(<span class="num">11</span>, <span class="num">12</span>, <span class="num">13</span>, <span class="num">14</span>)
<span class="kw">val</span> rh = Iterant[Task].of(<span class="num">21</span>, <span class="num">22</span>, <span class="num">23</span>, <span class="num">24</span>, <span class="num">25</span>)

<span class="cmt">// Yields 32, 34, 36, 38</span>
lh.zipMap(rh) { (a, b) <span class="kw">=&gt;</span> a + b }</pre></div><dl class="paramcmts block"><dt class="param">rhs</dt><dd class="cmt"><p>is the other iterant to zip the source with (the
       right hand side)</p></dd><dt class="param">f</dt><dd class="cmt"><p>is the mapping function to transform the zipped
       <code>(A, B)</code> elements</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li><li class="indented0 " name="monix.tail.Iterant#zipWithIndex" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zipWithIndex(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,(A,Long)]"></a><a id="zipWithIndex(Sync[F]):Iterant[F,(A,Long)]"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#zipWithIndex(implicitF:cats.effect.Sync[F]):monix.tail.Iterant[F,(A,Long)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zipWithIndex</span><span class="params">(<span class="implicit">implicit </span><span name="F">F: <span name="cats.effect.Sync" class="extype">Sync</span>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>]</span>)</span><span class="result">: <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, (<span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>, <a href="https://www.scala-lang.org/api/2.13.3/scala/Long.html#scala.Long" name="scala.Long" id="scala.Long" class="extype">Long</a>)]</span></span><p class="shortcomment cmt">Zips the emitted elements of the source with their indices.</p><div class="fullcomment"><div class="comment cmt"><p>Zips the emitted elements of the source with their indices.</p><p>The length of the result will be the same as the source.</p><p>Example: </p><pre><span class="kw">import</span> monix.eval.Task

<span class="kw">val</span> source = Iterant[Task].of(<span class="lit">"Sunday"</span>, <span class="lit">"Monday"</span>, <span class="lit">"Tuesday"</span>, <span class="lit">"Wednesday"</span>)

<span class="cmt">// Yields ("Sunday", 0), ("Monday", 1), ("Tuesday", 2), ("Wednesday", 3)</span>
source.zipWithIndex</pre></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a></dd></dl></div></li></ol></div><div class="values members"><h3>Deprecated Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit"></a> <span class="permalink"><a href="../../monix/tail/Iterant$$Suspend.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name deprecated" title="Deprecated: ">finalize</span><span class="params">()</span><span class="result">: <a href="https://www.scala-lang.org/api/2.13.3/scala/Unit.html#scala.Unit" name="scala.Unit" id="scala.Unit" class="extype">Unit</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> <span class="name">@Deprecated</span> </dd><dt>Deprecated</dt><dd class="cmt"></dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="monix.tail.Iterant" class="parent"><h3>Inherited from <a href="Iterant.html" name="monix.tail.Iterant" id="monix.tail.Iterant" class="extype">Iterant</a>[<span name="monix.tail.Iterant.Suspend.F" class="extype">F</span>, <span name="monix.tail.Iterant.Suspend.A" class="extype">A</span>]</h3></div><div name="java.io.Serializable" class="parent"><h3>Inherited from <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></h3></div><div name="scala.Product" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.3/scala/Product.html#scala.Product" name="scala.Product" id="scala.Product" class="extype">Product</a></h3></div><div name="scala.Equals" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.3/scala/Equals.html#scala.Equals" name="scala.Equals" id="scala.Equals" class="extype">Equals</a></h3></div><div name="scala.AnyRef" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.3/scala/AnyRef.html#scala.AnyRef" name="scala.AnyRef" id="scala.AnyRef" class="extype">AnyRef</a></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <a href="https://www.scala-lang.org/api/2.13.3/scala/Any.html#scala.Any" name="scala.Any" id="scala.Any" class="extype">Any</a></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
